{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Copyright and other protections apply. Please see the accompanying <code>LICENSE</code> file for rights and restrictions governing use of this software. All rights not expressly waived or licensed are reserved. If that file is missing or appears to be modified from its original, then please contact the author before viewing or using this software in any capacity.</p> <p> </p> <p>Are you defining a numeric interface that should work with more than just <code>int</code>s and <code>float</code>s? Are you annotating that interface for documentation and type-checking? Were you excited by PEP 3141\u2019s glitz and gloss promising a clean, straightforward number type definition mechanism, only to learn the hard way\u2014after many hours of searching, tweaking, hacking, and testing ever more convoluted code, again and again\u2014that you could\u2019t actually make it work with Python\u2019s type-checking system? Do you now wonder whether numbers were something new to computing in general because nothing else would explain such a gaping hole in a programming language so popular with the STEM crowd that has been around since the early 1990s? Does the number 3186 haunt you in your dreams? Do you find yourself shouting to no one in particular, \u201cThere has to be a better way?\u201d</p> <p>Well I\u2019m here to tell you there isn\u2019t. But until there is, there\u2019s \u2026</p>"},{"location":"#numerarynow-with-protocol-powertm","title":"<code>numerary</code>\u2014Now with Protocol Power\u2122","text":"<p>That\u2019s right!</p> <p>For a hopefully limited time, you too can benefit from someone else\u2019s deranged work-arounds for the enormous chasms in Python that lie between the esoteric fields of computation that are \u201ctyping\u201d and \u201cnumbers\u201d instead of having to roll your own out of sheer desperation from first principles! If you still have no idea what I\u2019m talking about, this may help illustrate.</p> <p><code>numerary</code> is a pure-Python codified rant for signaling that your interface is usable with non-native numeric primitives1 without breaking type-checking. More simply, <code>numerary</code> aspires to a world where numbers and types can work together.</p> <p>If you\u2019re thinking that you shouldn\u2019t need a \ud83e\udd2cing library for that, you\u2019re right.</p> <p>This madness should enjoy no audience. It should not exist. Yet here we are. Its author gauges its success by how quickly it can be forgotten, relegated to the annals of superfluous folly.</p> <p><code>numerary</code> is licensed under the MIT License. See the accompanying <code>LICENSE</code> file for details. It should be considered experimental for now, but should settle down quickly. See the release notes for a summary of version-to-version changes. Source code is available on GitHub.</p> <p>If you find it lacking in any way, please don\u2019t hesitate to bring it to my attention.</p>"},{"location":"#you-had-me-at-numbers-and-types-can-work-together","title":"You had me at, \u201cnumbers and types can work together\u201d","text":"<p><code>numerary</code> strives to define composable, efficient protocols that one can use to construct numeric requirements. If all you deal with are integrals and reals, and what you want is broad arithmetic operator compatibility, this will probably get you where you likely want to go:</p> <pre><code>&gt;&gt;&gt; from numerary import IntegralLike, RealLike\n\n&gt;&gt;&gt; def deeper_thot(arg: RealLike) -&gt; IntegralLike:\n...   assert arg != 0 and arg ** 0 == 1\n...   return arg // arg + 42\n</code></pre> <p>Beyond default compositions for common use cases, <code>numerary</code> expands on the <code>Supports</code> pattern used in the standard library. For example, <code>numerary.types.SupportsIntegralOps</code> is a <code>@typing.runtime_checkable</code> protocol that approximates the unary and binary operators introduced by <code>numbers.Integral</code>.</p> <pre><code>&gt;&gt;&gt; from numerary.types import SupportsIntegralOps\n\n&gt;&gt;&gt; def shift_right_one(arg: SupportsIntegralOps) -&gt; SupportsIntegralOps:\n...   assert isinstance(arg, SupportsIntegralOps)\n...   return arg &gt;&gt; 1\n\n&gt;&gt;&gt; shift_right_one(2)\n1\n\n&gt;&gt;&gt; from sympy import sympify\n&gt;&gt;&gt; two = sympify(\"2\") ; type(two)\n&lt;class 'sympy.core.numbers.Integer'&gt;\n&gt;&gt;&gt; res = shift_right_one(two) ; res\n1\n&gt;&gt;&gt; type(res)\n&lt;class 'sympy.core.numbers.One'&gt;\n\n&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; shift_right_one(Fraction(1, 2))  # type: ignore [arg-type]  # properly caught by Mypy\nTraceback (most recent call last):\n  ...\nAssertionError\n</code></pre> <p>Note</p> <p>Until 1.9, <code>sympy.Integer</code> lacked the requisite bitwise operators. <code>numerary</code> catches that! The above properly results in both a type-checking error as well as a runtime failure for SymPy versions prior to 1.9.</p> <p><code>numerary</code>\u2019s <code>Supports</code> protocols can be composed to refine requirements. For example, let\u2019s say one wanted to ensure type compatibility with primitives that support both <code>__abs__</code> and <code>__divmod__</code>.</p> <pre><code>&gt;&gt;&gt; from typing import TypeVar\n&gt;&gt;&gt; T_co = TypeVar(\"T_co\", covariant=True)\n&gt;&gt;&gt; from numerary.types import (\n...   CachingProtocolMeta, Protocol, runtime_checkable,\n...   SupportsAbs, SupportsDivmod,\n... )\n\n&gt;&gt;&gt; @runtime_checkable\n... class MyType(\n...   SupportsAbs[T_co], SupportsDivmod[T_co],\n...   Protocol, metaclass=CachingProtocolMeta,\n... ):\n...   pass\n\n&gt;&gt;&gt; my_type: MyType\n\n&gt;&gt;&gt; my_type = 3.5\n&gt;&gt;&gt; isinstance(my_type, MyType)\nTrue\n&gt;&gt;&gt; abs(my_type)\n3.5\n&gt;&gt;&gt; divmod(my_type, 2)\n(1.0, 1.5)\n\n&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; my_type = Fraction(22, 7)\n&gt;&gt;&gt; isinstance(my_type, MyType)\nTrue\n&gt;&gt;&gt; abs(my_type)\nFraction(22, 7)\n&gt;&gt;&gt; divmod(my_type, 2)\n(1, Fraction(8, 7))\n\n&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt; my_type = Decimal(\"5.2\")\n&gt;&gt;&gt; isinstance(my_type, MyType)\nTrue\n&gt;&gt;&gt; abs(my_type)\nDecimal('5.2')\n&gt;&gt;&gt; divmod(my_type, 2)\n(Decimal('2'), Decimal('1.2'))\n\n&gt;&gt;&gt; my_type = \"nope\"  # type: ignore [assignment]  # properly caught by Mypy\n&gt;&gt;&gt; isinstance(my_type, MyType)\nFalse\n</code></pre> <p>Remember that scandal where <code>complex</code> defined exception-throwing comparators it wasn\u2019t supposed to have, which confused runtime protocol checking, and then its type definitions lied about it to cover it up? Yeah, that shit ends here.</p> <pre><code>&gt;&gt;&gt; from numerary.types import SupportsRealOps\n&gt;&gt;&gt; isinstance(1.0, SupportsRealOps)  # all good\nTrue\n&gt;&gt;&gt; has_real_ops: SupportsRealOps = complex(1)  # type: ignore [assignment]  # properly caught by Mypy\n&gt;&gt;&gt; isinstance(complex(1), SupportsRealOps)  # you're not fooling anyone, buddy\nFalse\n</code></pre> <p><code>numerary</code> not only caches runtime protocol evaluations, but allows overriding those evaluations when the default machinery gets it wrong.</p> <pre><code>&gt;&gt;&gt; from abc import abstractmethod\n&gt;&gt;&gt; from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable\n\n&gt;&gt;&gt; @runtime_checkable\n... class MySupportsOne(Protocol, metaclass=CachingProtocolMeta):\n...   @abstractmethod\n...   def one(self) -&gt; int:\n...     pass\n\n&gt;&gt;&gt; class Imposter:\n...   def one(self) -&gt; str:\n...     return \"one\"\n\n&gt;&gt;&gt; imp: MySupportsOne = Imposter()  # type: ignore [assignment]  # properly caught by Mypy\n&gt;&gt;&gt; isinstance(imp, MySupportsOne)  # fool me once, shame on you ...\nTrue\n\n&gt;&gt;&gt; MySupportsOne.excludes(Imposter)\n&gt;&gt;&gt; isinstance(imp, MySupportsOne)  # ... can't get fooled again\nFalse\n</code></pre> <p><code>numerary</code> has default overrides to correct for known oddities with native types (like our old friend, <code>complex</code>) and with popular libraries like <code>numpy</code>2 and <code>sympy</code>. Others will be added as they are identified. If I\u2019ve missed any, or if you would like <code>numerary</code> to support additional number implementations out of the box, please let me know.</p>"},{"location":"#performance-enhanced-protocolsa-different-kind-of-pep-for-your-step","title":"Performance Enhanced Protocols\u2014A different kind of \u201cPEP\u201d for your step","text":"<p>By default, protocols frustrate runtime type-checking performance.</p> <p>A lot.</p> <p><code>numerary</code> applies two distinct, layered optimization strategies:</p> <ol> <li>Cached <code>__instancecheck__</code> results for <code>numerary</code>-defined protocols; and</li> <li>Optional(-ish) short-circuit type enumerations.</li> </ol>"},{"location":"#cached-__instancecheck__-results","title":"Cached <code>__instancecheck__</code> results","text":"<p>To understand why <code>numerary</code> protocols are faster for runtime checks, it helps to understand why non-<code>numerary</code> protocols are so slow. At runtime (i.e., via <code>isinstance</code>), the default <code>Protocol</code> implementation delegates to <code>type(Protocol).__instancecheck__</code> to perform a crude comparison of an instance\u2019s callable attributes against the protocol\u2019s. More attributes means more comparisons. Further, it performs these comparisons \u2026 Every. Single. \ud83e\udd2cing. Time.</p> <p>Protocols provided by <code>numerary</code> use instead <code>CachingProtocolMeta</code> as their meta class. <code>CachingProtocolMeta</code> derives from <code>type(beartype.typing.Protocol)</code> which caches results based on instance type. <code>numerary</code>\u2019s version allows for runtime check overrides of those results.</p> <p>Conceptually:</p> <pre><code>&gt;&gt;&gt; isinstance(1, SupportsIntegralOps)  # first check for an int is delegated to type(Protocol).__instancecheck__\nTrue\n&gt;&gt;&gt; isinstance(2, SupportsIntegralOps)  # cached result\nTrue\n&gt;&gt;&gt; isinstance(1.0, SupportsIntegralOps)  # the first check for a float is delegated to type(Protocol).__instancecheck__\nFalse\n&gt;&gt;&gt; isinstance(2.0, SupportsIntegralOps)  # cached result\nFalse\n</code></pre> <p>These offer significant performance improvements, especially where protocols define many methods.</p> <pre><code>%timeit isinstance(1, _SupportsComplexOps)\n4.61 \u00b5s \u00b1 20.3 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n%timeit isinstance(1, SupportsComplexOps)\n97.2 ns \u00b1 0.316 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n\n%timeit isinstance(2.0, _SupportsComplexOps)\n4.61 \u00b5s \u00b1 18.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n%timeit isinstance(2.0, SupportsComplexOps)\n98.6 ns \u00b1 1.04 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n\n%timeit isinstance(Decimal('3'), _SupportsComplexOps)\n4.59 \u00b5s \u00b1 50.4 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n%timeit isinstance(Decimal('3'), SupportsComplexOps)\n98.3 ns \u00b1 0.435 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n\n%timeit isinstance(Fraction(4, 1), _SupportsComplexOps)\n4.46 \u00b5s \u00b1 20.1 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n%timeit isinstance(Fraction(4, 1), SupportsComplexOps)\n97.1 ns \u00b1 0.161 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n\n%timeit isinstance(5, _SupportsComplexOps)\n4.53 \u00b5s \u00b1 32.6 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n%timeit isinstance(5, SupportsComplexOps)\n96.2 ns \u00b1 0.317 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n</code></pre> Source: <code>perf_supports_complex.ipy</code> <pre><code>from decimal import Decimal\nfrom fractions import Fraction\nfrom numerary.types import _SupportsComplexOps  # non-caching version\nfrom numerary.types import SupportsComplexOps  # CachingProtocolMeta version\nimport sympy\n\none_int = 1\ntwo_float = 2.0\nthree_dec = Decimal(3)\nfour_frac = Fraction(4)\nfive_sym = sympy.sympify(5)\nvals = (one_int, two_float, three_dec, four_frac, five_sym)\n\nfor v in vals:\n  for t in (\n    _SupportsComplexOps,\n    SupportsComplexOps,\n  ):\n    print(f\"%timeit isinstance({v!r}, {t.__name__})\")\n    %timeit isinstance(v, t)\n  print()\n</code></pre>"},{"location":"#unions-for-inclusion","title":"<code>Union</code>s for inclusion","text":"<p>Sometimes we might want types that don\u2019t comply with protocol definitions to validate anyway (e.g., because we know they will work at runtime). For example, <code>float</code>s in Python versions prior to 3.9 officially lacked <code>__floor__</code> and <code>__ceil__</code> methods, but were registered with the numeric tower and worked just fine with <code>math.floor</code> and <code>math.ceil</code>.</p> <p>How does <code>numerary</code>\u2019s <code>SupportsFloorCeil</code> deal with this situation? Not very well, unfortunately, at least not on its own.</p> <pre><code>&gt;&gt;&gt; import math, sys\n&gt;&gt;&gt; from numerary.types import SupportsFloorCeil\n\n&gt;&gt;&gt; def my_dumb_floor_func(arg: SupportsFloorCeil) -&gt; int:\n...   assert isinstance(arg, SupportsFloorCeil)  # will work, even for floats, thanks to default overrides\n...   return math.floor(arg)  # type: ignore [arg-type]  # doesn't understand SupportsFloorCeil\n\n&gt;&gt;&gt; float_val: float = 1.6180339887\n&gt;&gt;&gt; # For illustration only until &lt;https://github.com/python/mypy/issues/5940&gt; is fixed\n&gt;&gt;&gt; if sys.version_info &lt; (3, 9):\n...   my_dumb_floor_func(float_val)  # type: ignore [arg-type]  # still results in a Mypy error for Python version &lt;3.9\n... else:\n...   my_dumb_floor_func(float_val)  # validates\n1\n</code></pre> <p><code>Union</code>s allow a work-around.</p> <pre><code>&gt;&gt;&gt; from typing import Union\n&gt;&gt;&gt; from numerary.types import SupportsFloorCeil, __floor__\n&gt;&gt;&gt; SupportsFloorCeilU = Union[float, SupportsFloorCeil]\n\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; def my_floor_func(arg: SupportsFloorCeilU) -&gt; int:\n...   assert isinstance(arg, SupportsFloorCeil)\n...   return __floor__(arg)\n\n&gt;&gt;&gt; my_floor_func(float(1.2))  # works in 3.8+\n1\n</code></pre> <p>This is largely a contrived example, since <code>math.floor</code> and <code>math.ceil</code> happily accept <code>SupportsFloat</code>, but it is useful for illustration.</p>"},{"location":"#limitations","title":"Limitations","text":"<p>There are some downsides, though. (Aren\u2019t there always?)</p>"},{"location":"#sometimes-protocols-are-too-trusting","title":"Sometimes protocols are too trusting","text":"<p>Protocols trust numeric tower registrations. TODO(@posita): Is this really true? But sometimes, out there in the real world, implementations lie.</p> <p>Consider:</p> <pre><code>&gt;&gt;&gt; from numbers import Integral\n&gt;&gt;&gt; hasattr(Integral, \"real\") and hasattr(Integral, \"imag\")\nTrue\n&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; pants_on_fire = sympy.Integer(1)\n&gt;&gt;&gt; isinstance(pants_on_fire, Integral)\nTrue\n&gt;&gt;&gt; hasattr(pants_on_fire, \"real\") or hasattr(pants_on_fire, \"imag\")  # somebody's tellin' stories\nFalse\n&gt;&gt;&gt; from numerary.types import SupportsRealImag\n&gt;&gt;&gt; real_imag: SupportsRealImag = pants_on_fire  # fails to detect the lie\n&gt;&gt;&gt; real_imag.real\nTraceback (most recent call last):\n  ...\nAttributeError: 'One' object has no attribute 'real'\n</code></pre> <p>In this particular case, <code>numerary</code> provides us with a defensive mechanism.</p> <pre><code>&gt;&gt;&gt; from numerary.types import SupportsRealImagMixedU, real, imag\n&gt;&gt;&gt; real_imag_defense: SupportsRealImagMixedU = pants_on_fire\n&gt;&gt;&gt; real(real_imag_defense)\n1\n&gt;&gt;&gt; imag(real_imag)\n0\n</code></pre>"},{"location":"#protocols-loses-fidelity-during-runtime-checking","title":"Protocols loses fidelity during runtime checking","text":"<p>At runtime, protocols match names, not signatures. For example, <code>SupportsNumeratorDenominator</code>\u2019s  <code>numerator</code> and <code>denominator</code> properties will match <code>sage.rings.integer.Integer</code>\u2019s similarly named functions. In other words, <code>isinstance(sage_integer, SupportsNumeratorDenominator)</code> will return <code>True</code>. Further, if the short-circuiting approach is used, because <code>sage.rings.integer.Integer</code> registers itself with the numeric tower, this may3 not be caught by Mypy.</p> <pre><code>&gt;&gt;&gt; class SageLikeRational:\n...   def __init__(self, numerator: int, denominator: int = 1):\n...     self._numerator = numerator\n...     self._denominator = denominator\n...   def numerator(self) -&gt; int:\n...     return self._numerator\n...   def denominator(self) -&gt; int:\n...     return self._denominator\n\n&gt;&gt;&gt; from numerary.types import SupportsNumeratorDenominator\n&gt;&gt;&gt; frac: SupportsNumeratorDenominator = Fraction(29, 3)  # no typing error\n&gt;&gt;&gt; sage_rational1: SupportsNumeratorDenominator = SageLikeRational(29, 3)  # type: ignore [assignment]  # Mypy catches this\n&gt;&gt;&gt; isinstance(sage_rational1, SupportsNumeratorDenominator)  # isinstance does not\nTrue\n&gt;&gt;&gt; sage_rational1.numerator\n&lt;...method...numerator...&gt;\n&gt;&gt;&gt; frac.numerator\n29\n</code></pre> <p>Known warts could be cured by cache overriding as discussed above. However, to combat this particular situation, <code>numerary</code> provides an alternative: the <code>SupportsNumeratorDenominatorMethods</code> protocol and the <code>numerator</code> and <code>denominator</code> helper functions. These accommodate rational implementations like Sage\u2019s that are mostly compliant with the exception of their respective <code>numerator</code> and <code>denominator</code> implementations.</p> <pre><code>&gt;&gt;&gt; from numerary.types import numerator\n&gt;&gt;&gt; numerator(sage_rational1)\n29\n&gt;&gt;&gt; numerator(frac)\n29\n\n&gt;&gt;&gt; from numerary.types import SupportsNumeratorDenominatorMethods, numerator\n&gt;&gt;&gt; sage_rational2: SupportsNumeratorDenominatorMethods = SageLikeRational(3, 29)  # no type error\n&gt;&gt;&gt; numerator(sage_rational2)\n3\n</code></pre> <p><code>numerary</code> also defines:</p> <pre><code>SupportsNumeratorDenominatorMixedU = Union[\n    SupportsNumeratorDenominator,\n    SupportsNumeratorDenominatorMethods,\n]\nSupportsNumeratorDenominatorMixedT = (\n    SupportsNumeratorDenominator,\n    SupportsNumeratorDenominatorMethods,\n)\n</code></pre> <pre><code>&gt;&gt;&gt; from numerary.types import SupportsNumeratorDenominatorMixedU, numerator\n&gt;&gt;&gt; chimera_rational: SupportsNumeratorDenominatorMixedU\n&gt;&gt;&gt; chimera_rational = Fraction(29, 3)  # no type error\n&gt;&gt;&gt; numerator(chimera_rational)\n29\n&gt;&gt;&gt; chimera_rational = SageLikeRational(3, 29)  # still no type error\n&gt;&gt;&gt; numerator(chimera_rational)\n3\n</code></pre> <p>The <code>SupportsNumeratorDenominator*</code> primitives provide the basis for analogous <code>numerary.types.RationalLike*</code> primitives, which should provide sufficient (if idiosyncratic) coverage for dealing with (seemingly mis-appropriately named) rationals.</p>"},{"location":"#pass-through-caching-with-composition-is-pretty-sketchy","title":"Pass-through caching with composition is pretty sketchy","text":"<p>This is really getting into where the sausage is made, but full transparency is important, because <code>CachingProtocolMeta</code> does change how protocols are validated at runtime.</p> <p>Let\u2019s say we register an errant implementation as non-compliant using the <code>CachingProtocolMeta.excludes</code>method.</p> <pre><code>&gt;&gt;&gt; from numerary.types import SupportsFloat\n\n&gt;&gt;&gt; class FloatImposter:\n...   def __float__(self) -&gt; float:\n...     raise NotImplementedError(\"Haha! JK! @#$% you!\")\n...   def __int__(self) -&gt; int:\n...     return 42\n\n&gt;&gt;&gt; float_imp = FloatImposter()\n&gt;&gt;&gt; isinstance(float_imp, SupportsFloat)\nTrue\n&gt;&gt;&gt; SupportsFloat.excludes(FloatImposter)\n&gt;&gt;&gt; isinstance(float_imp, SupportsFloat)\nFalse\n</code></pre> <p>For registration to be ergonomic, it should be indelible, survive composition, and afford preference to subsequent overrides by inheritors.</p> <pre><code>&gt;&gt;&gt; from numerary.types import (\n...   CachingProtocolMeta, Protocol, runtime_checkable,\n...   SupportsInt,\n... )\n\n&gt;&gt;&gt; @runtime_checkable\n... class MySupportsFloatInt(\n...   SupportsFloat, SupportsInt,\n...   Protocol,\n... ):\n...   pass\n\n&gt;&gt;&gt; isinstance(float_imp, MySupportsFloatInt)  # composition picks up override from base\nFalse\n\n&gt;&gt;&gt; SupportsFloat.reset_for(FloatImposter)  # base resets override\n&gt;&gt;&gt; isinstance(float_imp, SupportsFloat)\nTrue\n&gt;&gt;&gt; isinstance(float_imp, MySupportsFloatInt)  # picks up base\u2019s changes\nTrue\n\n&gt;&gt;&gt; MySupportsFloatInt.excludes(FloatImposter)  # composition overrides\n&gt;&gt;&gt; isinstance(float_imp, MySupportsFloatInt)\nFalse\n&gt;&gt;&gt; SupportsFloat.includes(FloatImposter)  # base changes\n&gt;&gt;&gt; isinstance(float_imp, FloatImposter)\nTrue\n&gt;&gt;&gt; isinstance(float_imp, MySupportsFloatInt)  # composition remains unchanged\nFalse\n\n&gt;&gt;&gt; MySupportsFloatInt.reset_for(FloatImposter)  # removes override in composition\n&gt;&gt;&gt; isinstance(float_imp, MySupportsFloatInt)  # base is visible again\nTrue\n&gt;&gt;&gt; SupportsFloat.excludes(FloatImposter)\n&gt;&gt;&gt; isinstance(float_imp, MySupportsFloatInt)  # base\u2019s changes are visible to composition again\nFalse\n</code></pre> <p>For this to work under the current implementation, we cannot rely exclusively on the standard library\u2019s implementation of <code>__instancecheck__</code>, since it flattens and inspects all properties (with some proprietary exceptions) of all classes in the inheritance tree (in order of the MRO). In practical terms, this means one can\u2019t easily delegate to an ancestor\u2019s <code>__instancecheck__</code> method and a protocol\u2019s cache is effectively hidden from its progeny. In other words, leaning on the default behavior would require one to register exceptions with every inheritor. That would suck, so let\u2019s not do that.</p> <p>However, overriding the behavior is problematic, because the standard library uses non-public interfaces to perform its attribute enumeration. We certainly don\u2019t want to re-implement protocol runtime checking from scratch. (At least not yet.)</p> <p><code>beartype.typing.Protocol</code>\u2019s meta class tries to work around this by sneakily limiting its evaluation to directly defined attributes, and then delegating <code>isinstance</code> evaluation to its <code>__base__</code> classes. In doing so, it picks up its bases\u2019 then-cached values, but at the cost of re-implementing the attribute check as well as taking a dependency on various implementation details of the standard library, which creates a fragility. Further, for post-inheritance updates, <code>CachingProtocolMeta</code> extends <code>beartype</code>\u2019s version to implement a simplistic publish/subscribe mechanism that dirties non-overridden caches in inheritors when member protocols caches are updated. That\u2019s completely off the beaten path and there are probably some gremlins hiding out there.</p> <p>One subtlety is that the implementation deviates from performing checks in MRO order (and may perform redundant checks). This is probably fine as long as runtime comparisons remain limited to crude checks whether attributes merely exist. It would likely fail if runtime checking becomes more sophisticated, at which time, this implementation will need to be revisited. Hopefully by then, we can just delete <code>numerary</code> as the aspirationally unnecessary hack it is and move on with our lives.</p> <p>(See <code>beartype.typing</code> and <code>numerary</code>\u2019s extension for details.)</p>"},{"location":"#license","title":"License","text":"<p><code>numerary</code> is licensed under the MIT License. See the included <code>LICENSE</code> file for details. Source code is available on GitHub.</p>"},{"location":"#installation","title":"Installation","text":"<p>Installation can be performed via PyPI.</p> <pre><code>% pip install numerary\n...\n</code></pre> <p>Alternately, you can download the source and install manually.</p> <pre><code>% git clone https://github.com/posita/numerary.git\n...\n% cd numerary\n% python -m pip install .  # -or- python -c 'from setuptools import setup ; setup()' install .\n...\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<p><code>numerary</code> requires a relatively modern version of Python:</p> <ul> <li>CPython (3.8+)</li> <li>PyPy (CPython 3.8+ compatible)</li> </ul> <p>It has the following runtime dependencies:</p> <ul> <li><code>beartype</code> for caching protocols   </li> </ul> <p><code>numerary</code> will not use <code>beartype</code> internally unless the <code>NUMERARY_BEARTYPE</code> environment variable is set to a truthy4 value before <code>numerary</code> is loaded.</p> <p>See the hacking quick-start for additional development and testing dependencies.</p>"},{"location":"#customers","title":"Customers","text":"<ul> <li><code>dyce</code> - a pure-Python library for modeling arbitrarily complex dice mechanics and mother birthing code base of <code>numerary</code>!</li> <li>\ud83d\udc7b <code>phantom-types</code> - predicates and other type constraints without runtime overhead</li> <li>The next one could be you! \ud83d\udc4b</li> </ul> <p>Do you have a project that suffers problems made slightly less annoying by <code>numerary</code>? Let me know, and I\u2019ll promote it here!</p> <p>And don\u2019t forget to do your part in perpetuating gratuitous badge-ification!</p> <pre><code>&lt;!-- Markdown --&gt;\nAs of version 0.4.1, ``dyce`` is\n[![numerary-encumbered](https://raw.githubusercontent.com/posita/numerary/latest/docs/numerary-encumbered.svg)][numerary-encumbered]!\n[numerary-encumbered]: https://posita.github.io/numerary/ \"numerary-encumbered\"\n</code></pre> <pre><code>..\n    reStructuredText - see https://docutils.sourceforge.io/docs/ref/rst/directives.html#image\n\nAs of version 0.4.1, ``dyce`` is |numerary-encumbered|!\n\n.. |numerary-encumbered| image:: https://raw.githubusercontent.com/posita/numerary/latest/docs/numerary-encumbered.svg\n   :align: top\n   :target: https://posita.github.io/numerary/\n   :alt: numerary-encumbered\n</code></pre> <pre><code>&lt;!-- HTML --&gt;\nAs of version 0.4.1, &lt;code&gt;dyce&lt;/code&gt; is &lt;a href=\"https://posita.github.io/numerary/\"&gt;&lt;img\n  src=\"https://raw.githubusercontent.com/posita/numerary/latest/docs/numerary-encumbered.svg\"\n  alt=\"numerary-encumbered\"\n  style=\"vertical-align: middle;\"&gt;&lt;/a&gt;!\n</code></pre> <ol> <li> <p>You know, super weird, off-the-wall shit, like members of the numeric tower, or standard library primitives that remain non-members for some \ud83e\udd2ced up reason, or legitimate non-members because they predate PEP 3141 and conforming would amount to breaking changes, or\u2014I don\u2019t know\u2014oodles of libraries and applications that have been around for literally decades that bring huge value to vast scientific and mathematic audiences, but whose number primitives break type-checking if one abides by the ubiquitous bum steer, \u201cI don\u2019t have any experience trying to do what you\u2019re doing, but just use <code>float</code>, bro.\u201d</p> <p>Because, hey, \ud83e\udd2c numbers! Am I right?\u00a0\u21a9</p> </li> <li> <p>Bug</p> <p><code>numpy</code> no longer validates on assignment as it once did. See posita/numerary#16 for details.</p> <p>\u21a9</p> </li> <li> <p>I say may because I don\u2019t really understand how Sage\u2019s number registrations work.\u00a0\u21a9</p> </li> <li> <p>I.E., one of: <code>1</code>, <code>on</code>, <code>t</code>, <code>true</code>, and <code>yes</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"contrib/","title":"Contributing","text":""},{"location":"contrib/#contributing-to-numerary","title":"Contributing to <code>numerary</code>","text":"<p>There are many ways you can contribute. You have only but to try.</p>"},{"location":"contrib/#starting-discussions-and-filing-issues","title":"Starting discussions and filing issues","text":"<p>You can file new issues as you find them. Please try to avoid duplicating issues. \u201cWriting Effective Bug Reports\u201d by Elisabeth Hendrickson (PDF) may be helpful.</p> <p>For more free-flow discussions (beefs, rants, ideas, recipes, etc.), consider starting or joining a discussion.</p>"},{"location":"contrib/#hacking-quick-start","title":"Hacking quick-start","text":"<p>An easy way to bootstrap an isolated development environment is:</p> <pre><code>% git clone --recurse-submodules https://github.com/posita/numerary.git\n\u2026\n% cd numerary\n% /path/to/python -m venv .venv\n\u2026\n% . .venv/bin/activate\n% pip install --upgrade --editable '.[dev]'\n\u2026\n% python -m pre_commit install\n\u2026\n</code></pre> <p>Substitute your preferred virtual environment process for <code>venv</code>. The <code>[dev]</code> variant includes additional dependencies necessary for development and testing. See the <code>[options.extras_require]</code> section in <code>setup.cfg</code>.</p> <p>Unit tests are run with pytest via Tox.</p> <pre><code>% cd \u2026/path/to/numerary\n% . .venv/bin/activate\n% tox [TOX_ARGS... [-- PYTEST_ARGS...]]\n\u2026\n</code></pre>"},{"location":"contrib/#submission-guidelines","title":"Submission guidelines","text":"<p>If you are willing and able, consider submitting a pull request with a fix. See the docs if you\u2019re not already familiar with pull requests. <code>numerary</code> releases from <code>master</code> (although not always immediately), so a lot of these workflows are helpful. There are only a few additional guidelines:</p> <ul> <li>If it is not already present, please add your name (and optionally your email, GitHub username, website address, or other contact information) to the <code>LICENSE</code> file.</li> </ul> <pre><code>...\n* [Matt Bogosian](mailto:matt@bogosian.net?Subject=numerary); GitHub \u2013 [**@posita**](https://github.com/posita)\n...\n</code></pre> <ul> <li> <p>Use Black to format your changes.   Do your best to follow the source conventions as you observe them.   If it\u2019s important to you, Existing comments are wrapped at 88 characters per line to match Black\u2019s default.   (Don\u2019t spend too much effort on strict conformance, though.   I can clean things up later if they really bother me.)</p> </li> <li> <p>Provide tests where feasible and appropriate.   At the very least, existing tests should not fail.   (There are exceptions, but if there is any doubt, they probably do not apply.)   Unit tests live in <code>tests</code>.</p> </li> <li> <p>If you want feedback on a work-in-progress, consider \u201cmentioning\u201d me (@posita), and describe specifically how I can help.   Consider prefixing your pull request\u2019s title with something like, \u201c<code>NEED FEEDBACK \u2013</code>\u201d.</p> </li> <li> <p>If your pull request is still in progress, but you are not blocked on anything, consider using the draft feature.</p> </li> <li> <p>Once you are ready for a merge, resolve any conflicts, squash your commits, and provide a useful commit message.   (This and this may be helpful.)   If your pull request started out as a draft, promote it by requesting a review.   Consider prefixing the pull request\u2019s title to something like, \u201c<code>READY FOR MERGE \u2013</code>\u201d.   I will try to get to it as soon as I can.</p> </li> </ul>"},{"location":"license/","title":"License and credits","text":""},{"location":"license/#the-mit-license-mit","title":"The MIT License (MIT)","text":"<p>Copyright \u00a9 2015-2022 Matt Bogosian (@posita).</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"license/#contributors","title":"Contributors","text":"<p>The following individuals or entities have contributed to this software:</p> <ul> <li>Matt Bogosian; GitHub \u2013 @posita</li> </ul> <p>By adding your name to this list, you grant a nonexclusive, perpetual license to your contributions to this software under the same terms as its license, above. Further, you warrant that your contributions to this software are exclusively your own creations and no one else has any superior right or claim to them. Finally, you agree to indemnify and hold harmless this software\u2019s owner against any colorable claim of infringement by a third party for this software\u2019s owner\u2019s otherwise lawful use of your contribution, whether or not such use was contemplated by you at the time you made it.</p>"},{"location":"notes/","title":"Release notes","text":""},{"location":"notes/#numerary-release-notes","title":"<code>numerary</code> release notes","text":""},{"location":"notes/#044","title":"0.4.4","text":"<ul> <li>Fixes guerrilla patching of <code>RationalLikeMethods.__doc__</code> to work with <code>python -OO</code>.</li> </ul>"},{"location":"notes/#043","title":"0.4.3","text":"<ul> <li>Migrates from <code>setuptools_scm</code> to <code>versioningit</code> for more flexible version number formatting.</li> <li>Adds work-around for <code>numpy</code>\u2019s typing updates (posita/numerary#16).</li> <li>Allows deployments to PyPI from CI based on tags.</li> <li>Exposes <code>CachingProtocolMeta</code> (posita/numerary#15).</li> </ul>"},{"location":"notes/#042","title":"0.4.2","text":"<ul> <li>Fixes issue where <code>numpy</code> lacks <code>float128</code> on certain Windows installation.</li> </ul>"},{"location":"notes/#041","title":"0.4.1","text":"<ul> <li>Minor corrections to required Python version.</li> </ul>"},{"location":"notes/#040","title":"0.4.0","text":"<ul> <li>Now relies on <code>beartype.typing.Protocol</code> as the underlying caching protocol implementation.   This means that <code>beartype</code> has emerged as <code>numerary</code>\u2019s sole runtime dependency.   (<code>numerary</code> still layers on its own runtime override mechanism via CachingProtocolMeta, which derives from <code>beartype</code>\u2019s.)   It also means that <code>numerary</code> loses Python 3.7 support, but that was largely illusory anyway.</li> </ul> <p>This decision was not made lightly.   <code>numerary</code> is intended as a temporary work-around.   Its obsolescence will be something to celebrate.   Caching protocols, however, have much broader performance applications.   They deserve more.   <code>beartype</code> will provide what <code>numerary</code> was never meant to: a loving, stable, and permanent home.</p>"},{"location":"notes/#030","title":"0.3.0","text":"<ul> <li>Removes misleading advice that SCUs offer a performance benefit over merely using caching protocols.   They could under very specific circumstances (where <code>numerary</code> probably will not help anyway), but not always, and probably aren\u2019t worth the trouble if performance is the only concern.   Actually, removes SCUs altogether and documents a surgical example for those rare occasions where it might be needed.</li> <li>Finally removes <code>SupportsNumeratorDenominatorProperties</code> as promised.</li> </ul>"},{"location":"notes/#021","title":"0.2.1","text":"<ul> <li>Fixes trailing issues for <code>sympy</code> import issue resulting in <code>ValueError</code>s being thrown on import in some environments.</li> </ul>"},{"location":"notes/#020","title":"0.2.0","text":"<ul> <li><code>numerary</code> goes beta!</li> <li>Splits <code>SupportsRealImagAsMethod</code> out of <code>SupportsRealImag</code> and provides the <code>real</code> and <code>imag</code> helper functions for better support of <code>sympy</code>\u2019s number primitives.</li> <li>Renames <code>SupportsNumeratorDenominatorProperties</code> to <code>SupportsNumeratorDenominator</code> to mirror <code>SupportsRealImag</code> and reflect that it captures the numeric tower interface.   <code>SupportsNumeratorDenominatorProperties</code> and <code>SupportsNumeratorDenominatorPropertiesSCU</code> are maintained as aliases for limited backward compatibility and will be removed in the next version.</li> <li>Removes <code>enum.Flag</code> from testing as a non-sequitur.   (It matches none of the presented protocols.)</li> <li>Introduces <code>__pow__</code> helper function and renames <code>trunc</code>, <code>floor</code>, and <code>ceil</code> to <code>__trunc__</code>, <code>__floor__</code>, and <code>__ceil__</code>, respectively.</li> <li>Fixes <code>sympy</code> import issue resulting in <code>AttributeError</code>s being thrown on import in some environments.</li> </ul>"},{"location":"notes/#011","title":"0.1.1","text":"<ul> <li>Removes obsoleted <code>\u2026SCT</code> aliases.</li> <li>Corrects release notes which erroneously identified version 0.1.0 as 0.0.6.</li> <li>Adds <code>enum.IntEnum</code>, <code>enum.IntFlag</code>, and <code>enum.Flag</code> to testing.</li> <li>Merges <code>SupportsFloor</code> and <code>SupportsCeil</code> into <code>SupportsFloorCeil</code>.</li> <li>Gets rid of <code>MANIFEST.in</code> nonsense since we\u2019re not distributing sources via PyPI anymore.</li> <li>Adds a ton of examples to protocol docs.</li> <li>Better identifies false positives in tests.</li> </ul>"},{"location":"notes/#010","title":"0.1.0","text":"<ul> <li>Adds <code>CachingProtocolMeta.includes</code>,   <code>CachingProtocolMeta.excludes</code>, and   <code>CachingProtocolMeta.reset_for</code>   cache override functions.</li> <li>Retires <code>\u2026SCT</code> tuples as unnecessary, especially in light of cache overrides.   (Runtime <code>isinstance</code> protocol checking is fast enough.)   For limited backward compatibility, they are now merely type aliases for similarly named protocols and will be removed in the next version.</li> <li>Updates docs.</li> <li>Custom runtime comparison implementation allows composition to lean on base types\u2019 caches.   (\u26a0\ufe0f WARNING: Severe jank alert! \u26a0\ufe0f)</li> </ul>"},{"location":"notes/#005","title":"0.0.5","text":"<ul> <li>Updates license to the MIT License.</li> <li>Gets rid of <code>self</code> redundancy in <code>__isinstance__</code> checks.</li> </ul>"},{"location":"notes/#004","title":"0.0.4","text":"<ul> <li><code>numerary</code> finally leaves the <code>dyce</code> nest to become its own library!   It didn\u2019t quite leave before because its maintainer is a bonehead who doesn\u2019t understand setuptools\u2019 multitude of oh-so-simple packaging mechanisms.   No, it stuck around most weekends to do laundry while eating all of <code>dyce</code>\u2019s food.   Now it has officially left the nest.</li> </ul>"},{"location":"numerary/","title":"<tt>numerary</tt>","text":""},{"location":"numerary/#numerary-package-reference","title":"<code>numerary</code> package reference","text":"<p>Experimental</p> <p>This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated.</p> <p>These are composition protocols that should suit common use cases.</p>"},{"location":"numerary/#numerary.types.IntegralLike","title":"<code>IntegralLike</code>","text":"<p>             Bases: <code>SupportsAbs[_T_co]</code>, <code>SupportsFloat</code>, <code>SupportsIndex</code>, <code>SupportsInt</code>, <code>SupportsIntegralOps[_T_co]</code>, <code>SupportsIntegralPow</code>, <code>SupportsRealOps[_T_co]</code>, <code>SupportsComplexOps[_T_co]</code>, <code>Protocol</code>, <code>Generic[_T_co]</code></p> <p>A caching ABC that defines a core set of operations for interacting with integrals. It is a composition of:</p> <ul> <li><code>SupportsAbs</code></li> <li><code>SupportsFloat</code></li> <li><code>SupportsIndex</code></li> <li><code>SupportsInt</code></li> <li><code>SupportsIntegralOps</code></li> <li><code>SupportsIntegralPow</code></li> <li><code>SupportsRealOps</code></li> <li><code>SupportsComplexOps</code></li> <li>a <code>__hash__</code> method</li> </ul> <p>Basically:</p> <pre><code>from typing TypeVar, runtime_checkable\nfrom beartype.typing import Protocol\nfrom numerary.types import CachingProtocolMeta, Supports\u2026\nT_co = TypeVar(\"T_co\", covariant=True)\n\n@runtime_checkable\nclass IntegralLike(\n  SupportsAbs[T_co],\n  SupportsFloat,\n  SupportsIndex,\n  SupportsInt,\n  SupportsIntegralOps[T_co],\n  SupportsIntegralPow[T_co],\n  SupportsRealOps[T_co],\n  SupportsComplexOps[T_co],\n  Protocol[T_co],\n  metaclass=CachingProtocolMeta,\n):\n  @abstractmethod\n  def __hash__(self) -&gt; int:\n    pass\n</code></pre> <p>This is intended as a practically useful, but incomplete list. To enforce equivalence to <code>numbers.Integral</code>, one would also need:</p> <ul> <li><code>SupportsComplex</code></li> <li><code>SupportsConjugate</code></li> <li><code>SupportsRealImag</code></li> <li><code>SupportsRound</code></li> <li><code>SupportsTrunc</code></li> <li><code>SupportsFloorCeil</code></li> <li><code>SupportsDivmod</code></li> <li><code>SupportsNumeratorDenominator</code></li> </ul> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass IntegralLike(\n    SupportsAbs[_T_co],\n    SupportsFloat,\n    SupportsIndex,\n    SupportsInt,\n    SupportsIntegralOps[_T_co],\n    SupportsIntegralPow,\n    SupportsRealOps[_T_co],\n    SupportsComplexOps[_T_co],\n    Protocol,\n    Generic[_T_co],\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC that defines a core set of operations for interacting with integrals.\n    It is a composition of:\n\n    * [``SupportsAbs``][numerary.types.SupportsAbs]\n    * [``SupportsFloat``][numerary.types.SupportsFloat]\n    * [``SupportsIndex``][numerary.types.SupportsIndex]\n    * [``SupportsInt``][numerary.types.SupportsInt]\n    * [``SupportsIntegralOps``][numerary.types.SupportsIntegralOps]\n    * [``SupportsIntegralPow``][numerary.types.SupportsIntegralPow]\n    * [``SupportsRealOps``][numerary.types.SupportsRealOps]\n    * [``SupportsComplexOps``][numerary.types.SupportsComplexOps]\n    * a ``__hash__`` method\n\n    Basically:\n\n    ``` python\n    from typing TypeVar, runtime_checkable\n    from beartype.typing import Protocol\n    from numerary.types import CachingProtocolMeta, Supports\u2026\n    T_co = TypeVar(\"T_co\", covariant=True)\n\n    @runtime_checkable\n    class IntegralLike(\n      SupportsAbs[T_co],\n      SupportsFloat,\n      SupportsIndex,\n      SupportsInt,\n      SupportsIntegralOps[T_co],\n      SupportsIntegralPow[T_co],\n      SupportsRealOps[T_co],\n      SupportsComplexOps[T_co],\n      Protocol[T_co],\n      metaclass=CachingProtocolMeta,\n    ):\n      @abstractmethod\n      def __hash__(self) -&gt; int:\n        pass\n    ```\n\n    This is intended as a practically useful, but incomplete list. To enforce\n    equivalence to ``#!python numbers.Integral``, one would also need:\n\n    * [``SupportsComplex``][numerary.types.SupportsComplex]\n    * [``SupportsConjugate``][numerary.types.SupportsConjugate]\n    * [``SupportsRealImag``][numerary.types.SupportsRealImag]\n    * [``SupportsRound``][numerary.types.SupportsRound]\n    * [``SupportsTrunc``][numerary.types.SupportsTrunc]\n    * [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil]\n    * [``SupportsDivmod``][numerary.types.SupportsDivmod]\n    * [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator]\n    \"\"\"\n\n    # Must be able to instantiate it\n    @abstractmethod\n    def __init__(self, *args: Any, **kw: Any):\n        pass\n\n    @abstractmethod\n    def __hash__(self) -&gt; int:\n        pass\n</code></pre>"},{"location":"numerary/#numerary.types.RealLike","title":"<code>RealLike</code>","text":"<p>             Bases: <code>SupportsAbs[_T_co]</code>, <code>SupportsFloat</code>, <code>SupportsRealOps[_T_co]</code>, <code>SupportsComplexOps[_T_co]</code>, <code>SupportsComplexPow</code>, <code>Protocol</code>, <code>Generic[_T_co]</code></p> <p>A caching ABC that defines a core set of operations for interacting with reals. It is a composition of:</p> <ul> <li><code>SupportsAbs</code></li> <li><code>SupportsFloat</code></li> <li><code>SupportsRealOps</code></li> <li><code>SupportsComplexOps</code></li> <li><code>SupportsComplexPow</code></li> <li>a <code>__hash__</code> method</li> </ul> <p>Basically:</p> <pre><code>from typing import TypeVar, runtime_checkable\nfrom beartype.typing import Protocol\nfrom numerary.types import CachingProtocolMeta, Supports\u2026\nT_co = TypeVar(\"T_co\", covariant=True)\n\n@runtime_checkable\nclass RealLike(\n  SupportsAbs[T_co],\n  SupportsFloat,\n  SupportsRealOps[T_co],\n  SupportsComplexOps[T_co],\n  SupportsComplexPow[T_co],\n  Protocol[T_co],\n  metaclass=CachingProtocolMeta,\n):\n  @abstractmethod\n  def __hash__(self) -&gt; int:\n    pass\n</code></pre> <p>This is intended as a practically useful, but incomplete list. To enforce equivalence to <code>numbers.Real</code>, one would also need:</p> <ul> <li><code>SupportsComplex</code></li> <li><code>SupportsConjugate</code></li> <li><code>SupportsRealImag</code></li> <li><code>SupportsRound</code></li> <li><code>SupportsTrunc</code></li> <li><code>SupportsFloorCeil</code></li> <li><code>SupportsDivmod</code></li> </ul> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass RealLike(\n    SupportsAbs[_T_co],\n    SupportsFloat,\n    SupportsRealOps[_T_co],\n    SupportsComplexOps[_T_co],\n    SupportsComplexPow,\n    Protocol,\n    Generic[_T_co],\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC that defines a core set of operations for interacting with reals. It\n    is a composition of:\n\n    * [``SupportsAbs``][numerary.types.SupportsAbs]\n    * [``SupportsFloat``][numerary.types.SupportsFloat]\n    * [``SupportsRealOps``][numerary.types.SupportsRealOps]\n    * [``SupportsComplexOps``][numerary.types.SupportsComplexOps]\n    * [``SupportsComplexPow``][numerary.types.SupportsComplexPow]\n    * a ``__hash__`` method\n\n    Basically:\n\n    ``` python\n    from typing import TypeVar, runtime_checkable\n    from beartype.typing import Protocol\n    from numerary.types import CachingProtocolMeta, Supports\u2026\n    T_co = TypeVar(\"T_co\", covariant=True)\n\n    @runtime_checkable\n    class RealLike(\n      SupportsAbs[T_co],\n      SupportsFloat,\n      SupportsRealOps[T_co],\n      SupportsComplexOps[T_co],\n      SupportsComplexPow[T_co],\n      Protocol[T_co],\n      metaclass=CachingProtocolMeta,\n    ):\n      @abstractmethod\n      def __hash__(self) -&gt; int:\n        pass\n    ```\n\n    This is intended as a practically useful, but incomplete list. To enforce\n    equivalence to ``#!python numbers.Real``, one would also need:\n\n    * [``SupportsComplex``][numerary.types.SupportsComplex]\n    * [``SupportsConjugate``][numerary.types.SupportsConjugate]\n    * [``SupportsRealImag``][numerary.types.SupportsRealImag]\n    * [``SupportsRound``][numerary.types.SupportsRound]\n    * [``SupportsTrunc``][numerary.types.SupportsTrunc]\n    * [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil]\n    * [``SupportsDivmod``][numerary.types.SupportsDivmod]\n    \"\"\"\n\n    # Must be able to instantiate it\n    @abstractmethod\n    def __init__(self, *args: Any, **kw: Any):\n        pass\n\n    @abstractmethod\n    def __hash__(self) -&gt; int:\n        pass\n</code></pre>"},{"location":"numerary.protocol/","title":"<tt>numerary.protocol</tt>","text":""},{"location":"numerary.protocol/#numeraryprotocol-package-reference","title":"<code>numerary.protocol</code> package reference","text":"<p>Experimental</p> <p>This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated.</p> <p><code>numerary</code> has donated its core caching protocol implementation to (and now depends on) <code>beartype</code>. <code>beartype</code> is awesome, and its author is even awesomer.1 <code>numerary</code>\u2019s version (in this package) augments that implementation to allow for runtime check overrides.</p> <ol> <li> <p>I acknowledge that the subject of who is awesomer, beartype or the man who made it, is hotly contested.\u00a0\u21a9</p> </li> </ol>"},{"location":"numerary.protocol/#numerary.protocol.CachingProtocolMeta","title":"<code>CachingProtocolMeta</code>","text":"<p>             Bases: <code>_BeartypeCachingProtocolMeta</code></p> <p>An extension of <code>beartype.typing.Protocol</code> that allows overriding runtime checks.</p> Source code in <code>numerary/protocol.py</code> <pre><code>class CachingProtocolMeta(_BeartypeCachingProtocolMeta):\n    # TODO(posita): Add more precise link to beartype.typing.Protocol documentation once\n    # it becomes available.\nr\"\"\"\n    An extension of [``#!python\n    beartype.typing.Protocol``](https://github.com/beartype/beartype) that allows\n    overriding runtime checks.\n    \"\"\"\n\n    _abc_inst_check_cache_overridden: Dict[Type, bool]\n    _abc_inst_check_cache_listeners: Set[CachingProtocolMeta]\n\n    # Defined in beartype.typing.Protocol from which we inherit\n    _abc_inst_check_cache: Dict[type, bool]\n\n    def __new__(\n        mcls: Type[_TT],\n        name: str,\n        bases: Tuple[Type, ...],\n        namespace: Dict[str, Any],\n        **kw: Any,\n    ) -&gt; _TT:\n        cls = super().__new__(mcls, name, bases, namespace, **kw)\n\n        # Prefixing this class member with \"_abc_\" is necessary to prevent it from being\n        # considered part of the Protocol. (See\n        # &lt;https://github.com/python/cpython/blob/main/Lib/typing.py&gt;.)\n        cls._abc_inst_check_cache_overridden = defaultdict(bool)  # defaults to False\n        cls._abc_inst_check_cache_listeners = set()\n\n        for base in bases:\n            if hasattr(base, \"_abc_inst_check_cache_listeners\"):\n                base._abc_inst_check_cache_listeners.add(cls)\n\n        return cls\n\n    def includes(cls, inst_t: Type) -&gt; None:\nr\"\"\"\n        Registers *inst_t* as supporting the interface in the runtime type-checking cache.\n        This overrides any prior cached value.\n\n        ``` python\n        &gt;&gt;&gt; from abc import abstractmethod\n        &gt;&gt;&gt; from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable\n\n        &gt;&gt;&gt; @runtime_checkable\n        ... class SupportsSpam(\n        ...   Protocol,\n        ...   metaclass=CachingProtocolMeta\n        ... ):\n        ...   @abstractmethod\n        ...   def spam(self) -&gt; str:\n        ...     pass\n\n        &gt;&gt;&gt; class NoSpam:\n        ...   pass\n\n        &gt;&gt;&gt; isinstance(NoSpam(), SupportsSpam)\n        False\n        &gt;&gt;&gt; SupportsSpam.includes(NoSpam)\n        &gt;&gt;&gt; isinstance(NoSpam(), SupportsSpam)\n        True\n\n        ```\n\n        !!! note\n\n            This does not affect static type-checking.\n\n            ``` python\n            &gt;&gt;&gt; my_spam: SupportsSpam = NoSpam()  # type: ignore [assignment]  # still generates a Mypy warning\n\n            ```\n        \"\"\"\n        cls._abc_inst_check_cache[inst_t] = True\n        cls._abc_inst_check_cache_overridden[inst_t] = True\n        cls._dirty_for(inst_t)\n\n    def excludes(cls, inst_t: Type) -&gt; None:\nr\"\"\"\n        Registers *inst_t* as supporting the interface in the runtime type-checking cache.\n        This overrides any prior cached value.\n\n        ``` python\n        &gt;&gt;&gt; from abc import abstractmethod\n        &gt;&gt;&gt; from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable\n\n        &gt;&gt;&gt; @runtime_checkable\n        ... class SupportsHam(\n        ...   Protocol,\n        ...   metaclass=CachingProtocolMeta\n        ... ):\n        ...   @abstractmethod\n        ...   def ham(self) -&gt; str:\n        ...     pass\n\n        &gt;&gt;&gt; class NoHam:\n        ...   def ham(self) -&gt; str:\n        ...     raise NotImplementedError\n\n        &gt;&gt;&gt; isinstance(NoHam(), SupportsHam)\n        True\n        &gt;&gt;&gt; SupportsHam.excludes(NoHam)\n        &gt;&gt;&gt; isinstance(NoHam(), SupportsHam)\n        False\n\n        ```\n\n        !!! note\n\n            This does not affect static type-checking.\n\n            ``` python\n            &gt;&gt;&gt; my_ham: SupportsHam = NoHam()  # does *not* generate a Mypy warning\n\n            ```\n        \"\"\"\n        cls._abc_inst_check_cache[inst_t] = False\n        cls._abc_inst_check_cache_overridden[inst_t] = True\n        cls._dirty_for(inst_t)\n\n    def reset_for(cls, inst_t: Type) -&gt; None:\nr\"\"\"\n        Clears any cached instance check for *inst_t*.\n        \"\"\"\n        if inst_t in cls._abc_inst_check_cache:\n            del cls._abc_inst_check_cache[inst_t]\n            del cls._abc_inst_check_cache_overridden[inst_t]\n            cls._dirty_for(inst_t)\n\n    def _dirty_for(cls, inst_t: Type) -&gt; None:\n        for inheriting_cls in cls._abc_inst_check_cache_listeners:\n            if (\n                inst_t in inheriting_cls._abc_inst_check_cache\n                and not inheriting_cls._abc_inst_check_cache_overridden[inst_t]\n            ):\n                del inheriting_cls._abc_inst_check_cache[inst_t]\n                del inheriting_cls._abc_inst_check_cache_overridden[inst_t]\n</code></pre>"},{"location":"numerary.protocol/#numerary.protocol.CachingProtocolMeta.excludes","title":"<code>excludes(inst_t: Type) -&gt; None</code>","text":"<p>Registers inst_t as supporting the interface in the runtime type-checking cache. This overrides any prior cached value.</p> <pre><code>&gt;&gt;&gt; from abc import abstractmethod\n&gt;&gt;&gt; from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable\n\n&gt;&gt;&gt; @runtime_checkable\n... class SupportsHam(\n...   Protocol,\n...   metaclass=CachingProtocolMeta\n... ):\n...   @abstractmethod\n...   def ham(self) -&gt; str:\n...     pass\n\n&gt;&gt;&gt; class NoHam:\n...   def ham(self) -&gt; str:\n...     raise NotImplementedError\n\n&gt;&gt;&gt; isinstance(NoHam(), SupportsHam)\nTrue\n&gt;&gt;&gt; SupportsHam.excludes(NoHam)\n&gt;&gt;&gt; isinstance(NoHam(), SupportsHam)\nFalse\n</code></pre> <p>Note</p> <p>This does not affect static type-checking.</p> <pre><code>&gt;&gt;&gt; my_ham: SupportsHam = NoHam()  # does *not* generate a Mypy warning\n</code></pre> Source code in <code>numerary/protocol.py</code> <pre><code>def excludes(cls, inst_t: Type) -&gt; None:\nr\"\"\"\n    Registers *inst_t* as supporting the interface in the runtime type-checking cache.\n    This overrides any prior cached value.\n\n    ``` python\n    &gt;&gt;&gt; from abc import abstractmethod\n    &gt;&gt;&gt; from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable\n\n    &gt;&gt;&gt; @runtime_checkable\n    ... class SupportsHam(\n    ...   Protocol,\n    ...   metaclass=CachingProtocolMeta\n    ... ):\n    ...   @abstractmethod\n    ...   def ham(self) -&gt; str:\n    ...     pass\n\n    &gt;&gt;&gt; class NoHam:\n    ...   def ham(self) -&gt; str:\n    ...     raise NotImplementedError\n\n    &gt;&gt;&gt; isinstance(NoHam(), SupportsHam)\n    True\n    &gt;&gt;&gt; SupportsHam.excludes(NoHam)\n    &gt;&gt;&gt; isinstance(NoHam(), SupportsHam)\n    False\n\n    ```\n\n    !!! note\n\n        This does not affect static type-checking.\n\n        ``` python\n        &gt;&gt;&gt; my_ham: SupportsHam = NoHam()  # does *not* generate a Mypy warning\n\n        ```\n    \"\"\"\n    cls._abc_inst_check_cache[inst_t] = False\n    cls._abc_inst_check_cache_overridden[inst_t] = True\n    cls._dirty_for(inst_t)\n</code></pre>"},{"location":"numerary.protocol/#numerary.protocol.CachingProtocolMeta.includes","title":"<code>includes(inst_t: Type) -&gt; None</code>","text":"<p>Registers inst_t as supporting the interface in the runtime type-checking cache. This overrides any prior cached value.</p> <pre><code>&gt;&gt;&gt; from abc import abstractmethod\n&gt;&gt;&gt; from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable\n\n&gt;&gt;&gt; @runtime_checkable\n... class SupportsSpam(\n...   Protocol,\n...   metaclass=CachingProtocolMeta\n... ):\n...   @abstractmethod\n...   def spam(self) -&gt; str:\n...     pass\n\n&gt;&gt;&gt; class NoSpam:\n...   pass\n\n&gt;&gt;&gt; isinstance(NoSpam(), SupportsSpam)\nFalse\n&gt;&gt;&gt; SupportsSpam.includes(NoSpam)\n&gt;&gt;&gt; isinstance(NoSpam(), SupportsSpam)\nTrue\n</code></pre> <p>Note</p> <p>This does not affect static type-checking.</p> <pre><code>&gt;&gt;&gt; my_spam: SupportsSpam = NoSpam()  # type: ignore [assignment]  # still generates a Mypy warning\n</code></pre> Source code in <code>numerary/protocol.py</code> <pre><code>def includes(cls, inst_t: Type) -&gt; None:\nr\"\"\"\n    Registers *inst_t* as supporting the interface in the runtime type-checking cache.\n    This overrides any prior cached value.\n\n    ``` python\n    &gt;&gt;&gt; from abc import abstractmethod\n    &gt;&gt;&gt; from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable\n\n    &gt;&gt;&gt; @runtime_checkable\n    ... class SupportsSpam(\n    ...   Protocol,\n    ...   metaclass=CachingProtocolMeta\n    ... ):\n    ...   @abstractmethod\n    ...   def spam(self) -&gt; str:\n    ...     pass\n\n    &gt;&gt;&gt; class NoSpam:\n    ...   pass\n\n    &gt;&gt;&gt; isinstance(NoSpam(), SupportsSpam)\n    False\n    &gt;&gt;&gt; SupportsSpam.includes(NoSpam)\n    &gt;&gt;&gt; isinstance(NoSpam(), SupportsSpam)\n    True\n\n    ```\n\n    !!! note\n\n        This does not affect static type-checking.\n\n        ``` python\n        &gt;&gt;&gt; my_spam: SupportsSpam = NoSpam()  # type: ignore [assignment]  # still generates a Mypy warning\n\n        ```\n    \"\"\"\n    cls._abc_inst_check_cache[inst_t] = True\n    cls._abc_inst_check_cache_overridden[inst_t] = True\n    cls._dirty_for(inst_t)\n</code></pre>"},{"location":"numerary.protocol/#numerary.protocol.CachingProtocolMeta.reset_for","title":"<code>reset_for(inst_t: Type) -&gt; None</code>","text":"<p>Clears any cached instance check for inst_t.</p> Source code in <code>numerary/protocol.py</code> <pre><code>def reset_for(cls, inst_t: Type) -&gt; None:\nr\"\"\"\n    Clears any cached instance check for *inst_t*.\n    \"\"\"\n    if inst_t in cls._abc_inst_check_cache:\n        del cls._abc_inst_check_cache[inst_t]\n        del cls._abc_inst_check_cache_overridden[inst_t]\n        cls._dirty_for(inst_t)\n</code></pre>"},{"location":"numerary.types/","title":"<tt>numerary.types</tt>","text":""},{"location":"numerary.types/#numerarytypes-package-reference","title":"<code>numerary.types</code> package reference","text":"<p>Experimental</p> <p>This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated.</p>"},{"location":"numerary.types/#numerary.types.RationalLike","title":"<code>RationalLike</code>","text":"<p>             Bases: <code>SupportsAbs[_T_co]</code>, <code>SupportsFloat</code>, <code>SupportsNumeratorDenominator</code>, <code>SupportsRealOps[_T_co]</code>, <code>SupportsComplexOps[_T_co]</code>, <code>SupportsComplexPow</code>, <code>Protocol</code>, <code>Generic[_T_co]</code></p> <p>A caching ABC that defines a core set of operations for interacting with rationals. It is a composition of:</p> <ul> <li><code>SupportsAbs</code></li> <li><code>SupportsFloat</code></li> <li><code>SupportsNumeratorDenominator</code></li> <li><code>SupportsRealOps</code></li> <li><code>SupportsComplexOps</code></li> <li><code>SupportsComplexPow</code></li> <li>a <code>__hash__</code> method</li> </ul> <p>Basically:</p> <pre><code>from typing TypeVar, runtime_checkable\nfrom beartype.typing import Protocol\nfrom numerary.types import CachingProtocolMeta, Supports\u2026\nT_co = TypeVar(\"T_co\", covariant=True)\n\n@runtime_checkable\nclass RationalLike(\n  SupportsAbs[T_co],\n  SupportsFloat,\n  SupportsNumeratorDenominator,\n  SupportsRealOps[T_co],\n  SupportsComplexOps[T_co],\n  SupportsComplexPow[T_co],\n  Protocol[T_co],\n  metaclass=CachingProtocolMeta,\n):\n  @abstractmethod\n  def __hash__(self) -&gt; int:\n    pass\n</code></pre> <p>This is intended as a practically useful, but incomplete list. To enforce equivalence to <code>numbers.Rational</code>, one would also need:</p> <ul> <li><code>SupportsComplex</code></li> <li><code>SupportsConjugate</code></li> <li><code>SupportsRealImag</code></li> <li><code>SupportsRound</code></li> <li><code>SupportsTrunc</code></li> <li><code>SupportsFloorCeil</code></li> <li><code>SupportsDivmod</code></li> </ul> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass RationalLike(\n    SupportsAbs[_T_co],\n    SupportsFloat,\n    SupportsNumeratorDenominator,\n    SupportsRealOps[_T_co],\n    SupportsComplexOps[_T_co],\n    SupportsComplexPow,\n    Protocol,\n    Generic[_T_co],\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC that defines a core set of operations for interacting with rationals.\n    It is a composition of:\n\n    * [``SupportsAbs``][numerary.types.SupportsAbs]\n    * [``SupportsFloat``][numerary.types.SupportsFloat]\n    * [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator]\n    * [``SupportsRealOps``][numerary.types.SupportsRealOps]\n    * [``SupportsComplexOps``][numerary.types.SupportsComplexOps]\n    * [``SupportsComplexPow``][numerary.types.SupportsComplexPow]\n    * a ``__hash__`` method\n\n    Basically:\n\n    ``` python\n    from typing TypeVar, runtime_checkable\n    from beartype.typing import Protocol\n    from numerary.types import CachingProtocolMeta, Supports\u2026\n    T_co = TypeVar(\"T_co\", covariant=True)\n\n    @runtime_checkable\n    class RationalLike(\n      SupportsAbs[T_co],\n      SupportsFloat,\n      SupportsNumeratorDenominator,\n      SupportsRealOps[T_co],\n      SupportsComplexOps[T_co],\n      SupportsComplexPow[T_co],\n      Protocol[T_co],\n      metaclass=CachingProtocolMeta,\n    ):\n      @abstractmethod\n      def __hash__(self) -&gt; int:\n        pass\n    ```\n\n    This is intended as a practically useful, but incomplete list. To enforce\n    equivalence to ``#!python numbers.Rational``, one would also need:\n\n    * [``SupportsComplex``][numerary.types.SupportsComplex]\n    * [``SupportsConjugate``][numerary.types.SupportsConjugate]\n    * [``SupportsRealImag``][numerary.types.SupportsRealImag]\n    * [``SupportsRound``][numerary.types.SupportsRound]\n    * [``SupportsTrunc``][numerary.types.SupportsTrunc]\n    * [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil]\n    * [``SupportsDivmod``][numerary.types.SupportsDivmod]\n    \"\"\"\n\n    # Must be able to instantiate it\n    @abstractmethod\n    def __init__(self, *args: Any, **kw: Any):\n        pass\n\n    @abstractmethod\n    def __hash__(self) -&gt; int:\n        pass\n</code></pre>"},{"location":"numerary.types/#numerary.types.RationalLikeMethods","title":"<code>RationalLikeMethods</code>","text":"<p>             Bases: <code>SupportsAbs[_T_co]</code>, <code>SupportsFloat</code>, <code>SupportsNumeratorDenominatorMethods</code>, <code>SupportsRealOps[_T_co]</code>, <code>SupportsComplexOps[_T_co]</code>, <code>SupportsComplexPow</code>, <code>Protocol</code>, <code>Generic[_T_co]</code></p> <p>A caching ABC that defines a core set of operations for interacting with rationals. It is identical to <code>RationalLike</code> with one important exception. Instead of <code>SupportsNumeratorDenominator</code>, this protocol provides <code>SupportsNumeratorDenominatorMethods</code>.</p> <p>Basically:</p> <pre><code>from typing TypeVar, runtime_checkable\nfrom beartype.typing import Protocol\nfrom numerary.types import CachingProtocolMeta, Supports\u2026\nT_co = TypeVar(\"T_co\", covariant=True)\n\n@runtime_checkable\nclass RationalLikeMethods(\n  SupportsAbs[T_co],\n  SupportsFloat,\n  SupportsNumeratorDenominatorMethods,\n  SupportsRealOps[T_co],\n  SupportsComplexOps[T_co],\n  SupportsComplexPow[T_co],\n  Protocol[T_co],\n  metaclass=CachingProtocolMeta,\n):\n  @abstractmethod\n  def __hash__(self) -&gt; int:\n    pass\n</code></pre> <p>This is probably not very useful on its own, but is important to the construction of <code>RationalLikeMixedU</code> and <code>RationalLikeMixedT</code>.</p> <p>See also the <code>numerator</code> and <code>denominator</code> helper functions.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass RationalLikeMethods(\n    SupportsAbs[_T_co],\n    SupportsFloat,\n    SupportsNumeratorDenominatorMethods,\n    SupportsRealOps[_T_co],\n    SupportsComplexOps[_T_co],\n    SupportsComplexPow,\n    Protocol,\n    Generic[_T_co],\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC that defines a core set of operations for interacting with rationals.\n    It is identical to [``RationalLike``][numerary.types.RationalLike] with one\n    important exception. Instead of\n    [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator],\n    this protocol provides\n    [``SupportsNumeratorDenominatorMethods``][numerary.types.SupportsNumeratorDenominatorMethods].\n\n    Basically:\n\n    ``` python\n    from typing TypeVar, runtime_checkable\n    from beartype.typing import Protocol\n    from numerary.types import CachingProtocolMeta, Supports\u2026\n    T_co = TypeVar(\"T_co\", covariant=True)\n\n    @runtime_checkable\n    class RationalLikeMethods(\n      SupportsAbs[T_co],\n      SupportsFloat,\n      SupportsNumeratorDenominatorMethods,\n      SupportsRealOps[T_co],\n      SupportsComplexOps[T_co],\n      SupportsComplexPow[T_co],\n      Protocol[T_co],\n      metaclass=CachingProtocolMeta,\n    ):\n      @abstractmethod\n      def __hash__(self) -&gt; int:\n        pass\n    ```\n\n    This is probably not very useful on its own, but is important to the construction of\n    [``RationalLikeMixedU``][numerary.types.RationalLikeMixedU] and\n    [``RationalLikeMixedT``][numerary.types.RationalLikeMixedT].\n\n    See also the [``numerator``][numerary.types.numerator] and\n    [``denominator``][numerary.types.denominator] helper functions.\n    \"\"\"\n\n    # Must be able to instantiate it\n    @abstractmethod\n    def __init__(self, *args: Any, **kw: Any):\n        pass\n\n    @abstractmethod\n    def __hash__(self) -&gt; int:\n        pass\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsAbs","title":"<code>SupportsAbs</code>","text":"<p>             Bases: <code>_SupportsAbs[_T_co]</code>, <code>Protocol</code>, <code>Generic[_T_co]</code></p> <p>A derivative of <code>beartype.typing.SupportsAbs</code> with an override-able cache.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsAbs(\n    _SupportsAbs[_T_co],\n    Protocol,\n    Generic[_T_co],\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A derivative of ``beartype.typing.SupportsAbs`` with an override-able cache.\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsComplex","title":"<code>SupportsComplex</code>","text":"<p>             Bases: <code>_SupportsComplex</code>, <code>Protocol</code></p> <p>A derivative of <code>beartype.typing.SupportsComplex</code> with an override-able cache.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsComplex(\n    _SupportsComplex,\n    Protocol,\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A derivative of ``beartype.typing.SupportsComplex`` with an override-able cache.\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsFloat","title":"<code>SupportsFloat</code>","text":"<p>             Bases: <code>_SupportsFloat</code>, <code>Protocol</code></p> <p>A derivative of <code>beartype.typing.SupportsFloat</code> with an override-able cache.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsFloat(\n    _SupportsFloat,\n    Protocol,\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A derivative of ``beartype.typing.SupportsFloat`` with an override-able cache.\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsInt","title":"<code>SupportsInt</code>","text":"<p>             Bases: <code>_SupportsInt</code>, <code>Protocol</code></p> <p>A derivative of <code>beartype.typing.SupportsInt</code> with an override-able cache.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsInt(\n    _SupportsInt,\n    Protocol,\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A derivative of ``beartype.typing.SupportsInt`` with an override-able cache.\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsIndex","title":"<code>SupportsIndex</code>","text":"<p>             Bases: <code>_SupportsIndex</code>, <code>Protocol</code></p> <p>A derivative of <code>beartype.typing.SupportsIndex</code> with an override-able cache.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsIndex(\n    _SupportsIndex,\n    Protocol,\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A derivative of ``beartype.typing.SupportsIndex`` with an override-able cache.\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsRound","title":"<code>SupportsRound</code>","text":"<p>             Bases: <code>_SupportsRound[_T_co]</code>, <code>Protocol</code>, <code>Generic[_T_co]</code></p> <p>A derivative of <code>beartype.typing.SupportsRound</code> with an override-able cache.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsRound(\n    _SupportsRound[_T_co],\n    Protocol,\n    Generic[_T_co],\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A derivative of ``beartype.typing.SupportsRound`` with an override-able cache.\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsConjugate","title":"<code>SupportsConjugate</code>","text":"<p>             Bases: <code>_SupportsConjugate</code>, <code>Protocol</code></p> <p>A caching ABC defining the <code>conjugate</code> method.</p> <p>(<code>_SupportsConjugate</code> is the raw, non-caching version that defines the actual methods.)</p> <pre><code>&gt;&gt;&gt; from typing import TypeVar\n&gt;&gt;&gt; from numerary.types import SupportsConjugate\n&gt;&gt;&gt; MyConjugateT = TypeVar(\"MyConjugateT\", bound=SupportsConjugate)\n\n&gt;&gt;&gt; def conjugate_my_thing(arg: MyConjugateT) -&gt; MyConjugateT:\n...   assert isinstance(arg, SupportsConjugate)\n...   return arg.conjugate()\n\n&gt;&gt;&gt; conjugate_my_thing(3)\n3\n\n&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt; conjugate_my_thing(Decimal(2.5))\nDecimal('2.5')\n\n&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; conjugate_my_thing(sympy.Float(3.5))\n3.5\n&gt;&gt;&gt; type(_)\n&lt;class 'sympy.core.numbers.Float'&gt;\n\n&gt;&gt;&gt; # error: Value of type variable \"MyConjugateT\" of \"conjugate_my_thing\" cannot be \"str\"\n&gt;&gt;&gt; conjugate_my_thing(\"not-a-number\")  # type: ignore [type-var]\nTraceback (most recent call last):\n  ...\nAssertionError\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsConjugate(\n    _SupportsConjugate,\n    Protocol,\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC defining the [``conjugate``\n    method](https://docs.python.org/3/library/numbers.html#numbers.Complex.conjugate).\n\n    ([``_SupportsConjugate``][numerary.types._SupportsConjugate] is the raw, non-caching\n    version that defines the actual methods.)\n\n    ``` python\n    &gt;&gt;&gt; from typing import TypeVar\n    &gt;&gt;&gt; from numerary.types import SupportsConjugate\n    &gt;&gt;&gt; MyConjugateT = TypeVar(\"MyConjugateT\", bound=SupportsConjugate)\n\n    &gt;&gt;&gt; def conjugate_my_thing(arg: MyConjugateT) -&gt; MyConjugateT:\n    ...   assert isinstance(arg, SupportsConjugate)\n    ...   return arg.conjugate()\n\n    &gt;&gt;&gt; conjugate_my_thing(3)\n    3\n\n    &gt;&gt;&gt; from decimal import Decimal\n    &gt;&gt;&gt; conjugate_my_thing(Decimal(2.5))\n    Decimal('2.5')\n\n    &gt;&gt;&gt; import sympy\n    &gt;&gt;&gt; conjugate_my_thing(sympy.Float(3.5))\n    3.5\n    &gt;&gt;&gt; type(_)\n    &lt;class 'sympy.core.numbers.Float'&gt;\n\n    &gt;&gt;&gt; # error: Value of type variable \"MyConjugateT\" of \"conjugate_my_thing\" cannot be \"str\"\n    &gt;&gt;&gt; conjugate_my_thing(\"not-a-number\")  # type: ignore [type-var]\n    Traceback (most recent call last):\n      ...\n    AssertionError\n\n    ```\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsRealImag","title":"<code>SupportsRealImag</code>","text":"<p>             Bases: <code>_SupportsRealImag</code>, <code>Protocol</code></p> <p>A caching ABC defining the <code>real</code> and <code>imag</code> properties.</p> <p>(<code>_SupportsRealImag</code> is the raw, non-caching version that defines the actual methods.)</p> <pre><code>&gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n&gt;&gt;&gt; from numerary.types import SupportsRealImag, real, imag\n&gt;&gt;&gt; MyRealImagT = TypeVar(\"MyRealImagT\", bound=SupportsRealImag)\n\n&gt;&gt;&gt; def real_imag_my_thing(arg: MyRealImagT) -&gt; Tuple[Any, Any]:\n...   assert isinstance(arg, SupportsRealImag)\n...   return (real(arg), imag(arg))\n\n&gt;&gt;&gt; real_imag_my_thing(3)\n(3, 0)\n\n&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt; real_imag_my_thing(Decimal(2.5))\n(Decimal('2.5'), Decimal('0'))\n\n&gt;&gt;&gt; # error: Value of type variable \"MyRealImagT\" of \"real_imag_my_thing\" cannot be \"str\"\n&gt;&gt;&gt; real_imag_my_thing(\"not-a-number\")  # type: ignore [type-var]\nTraceback (most recent call last):\n  ...\nAssertionError\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsRealImag(\n    _SupportsRealImag,\n    Protocol,\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC defining the\n    [``real``](https://docs.python.org/3/library/numbers.html#numbers.Complex.real) and\n    [``imag``](https://docs.python.org/3/library/numbers.html#numbers.Complex.imag)\n    properties.\n\n    ([``_SupportsRealImag``][numerary.types._SupportsRealImag] is\n    the raw, non-caching version that defines the actual methods.)\n\n    ``` python\n    &gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n    &gt;&gt;&gt; from numerary.types import SupportsRealImag, real, imag\n    &gt;&gt;&gt; MyRealImagT = TypeVar(\"MyRealImagT\", bound=SupportsRealImag)\n\n    &gt;&gt;&gt; def real_imag_my_thing(arg: MyRealImagT) -&gt; Tuple[Any, Any]:\n    ...   assert isinstance(arg, SupportsRealImag)\n    ...   return (real(arg), imag(arg))\n\n    &gt;&gt;&gt; real_imag_my_thing(3)\n    (3, 0)\n\n    &gt;&gt;&gt; from decimal import Decimal\n    &gt;&gt;&gt; real_imag_my_thing(Decimal(2.5))\n    (Decimal('2.5'), Decimal('0'))\n\n    &gt;&gt;&gt; # error: Value of type variable \"MyRealImagT\" of \"real_imag_my_thing\" cannot be \"str\"\n    &gt;&gt;&gt; real_imag_my_thing(\"not-a-number\")  # type: ignore [type-var]\n    Traceback (most recent call last):\n      ...\n    AssertionError\n\n    ```\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsRealImagAsMethod","title":"<code>SupportsRealImagAsMethod</code>","text":"<p>             Bases: <code>_SupportsRealImagAsMethod</code>, <code>Protocol</code></p> <p>A caching ABC defining the <code>as_real_imag</code> method that returns a 2-tuple.</p> <p>(<code>_SupportsRealImagAsMethod</code> is the raw, non-caching version that defines the actual methods.)</p> <p>See also the <code>real</code> and <code>imag</code> helper functions.</p> <pre><code>&gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n&gt;&gt;&gt; from numerary.types import SupportsRealImagAsMethod, real, imag\n&gt;&gt;&gt; MyRealImagAsMethodT = TypeVar(\"MyRealImagAsMethodT\", bound=SupportsRealImagAsMethod)\n\n&gt;&gt;&gt; def as_real_imag_my_thing(arg: MyRealImagAsMethodT) -&gt; Tuple[Any, Any]:\n...   assert isinstance(arg, SupportsRealImagAsMethod)\n...   return (real(arg), imag(arg))\n\n&gt;&gt;&gt; as_real_imag_my_thing(sympy.Float(3.5))\n(3.5, 0)\n&gt;&gt;&gt; tuple(type(i) for i in _)\n(&lt;class 'sympy.core.numbers.Float'&gt;, &lt;class 'sympy.core.numbers.Zero'&gt;)\n\n&gt;&gt;&gt; # error: Value of type variable \"MyRealImagAsMethodT\" of \"as_real_imag_my_thing\" cannot be \"str\"\n&gt;&gt;&gt; as_real_imag_my_thing(\"not-a-number\")  # type: ignore [type-var]\nTraceback (most recent call last):\n  ...\nAssertionError\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsRealImagAsMethod(\n    _SupportsRealImagAsMethod,\n    Protocol,\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC defining the ``#!python as_real_imag`` method that returns a 2-tuple.\n\n    ([``_SupportsRealImagAsMethod``][numerary.types._SupportsRealImagAsMethod]\n    is the raw, non-caching version that defines the actual methods.)\n\n    See also the [``real``][numerary.types.real] and [``imag``][numerary.types.imag]\n    helper functions.\n\n    ``` python\n    &gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n    &gt;&gt;&gt; from numerary.types import SupportsRealImagAsMethod, real, imag\n    &gt;&gt;&gt; MyRealImagAsMethodT = TypeVar(\"MyRealImagAsMethodT\", bound=SupportsRealImagAsMethod)\n\n    &gt;&gt;&gt; def as_real_imag_my_thing(arg: MyRealImagAsMethodT) -&gt; Tuple[Any, Any]:\n    ...   assert isinstance(arg, SupportsRealImagAsMethod)\n    ...   return (real(arg), imag(arg))\n\n    &gt;&gt;&gt; as_real_imag_my_thing(sympy.Float(3.5))\n    (3.5, 0)\n    &gt;&gt;&gt; tuple(type(i) for i in _)\n    (&lt;class 'sympy.core.numbers.Float'&gt;, &lt;class 'sympy.core.numbers.Zero'&gt;)\n\n    &gt;&gt;&gt; # error: Value of type variable \"MyRealImagAsMethodT\" of \"as_real_imag_my_thing\" cannot be \"str\"\n    &gt;&gt;&gt; as_real_imag_my_thing(\"not-a-number\")  # type: ignore [type-var]\n    Traceback (most recent call last):\n      ...\n    AssertionError\n\n    ```\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsTrunc","title":"<code>SupportsTrunc</code>","text":"<p>             Bases: <code>_SupportsTrunc</code>, <code>Protocol</code></p> <p>A caching ABC defining the <code>__trunc__</code> method.</p> <p>See also the <code>__trunc__</code> helper function.</p> <p>(<code>_SupportsTrunc</code> is the raw, non-caching version that defines the actual methods.)</p> <pre><code>&gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n&gt;&gt;&gt; from numerary.types import SupportsTrunc, __trunc__\n&gt;&gt;&gt; MyTruncT = TypeVar(\"MyTruncT\", bound=SupportsTrunc)\n\n&gt;&gt;&gt; def trunc_my_thing(arg: MyTruncT) -&gt; Tuple[Any, Any]:\n...   assert isinstance(arg, SupportsTrunc)\n...   return __trunc__(arg)\n\n&gt;&gt;&gt; trunc_my_thing(3)\n3\n\n&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt; trunc_my_thing(Decimal(2.5))\n2\n\n&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; trunc_my_thing(sympy.Float(3.5))\n3\n&gt;&gt;&gt; type(_)\n&lt;class 'sympy.core.numbers.Integer'&gt;\n\n&gt;&gt;&gt; # error: Value of type variable \"MyTruncT\" of \"trunc_my_thing\" cannot be \"str\"\n&gt;&gt;&gt; trunc_my_thing(\"not-a-number\")  # type: ignore [type-var]\nTraceback (most recent call last):\n  ...\nAssertionError\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsTrunc(\n    _SupportsTrunc,\n    Protocol,\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC defining the [``__trunc__``\n    method](https://docs.python.org/3/reference/datamodel.html#object.__trunc__).\n\n    See also the [``__trunc__`` helper function][numerary.types.__trunc__].\n\n    ([``_SupportsTrunc``][numerary.types._SupportsTrunc] is the raw, non-caching version\n    that defines the actual methods.)\n\n    ``` python\n    &gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n    &gt;&gt;&gt; from numerary.types import SupportsTrunc, __trunc__\n    &gt;&gt;&gt; MyTruncT = TypeVar(\"MyTruncT\", bound=SupportsTrunc)\n\n    &gt;&gt;&gt; def trunc_my_thing(arg: MyTruncT) -&gt; Tuple[Any, Any]:\n    ...   assert isinstance(arg, SupportsTrunc)\n    ...   return __trunc__(arg)\n\n    &gt;&gt;&gt; trunc_my_thing(3)\n    3\n\n    &gt;&gt;&gt; from decimal import Decimal\n    &gt;&gt;&gt; trunc_my_thing(Decimal(2.5))\n    2\n\n    &gt;&gt;&gt; import sympy\n    &gt;&gt;&gt; trunc_my_thing(sympy.Float(3.5))\n    3\n    &gt;&gt;&gt; type(_)\n    &lt;class 'sympy.core.numbers.Integer'&gt;\n\n    &gt;&gt;&gt; # error: Value of type variable \"MyTruncT\" of \"trunc_my_thing\" cannot be \"str\"\n    &gt;&gt;&gt; trunc_my_thing(\"not-a-number\")  # type: ignore [type-var]\n    Traceback (most recent call last):\n      ...\n    AssertionError\n\n    ```\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsFloorCeil","title":"<code>SupportsFloorCeil</code>","text":"<p>             Bases: <code>_SupportsFloorCeil</code>, <code>Protocol</code></p> <p>A caching ABC defining the <code>__floor__</code>. and <code>__ceil__</code> methods.</p> <p>(<code>_SupportsFloorCeil</code> is the raw, non-caching version that defines the actual methods.)</p> <p>Note</p> <p>This is of limited value for Python versions prior to 3.9, since <code>float.__floor__</code> and <code>float.__ceil__</code> were not defined. If support for those environments is important, consider using <code>SupportsFloat</code> instead.</p> <p>See also the <code>__floor__</code> and <code>__ceil__</code> helper functions.</p> <pre><code>&gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n&gt;&gt;&gt; from numerary.types import SupportsFloorCeil, __ceil__, __floor__\n&gt;&gt;&gt; MyFloorCeilT = TypeVar(\"MyFloorCeilT\", bound=SupportsFloorCeil)\n\n&gt;&gt;&gt; def floor_ceil_my_thing(arg: MyFloorCeilT) -&gt; Tuple[int, int]:\n...   assert isinstance(arg, SupportsFloorCeil)\n...   return __floor__(arg), __ceil__(arg)\n\n&gt;&gt;&gt; floor_ceil_my_thing(3)\n(3, 3)\n\n&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt; floor_ceil_my_thing(Decimal(2.5))\n(2, 3)\n\n&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; floor_ceil_my_thing(sympy.Float(3.5))\n(3, 4)\n&gt;&gt;&gt; tuple(type(i) for i in _)\n(&lt;class 'sympy.core.numbers.Integer'&gt;, &lt;class 'sympy.core.numbers.Integer'&gt;)\n\n&gt;&gt;&gt; # error: Value of type variable \"MyFloorCeilT\" of \"floor_ceil_my_thing\" cannot be \"str\"\n&gt;&gt;&gt; floor_ceil_my_thing(\"not-a-number\")  # type: ignore [type-var]\nTraceback (most recent call last):\n  ...\nAssertionError\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsFloorCeil(\n    _SupportsFloorCeil,\n    Protocol,\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC defining the\n    [``__floor__``](https://docs.python.org/3/reference/datamodel.html#object.__floor__).\n    and\n    [``__ceil__``](https://docs.python.org/3/reference/datamodel.html#object.__ceil__)\n    methods.\n\n    ([``_SupportsFloorCeil``][numerary.types._SupportsFloorCeil] is the raw, non-caching\n    version that defines the actual methods.)\n\n    !!! note\n\n        This is of limited value for Python versions prior to 3.9, since ``#!python\n        float.__floor__`` and ``#!python float.__ceil__`` were not defined. If support\n        for those environments is important, consider using\n        [``SupportsFloat``][numerary.types.SupportsFloat] instead.\n\n        See also the [``__floor__``][numerary.types.__floor__] and\n        [``__ceil__``][numerary.types.__ceil__] helper functions.\n\n    ``` python\n    &gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n    &gt;&gt;&gt; from numerary.types import SupportsFloorCeil, __ceil__, __floor__\n    &gt;&gt;&gt; MyFloorCeilT = TypeVar(\"MyFloorCeilT\", bound=SupportsFloorCeil)\n\n    &gt;&gt;&gt; def floor_ceil_my_thing(arg: MyFloorCeilT) -&gt; Tuple[int, int]:\n    ...   assert isinstance(arg, SupportsFloorCeil)\n    ...   return __floor__(arg), __ceil__(arg)\n\n    &gt;&gt;&gt; floor_ceil_my_thing(3)\n    (3, 3)\n\n    &gt;&gt;&gt; from decimal import Decimal\n    &gt;&gt;&gt; floor_ceil_my_thing(Decimal(2.5))\n    (2, 3)\n\n    &gt;&gt;&gt; import sympy\n    &gt;&gt;&gt; floor_ceil_my_thing(sympy.Float(3.5))\n    (3, 4)\n    &gt;&gt;&gt; tuple(type(i) for i in _)\n    (&lt;class 'sympy.core.numbers.Integer'&gt;, &lt;class 'sympy.core.numbers.Integer'&gt;)\n\n    &gt;&gt;&gt; # error: Value of type variable \"MyFloorCeilT\" of \"floor_ceil_my_thing\" cannot be \"str\"\n    &gt;&gt;&gt; floor_ceil_my_thing(\"not-a-number\")  # type: ignore [type-var]\n    Traceback (most recent call last):\n      ...\n    AssertionError\n\n    ```\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsDivmod","title":"<code>SupportsDivmod</code>","text":"<p>             Bases: <code>_SupportsDivmod[_T_co]</code>, <code>Protocol</code>, <code>Generic[_T_co]</code></p> <p>A caching ABC defining the <code>__divmod__</code> and <code>__rdivmod__</code> methods. Each returns a 2-tuple of covariants.</p> <p>(<code>_SupportsDivmod</code> is the raw, non-caching version that defines the actual methods.)</p> <pre><code>&gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n&gt;&gt;&gt; from numerary.types import SupportsDivmod\n&gt;&gt;&gt; MyDivmodT = TypeVar(\"MyDivmodT\", bound=SupportsDivmod)\n\n&gt;&gt;&gt; def divmod_my_thing(arg: MyDivmodT, other: Any) -&gt; Tuple[MyDivmodT, MyDivmodT]:\n...   assert isinstance(arg, SupportsDivmod)\n...   return divmod(arg, other)\n\n&gt;&gt;&gt; divmod_my_thing(2, 1)\n(2, 0)\n\n&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt; divmod_my_thing(Decimal(2.5), Decimal(1.5))\n(Decimal('1'), Decimal('1.0'))\n\n&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; divmod_my_thing(sympy.Float(3.5), sympy.Float(1.5))\n(2, 0.5)\n&gt;&gt;&gt; tuple(type(i) for i in _)\n(&lt;class 'sympy.core.numbers.Integer'&gt;, &lt;class 'sympy.core.numbers.Float'&gt;)\n\n&gt;&gt;&gt; # error: Value of type variable \"MyDivmodT\" of \"divmod_my_thing\" cannot be \"str\"\n&gt;&gt;&gt; divmod_my_thing(\"not-a-number\", \"still-not-a-number\")  # type: ignore [type-var]\nTraceback (most recent call last):\n  ...\nAssertionError\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsDivmod(\n    _SupportsDivmod[_T_co],\n    Protocol,\n    Generic[_T_co],\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC defining the\n    [``__divmod__``](https://docs.python.org/3/reference/datamodel.html#object.__divmod__)\n    and\n    [``__rdivmod__``](https://docs.python.org/3/reference/datamodel.html#object.__rdivmod__)\n    methods. Each returns a 2-tuple of covariants.\n\n    ([``_SupportsDivmod``][numerary.types._SupportsDivmod] is the raw, non-caching\n    version that defines the actual methods.)\n\n    ``` python\n    &gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n    &gt;&gt;&gt; from numerary.types import SupportsDivmod\n    &gt;&gt;&gt; MyDivmodT = TypeVar(\"MyDivmodT\", bound=SupportsDivmod)\n\n    &gt;&gt;&gt; def divmod_my_thing(arg: MyDivmodT, other: Any) -&gt; Tuple[MyDivmodT, MyDivmodT]:\n    ...   assert isinstance(arg, SupportsDivmod)\n    ...   return divmod(arg, other)\n\n    &gt;&gt;&gt; divmod_my_thing(2, 1)\n    (2, 0)\n\n    &gt;&gt;&gt; from decimal import Decimal\n    &gt;&gt;&gt; divmod_my_thing(Decimal(2.5), Decimal(1.5))\n    (Decimal('1'), Decimal('1.0'))\n\n    &gt;&gt;&gt; import sympy\n    &gt;&gt;&gt; divmod_my_thing(sympy.Float(3.5), sympy.Float(1.5))\n    (2, 0.5)\n    &gt;&gt;&gt; tuple(type(i) for i in _)\n    (&lt;class 'sympy.core.numbers.Integer'&gt;, &lt;class 'sympy.core.numbers.Float'&gt;)\n\n    &gt;&gt;&gt; # error: Value of type variable \"MyDivmodT\" of \"divmod_my_thing\" cannot be \"str\"\n    &gt;&gt;&gt; divmod_my_thing(\"not-a-number\", \"still-not-a-number\")  # type: ignore [type-var]\n    Traceback (most recent call last):\n      ...\n    AssertionError\n\n    ```\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominator","title":"<code>SupportsNumeratorDenominator</code>","text":"<p>             Bases: <code>_SupportsNumeratorDenominator</code>, <code>Protocol</code></p> <p>A caching ABC defining the <code>numerator</code> and <code>denominator</code> properties.</p> <p>(<code>_SupportsNumeratorDenominator</code> is the raw, non-caching version that defines the actual properties.)</p> <pre><code>&gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n&gt;&gt;&gt; from numerary.types import SupportsNumeratorDenominator, denominator, numerator\n&gt;&gt;&gt; MyNumDenomT = TypeVar(\"MyNumDenomT\", bound=SupportsNumeratorDenominator)\n\n&gt;&gt;&gt; def num_denom_my_thing(arg: MyNumDenomT) -&gt; Tuple[int, int]:\n...   assert isinstance(arg, SupportsNumeratorDenominator)\n...   return numerator(arg), denominator(arg)\n\n&gt;&gt;&gt; num_denom_my_thing(3)\n(3, 1)\n\n&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; num_denom_my_thing(Fraction(2, 3))\n(2, 3)\n\n&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; num_denom_my_thing(sympy.Rational(3, 4))\n(3, 4)\n&gt;&gt;&gt; tuple(type(i) for i in _)\n(&lt;class 'int'&gt;, &lt;class 'int'&gt;)\n\n&gt;&gt;&gt; # error: Value of type variable \"MyNumDenomT\" of \"num_denom_my_thing\" cannot be \"str\"\n&gt;&gt;&gt; num_denom_my_thing(\"not-a-number\")  # type: ignore [type-var]\nTraceback (most recent call last):\n  ...\nAssertionError\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsNumeratorDenominator(\n    _SupportsNumeratorDenominator,\n    Protocol,\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC defining the\n    [``numerator``](https://docs.python.org/3/library/numbers.html#numbers.Rational.numerator)\n    and\n    [``denominator``](https://docs.python.org/3/library/numbers.html#numbers.Rational.denominator)\n    properties.\n\n    ([``_SupportsNumeratorDenominator``][numerary.types._SupportsNumeratorDenominator]\n    is the raw, non-caching version that defines the actual properties.)\n\n    ``` python\n    &gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n    &gt;&gt;&gt; from numerary.types import SupportsNumeratorDenominator, denominator, numerator\n    &gt;&gt;&gt; MyNumDenomT = TypeVar(\"MyNumDenomT\", bound=SupportsNumeratorDenominator)\n\n    &gt;&gt;&gt; def num_denom_my_thing(arg: MyNumDenomT) -&gt; Tuple[int, int]:\n    ...   assert isinstance(arg, SupportsNumeratorDenominator)\n    ...   return numerator(arg), denominator(arg)\n\n    &gt;&gt;&gt; num_denom_my_thing(3)\n    (3, 1)\n\n    &gt;&gt;&gt; from fractions import Fraction\n    &gt;&gt;&gt; num_denom_my_thing(Fraction(2, 3))\n    (2, 3)\n\n    &gt;&gt;&gt; import sympy\n    &gt;&gt;&gt; num_denom_my_thing(sympy.Rational(3, 4))\n    (3, 4)\n    &gt;&gt;&gt; tuple(type(i) for i in _)\n    (&lt;class 'int'&gt;, &lt;class 'int'&gt;)\n\n    &gt;&gt;&gt; # error: Value of type variable \"MyNumDenomT\" of \"num_denom_my_thing\" cannot be \"str\"\n    &gt;&gt;&gt; num_denom_my_thing(\"not-a-number\")  # type: ignore [type-var]\n    Traceback (most recent call last):\n      ...\n    AssertionError\n\n    ```\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMethods","title":"<code>SupportsNumeratorDenominatorMethods</code>","text":"<p>             Bases: <code>_SupportsNumeratorDenominatorMethods</code>, <code>Protocol</code></p> <p>A caching ABC defining <code>numerator</code> and <code>denominator</code> methods. Each returns a <code>SupportsInt</code>.</p> <p>(<code>_SupportsNumeratorDenominatorMethods</code> is the raw, non-caching version that defines the actual methods.)</p> <p>See also the <code>numerator</code> and <code>denominator</code> helper functions.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsNumeratorDenominatorMethods(\n    _SupportsNumeratorDenominatorMethods,\n    Protocol,\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC defining ``#!python numerator`` and ``#!python denominator`` methods.\n    Each returns a [``SupportsInt``][numerary.types.SupportsInt].\n\n    ([``_SupportsNumeratorDenominatorMethods``][numerary.types._SupportsNumeratorDenominatorMethods]\n    is the raw, non-caching version that defines the actual methods.)\n\n    See also the [``numerator``][numerary.types.numerator] and\n    [``denominator``][numerary.types.denominator] helper functions.\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsComplexOps","title":"<code>SupportsComplexOps</code>","text":"<p>             Bases: <code>_SupportsComplexOps[_T_co]</code>, <code>Protocol</code>, <code>Generic[_T_co]</code></p> <p>A caching ABC defining the <code>Complex</code> operator methods with covariant return values.</p> <p>(<code>_SupportsComplexOps</code> is the raw, non-caching version that defines the actual methods.)</p> <pre><code>&gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n&gt;&gt;&gt; from numerary.types import SupportsComplexOps\n&gt;&gt;&gt; MyComplexOpsT = TypeVar(\"MyComplexOpsT\", bound=SupportsComplexOps)\n\n&gt;&gt;&gt; def complex_ops_my_thing(arg: MyComplexOpsT) -&gt; MyComplexOpsT:\n...   assert isinstance(arg, SupportsComplexOps)\n...   return arg * -2 + 5\n\n&gt;&gt;&gt; complex_ops_my_thing(3)\n-1\n\n&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt; complex_ops_my_thing(Decimal(\"2.5\"))\nDecimal('0.0')\n\n&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; complex_ops_my_thing(sympy.Float(3.5))\n-2.0\n&gt;&gt;&gt; type(_)\n&lt;class 'sympy.core.numbers.Float'&gt;\n\n&gt;&gt;&gt; # error: Value of type variable \"MyComplexOpsT\" of \"complex_ops_my_thing\" cannot be \"str\"\n&gt;&gt;&gt; complex_ops_my_thing(\"not-a-number\")  # type: ignore [type-var]\nTraceback (most recent call last):\n  ...\nAssertionError\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsComplexOps(\n    _SupportsComplexOps[_T_co],\n    Protocol,\n    Generic[_T_co],\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC defining the [``Complex`` operator\n    methods](https://docs.python.org/3/library/numbers.html#numbers.Complex) with\n    covariant return values.\n\n    ([``_SupportsComplexOps``][numerary.types._SupportsComplexOps] is the raw,\n    non-caching version that defines the actual methods.)\n\n    ``` python\n    &gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n    &gt;&gt;&gt; from numerary.types import SupportsComplexOps\n    &gt;&gt;&gt; MyComplexOpsT = TypeVar(\"MyComplexOpsT\", bound=SupportsComplexOps)\n\n    &gt;&gt;&gt; def complex_ops_my_thing(arg: MyComplexOpsT) -&gt; MyComplexOpsT:\n    ...   assert isinstance(arg, SupportsComplexOps)\n    ...   return arg * -2 + 5\n\n    &gt;&gt;&gt; complex_ops_my_thing(3)\n    -1\n\n    &gt;&gt;&gt; from decimal import Decimal\n    &gt;&gt;&gt; complex_ops_my_thing(Decimal(\"2.5\"))\n    Decimal('0.0')\n\n    &gt;&gt;&gt; import sympy\n    &gt;&gt;&gt; complex_ops_my_thing(sympy.Float(3.5))\n    -2.0\n    &gt;&gt;&gt; type(_)\n    &lt;class 'sympy.core.numbers.Float'&gt;\n\n    &gt;&gt;&gt; # error: Value of type variable \"MyComplexOpsT\" of \"complex_ops_my_thing\" cannot be \"str\"\n    &gt;&gt;&gt; complex_ops_my_thing(\"not-a-number\")  # type: ignore [type-var]\n    Traceback (most recent call last):\n      ...\n    AssertionError\n\n    ```\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsComplexPow","title":"<code>SupportsComplexPow</code>","text":"<p>             Bases: <code>_SupportsComplexPow</code>, <code>Protocol</code></p> <p>A caching ABC defining the <code>Complex</code> (i.e., non-modulo) versions of the <code>__pow__</code> and <code>__rpow__</code>.</p> <p>(<code>_SupportsComplexPow</code> is the raw, non-caching version that defines the actual methods.)</p> <pre><code>&gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n&gt;&gt;&gt; from numerary.types import SupportsComplexPow\n&gt;&gt;&gt; MyComplexPowT = TypeVar(\"MyComplexPowT\", bound=SupportsComplexPow)\n\n&gt;&gt;&gt; def complex_pow_my_thing(arg: MyComplexPowT) -&gt; MyComplexPowT:\n...   assert isinstance(arg, SupportsComplexPow)\n...   return arg ** -2\n\n&gt;&gt;&gt; complex_pow_my_thing(3)\n0.1111111111111111\n\n&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt; complex_pow_my_thing(Decimal(\"2.5\"))\nDecimal('0.16')\n\n&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; complex_pow_my_thing(sympy.Float(3.5))\n0.0816326530612245\n&gt;&gt;&gt; type(_)\n&lt;class 'sympy.core.numbers.Float'&gt;\n\n&gt;&gt;&gt; # error: Value of type variable \"MyComplexPowT\" of \"complex_pow_my_thing\" cannot be \"str\"\n&gt;&gt;&gt; complex_pow_my_thing(\"not-a-number\")  # type: ignore [type-var]\nTraceback (most recent call last):\n  ...\nAssertionError\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsComplexPow(\n    _SupportsComplexPow,\n    Protocol,\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC defining the ``#!python Complex`` (i.e., non-modulo) versions of the\n    [``__pow__``](https://docs.python.org/3/reference/datamodel.html#object.__pow__) and\n    [``__rpow__``](https://docs.python.org/3/reference/datamodel.html#object.__rpow__).\n\n    ([``_SupportsComplexPow``][numerary.types._SupportsComplexPow] is the raw,\n    non-caching version that defines the actual methods.)\n\n    ``` python\n    &gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n    &gt;&gt;&gt; from numerary.types import SupportsComplexPow\n    &gt;&gt;&gt; MyComplexPowT = TypeVar(\"MyComplexPowT\", bound=SupportsComplexPow)\n\n    &gt;&gt;&gt; def complex_pow_my_thing(arg: MyComplexPowT) -&gt; MyComplexPowT:\n    ...   assert isinstance(arg, SupportsComplexPow)\n    ...   return arg ** -2\n\n    &gt;&gt;&gt; complex_pow_my_thing(3)\n    0.1111111111111111\n\n    &gt;&gt;&gt; from decimal import Decimal\n    &gt;&gt;&gt; complex_pow_my_thing(Decimal(\"2.5\"))\n    Decimal('0.16')\n\n    &gt;&gt;&gt; import sympy\n    &gt;&gt;&gt; complex_pow_my_thing(sympy.Float(3.5))\n    0.0816326530612245\n    &gt;&gt;&gt; type(_)\n    &lt;class 'sympy.core.numbers.Float'&gt;\n\n    &gt;&gt;&gt; # error: Value of type variable \"MyComplexPowT\" of \"complex_pow_my_thing\" cannot be \"str\"\n    &gt;&gt;&gt; complex_pow_my_thing(\"not-a-number\")  # type: ignore [type-var]\n    Traceback (most recent call last):\n      ...\n    AssertionError\n\n    ```\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsRealOps","title":"<code>SupportsRealOps</code>","text":"<p>             Bases: <code>_SupportsRealOps[_T_co]</code>, <code>Protocol</code>, <code>Generic[_T_co]</code></p> <p>A caching ABC defining the <code>Real</code> operator methods with covariant return values.</p> <p>(<code>_SupportsRealOps</code> is the raw, non-caching version that defines the actual methods.)</p> <pre><code>&gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n&gt;&gt;&gt; from numerary.types import SupportsRealOps\n&gt;&gt;&gt; MyRealOpsT = TypeVar(\"MyRealOpsT\", bound=SupportsRealOps)\n\n&gt;&gt;&gt; def real_ops_my_thing(arg: MyRealOpsT) -&gt; Any:\n...   assert isinstance(arg, SupportsRealOps)\n...   return arg // -2\n\n&gt;&gt;&gt; real_ops_my_thing(3)\n-2\n\n&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt; real_ops_my_thing(Decimal(\"2.5\"))\nDecimal('-1')\n\n&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; real_ops_my_thing(sympy.Float(3.5))\n-2\n&gt;&gt;&gt; type(_)\n&lt;class 'sympy.core.numbers.Integer'&gt;\n\n&gt;&gt;&gt; # error: Value of type variable \"MyRealOpsT\" of \"real_ops_my_thing\" cannot be \"str\"\n&gt;&gt;&gt; real_ops_my_thing(\"not-a-number\")  # type: ignore [type-var]\nTraceback (most recent call last):\n  ...\nAssertionError\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsRealOps(\n    _SupportsRealOps[_T_co],\n    Protocol,\n    Generic[_T_co],\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC defining the [``Real`` operator\n    methods](https://docs.python.org/3/library/numbers.html#numbers.Real) with covariant\n    return values.\n\n    ([``_SupportsRealOps``][numerary.types._SupportsRealOps] is the raw, non-caching\n    version that defines the actual methods.)\n\n    ``` python\n    &gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n    &gt;&gt;&gt; from numerary.types import SupportsRealOps\n    &gt;&gt;&gt; MyRealOpsT = TypeVar(\"MyRealOpsT\", bound=SupportsRealOps)\n\n    &gt;&gt;&gt; def real_ops_my_thing(arg: MyRealOpsT) -&gt; Any:\n    ...   assert isinstance(arg, SupportsRealOps)\n    ...   return arg // -2\n\n    &gt;&gt;&gt; real_ops_my_thing(3)\n    -2\n\n    &gt;&gt;&gt; from decimal import Decimal\n    &gt;&gt;&gt; real_ops_my_thing(Decimal(\"2.5\"))\n    Decimal('-1')\n\n    &gt;&gt;&gt; import sympy\n    &gt;&gt;&gt; real_ops_my_thing(sympy.Float(3.5))\n    -2\n    &gt;&gt;&gt; type(_)\n    &lt;class 'sympy.core.numbers.Integer'&gt;\n\n    &gt;&gt;&gt; # error: Value of type variable \"MyRealOpsT\" of \"real_ops_my_thing\" cannot be \"str\"\n    &gt;&gt;&gt; real_ops_my_thing(\"not-a-number\")  # type: ignore [type-var]\n    Traceback (most recent call last):\n      ...\n    AssertionError\n\n    ```\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps","title":"<code>SupportsIntegralOps</code>","text":"<p>             Bases: <code>_SupportsIntegralOps[_T_co]</code>, <code>Protocol</code>, <code>Generic[_T_co]</code></p> <p>A caching ABC defining the <code>Integral</code> operator methods with covariant return values.</p> <p>(<code>_SupportsIntegralOps</code> is the raw, non-caching version that defines the actual methods.)</p> <pre><code>&gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n&gt;&gt;&gt; from numerary.types import SupportsIntegralOps\n&gt;&gt;&gt; MyIntegralOpsT = TypeVar(\"MyIntegralOpsT\", bound=SupportsIntegralOps)\n\n&gt;&gt;&gt; def integral_ops_my_thing(arg: MyIntegralOpsT) -&gt; MyIntegralOpsT:\n...   assert isinstance(arg, SupportsIntegralOps)\n...   return arg &lt;&lt; 1\n\n&gt;&gt;&gt; integral_ops_my_thing(3)\n6\n\n&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; integral_ops_my_thing(sympy.Integer(3))\n6\n&gt;&gt;&gt; type(_)\n&lt;class 'sympy.core.numbers.Integer'&gt;\n\n&gt;&gt;&gt; # error: Value of type variable \"MyIntegralOpsT\" of \"integral_ops_my_thing\" cannot be \"str\"\n&gt;&gt;&gt; integral_ops_my_thing(\"not-a-number\")  # type: ignore [type-var]\nTraceback (most recent call last):\n  ...\nAssertionError\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsIntegralOps(\n    _SupportsIntegralOps[_T_co],\n    Protocol,\n    Generic[_T_co],\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC defining the [``Integral`` operator\n    methods](https://docs.python.org/3/library/numbers.html#numbers.Integral) with\n    covariant return values.\n\n    ([``_SupportsIntegralOps``][numerary.types._SupportsIntegralOps] is the raw,\n    non-caching version that defines the actual methods.)\n\n    ``` python\n    &gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n    &gt;&gt;&gt; from numerary.types import SupportsIntegralOps\n    &gt;&gt;&gt; MyIntegralOpsT = TypeVar(\"MyIntegralOpsT\", bound=SupportsIntegralOps)\n\n    &gt;&gt;&gt; def integral_ops_my_thing(arg: MyIntegralOpsT) -&gt; MyIntegralOpsT:\n    ...   assert isinstance(arg, SupportsIntegralOps)\n    ...   return arg &lt;&lt; 1\n\n    &gt;&gt;&gt; integral_ops_my_thing(3)\n    6\n\n    &gt;&gt;&gt; import sympy\n    &gt;&gt;&gt; integral_ops_my_thing(sympy.Integer(3))\n    6\n    &gt;&gt;&gt; type(_)\n    &lt;class 'sympy.core.numbers.Integer'&gt;\n\n    &gt;&gt;&gt; # error: Value of type variable \"MyIntegralOpsT\" of \"integral_ops_my_thing\" cannot be \"str\"\n    &gt;&gt;&gt; integral_ops_my_thing(\"not-a-number\")  # type: ignore [type-var]\n    Traceback (most recent call last):\n      ...\n    AssertionError\n\n    ```\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow","title":"<code>SupportsIntegralPow</code>","text":"<p>             Bases: <code>_SupportsIntegralPow</code>, <code>Protocol</code></p> <p>A caching ABC defining the <code>Integral</code> (i.e., modulo) versions of the <code>__pow__</code> and <code>__rpow__</code> methods.</p> <p>(<code>_SupportsIntegralPow</code> is the raw, non-caching version that defines the actual methods.)</p> <pre><code>&gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n&gt;&gt;&gt; from numerary.types import SupportsIntegralPow\n&gt;&gt;&gt; MyIntegralPowT = TypeVar(\"MyIntegralPowT\", bound=SupportsIntegralPow)\n\n&gt;&gt;&gt; def integral_pow_my_thing(arg: MyIntegralPowT) -&gt; MyIntegralPowT:\n...   assert isinstance(arg, SupportsIntegralPow)\n...   return pow(arg, 2, 2)\n\n&gt;&gt;&gt; integral_pow_my_thing(3)\n1\n\n&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; integral_pow_my_thing(sympy.Integer(3))\n1\n&gt;&gt;&gt; type(_)\n&lt;class 'sympy.core.numbers.One'&gt;\n\n&gt;&gt;&gt; # error: Value of type variable \"MyIntegralPowT\" of \"integral_pow_my_thing\" cannot be \"str\"\n&gt;&gt;&gt; integral_pow_my_thing(\"not-a-number\")  # type: ignore [type-var]\nTraceback (most recent call last):\n  ...\nAssertionError\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass SupportsIntegralPow(\n    _SupportsIntegralPow,\n    Protocol,\n    metaclass=CachingProtocolMeta,\n):\nr\"\"\"\n    A caching ABC defining the ``#!python Integral`` (i.e., modulo) versions of the\n    [``__pow__``](https://docs.python.org/3/reference/datamodel.html#object.__pow__) and\n    [``__rpow__``](https://docs.python.org/3/reference/datamodel.html#object.__rpow__)\n    methods.\n\n    ([``_SupportsIntegralPow``][numerary.types._SupportsIntegralPow] is the raw,\n    non-caching version that defines the actual methods.)\n\n    ``` python\n    &gt;&gt;&gt; from typing import Any, Tuple, TypeVar\n    &gt;&gt;&gt; from numerary.types import SupportsIntegralPow\n    &gt;&gt;&gt; MyIntegralPowT = TypeVar(\"MyIntegralPowT\", bound=SupportsIntegralPow)\n\n    &gt;&gt;&gt; def integral_pow_my_thing(arg: MyIntegralPowT) -&gt; MyIntegralPowT:\n    ...   assert isinstance(arg, SupportsIntegralPow)\n    ...   return pow(arg, 2, 2)\n\n    &gt;&gt;&gt; integral_pow_my_thing(3)\n    1\n\n    &gt;&gt;&gt; import sympy\n    &gt;&gt;&gt; integral_pow_my_thing(sympy.Integer(3))\n    1\n    &gt;&gt;&gt; type(_)\n    &lt;class 'sympy.core.numbers.One'&gt;\n\n    &gt;&gt;&gt; # error: Value of type variable \"MyIntegralPowT\" of \"integral_pow_my_thing\" cannot be \"str\"\n    &gt;&gt;&gt; integral_pow_my_thing(\"not-a-number\")  # type: ignore [type-var]\n    Traceback (most recent call last):\n      ...\n    AssertionError\n\n    ```\n    \"\"\"\n</code></pre>"},{"location":"numerary.types/#numerary.types.real","title":"<code>real(operand: SupportsRealImagMixedU)</code>","text":"<p>Helper function that extracts the real part from operand including resolving non-compliant implementations that implement such extraction via a <code>as_real_imag</code> method rather than as properties.</p> <pre><code>&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; from numerary.types import real\n&gt;&gt;&gt; real(sympy.Float(3.5))\n3.5\n</code></pre> <p>See SupportsRealImag and SupportsRealImagAsMethod.</p> Source code in <code>numerary/types.py</code> <pre><code>@beartype\ndef real(operand: SupportsRealImagMixedU):\nr\"\"\"\n    Helper function that extracts the real part from *operand* including resolving\n    non-compliant implementations that implement such extraction via a ``as_real_imag``\n    method rather than as properties.\n\n    ``` python\n    &gt;&gt;&gt; import sympy\n    &gt;&gt;&gt; from numerary.types import real\n    &gt;&gt;&gt; real(sympy.Float(3.5))\n    3.5\n\n    ```\n\n    See\n    [SupportsRealImag][numerary.types.SupportsRealImag]\n    and\n    [SupportsRealImagAsMethod][numerary.types.SupportsRealImagAsMethod].\n    \"\"\"\n    if callable(getattr(operand, \"as_real_imag\", None)):\n        real_part, _ = operand.as_real_imag()  # type: ignore [union-attr]\n\n        return real_part\n    elif hasattr(operand, \"real\"):\n        return operand.real\n    else:\n        raise TypeError(f\"{operand!r} has no real or as_real_imag\")\n</code></pre>"},{"location":"numerary.types/#numerary.types.imag","title":"<code>imag(operand: SupportsRealImagMixedU)</code>","text":"<p>Helper function that extracts the imaginary part from operand including resolving non-compliant implementations that implement such extraction via a <code>as_real_imag</code> method rather than as properties.</p> <pre><code>&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; from numerary.types import real\n&gt;&gt;&gt; imag(sympy.Float(3.5))\n0\n</code></pre> <p>See SupportsRealImag and SupportsRealImagAsMethod.</p> Source code in <code>numerary/types.py</code> <pre><code>@beartype\ndef imag(operand: SupportsRealImagMixedU):\nr\"\"\"\n    Helper function that extracts the imaginary part from *operand* including resolving\n    non-compliant implementations that implement such extraction via a ``as_real_imag``\n    method rather than as properties.\n\n    ``` python\n    &gt;&gt;&gt; import sympy\n    &gt;&gt;&gt; from numerary.types import real\n    &gt;&gt;&gt; imag(sympy.Float(3.5))\n    0\n\n    ```\n\n    See\n    [SupportsRealImag][numerary.types.SupportsRealImag]\n    and\n    [SupportsRealImagAsMethod][numerary.types.SupportsRealImagAsMethod].\n    \"\"\"\n    if callable(getattr(operand, \"as_real_imag\", None)):\n        _, imag_part = operand.as_real_imag()  # type: ignore [union-attr]\n\n        return imag_part\n    elif hasattr(operand, \"imag\"):\n        return operand.imag\n    else:\n        raise TypeError(f\"{operand!r} has no real or as_real_imag\")\n</code></pre>"},{"location":"numerary.types/#numerary.types.__pow__","title":"<code>__pow__(arg: Union[SupportsComplexPow, SupportsIntegralPow], exponent: Any, modulus: Optional[Any] = None) -&gt; Any</code>","text":"<p>Helper function that wraps <code>pow</code> to work with <code>SupportsComplexPow</code>, <code>SupportsIntegralPow</code>.</p> <pre><code>&gt;&gt;&gt; from numerary.types import SupportsComplexPow, SupportsIntegralPow, __pow__\n&gt;&gt;&gt; my_complex_pow: SupportsComplexPow = complex(2)\n&gt;&gt;&gt; __pow__(my_complex_pow, 1)\n(2+0j)\n&gt;&gt;&gt; __pow__(my_complex_pow, 1, None)\n(2+0j)\n&gt;&gt;&gt; __pow__(my_complex_pow, 1, 1)  # type: ignore [operator]  # properly caught by Mypy\nTraceback (most recent call last):\n  ...\nValueError: complex modulo\n\n&gt;&gt;&gt; my_complex_pow = 1.2\n&gt;&gt;&gt; __pow__(my_complex_pow, 1)\n1.2\n&gt;&gt;&gt; __pow__(my_complex_pow, 1, None)\n1.2\n&gt;&gt;&gt; __pow__(my_complex_pow, 1, 1)  # ugh; *not* caught by Mypy because it treats floats as equivalent to ints?\nTraceback (most recent call last):\n  ...\nTypeError: pow() 3rd argument not allowed unless all arguments are integers\n&gt;&gt;&gt; from fractions import Fraction\n\n&gt;&gt;&gt; my_complex_pow = Fraction(1, 2)\n&gt;&gt;&gt; __pow__(my_complex_pow, 1)\nFraction(1, 2)\n&gt;&gt;&gt; __pow__(my_complex_pow, 1, None)\nFraction(1, 2)\n&gt;&gt;&gt; __pow__(my_complex_pow, 1, 1)  # type: ignore [operator]  # properly caught by Mypy\nTraceback (most recent call last):\n  ...\nTypeError: __pow__() takes 2 positional arguments but 3 were given\n\n&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt; my_integral_pow: SupportsIntegralPow = Decimal(\"2\")\n&gt;&gt;&gt; __pow__(my_integral_pow, 1)\nDecimal('2')\n&gt;&gt;&gt; __pow__(my_integral_pow, 1, None)\nDecimal('2')\n&gt;&gt;&gt; __pow__(my_integral_pow, 1, 2)\nDecimal('0')\n\n&gt;&gt;&gt; my_integral_pow = Decimal(\"1.2\")  # ruh-roh\n&gt;&gt;&gt; __pow__(my_integral_pow, 1)\nDecimal('1.2')\n&gt;&gt;&gt; __pow__(my_integral_pow, 1, None)\nDecimal('1.2')\n&gt;&gt;&gt; __pow__(my_integral_pow, 1, 2)  # not catchable by Mypy, since it works *some* of the time\nTraceback (most recent call last):\n  ...\ndecimal.InvalidOperation: [&lt;class 'decimal.InvalidOperation'&gt;]\n\n&gt;&gt;&gt; my_integral_pow = 2\n&gt;&gt;&gt; __pow__(my_integral_pow, 1)\n2\n&gt;&gt;&gt; __pow__(my_integral_pow, 1, None)\n2\n&gt;&gt;&gt; __pow__(my_integral_pow, 1, 2)\n0\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@beartype\ndef __pow__(\n    arg: Union[SupportsComplexPow, SupportsIntegralPow],\n    exponent: Any,\n    modulus: Optional[Any] = None,\n) -&gt; Any:\nr\"\"\"\n    Helper function that wraps ``pow`` to work with\n    [``SupportsComplexPow``][numerary.types.SupportsComplexPow],\n    [``SupportsIntegralPow``][numerary.types.SupportsIntegralPow].\n\n    ``` python\n    &gt;&gt;&gt; from numerary.types import SupportsComplexPow, SupportsIntegralPow, __pow__\n    &gt;&gt;&gt; my_complex_pow: SupportsComplexPow = complex(2)\n    &gt;&gt;&gt; __pow__(my_complex_pow, 1)\n    (2+0j)\n    &gt;&gt;&gt; __pow__(my_complex_pow, 1, None)\n    (2+0j)\n    &gt;&gt;&gt; __pow__(my_complex_pow, 1, 1)  # type: ignore [operator]  # properly caught by Mypy\n    Traceback (most recent call last):\n      ...\n    ValueError: complex modulo\n\n    &gt;&gt;&gt; my_complex_pow = 1.2\n    &gt;&gt;&gt; __pow__(my_complex_pow, 1)\n    1.2\n    &gt;&gt;&gt; __pow__(my_complex_pow, 1, None)\n    1.2\n    &gt;&gt;&gt; __pow__(my_complex_pow, 1, 1)  # ugh; *not* caught by Mypy because it treats floats as equivalent to ints?\n    Traceback (most recent call last):\n      ...\n    TypeError: pow() 3rd argument not allowed unless all arguments are integers\n    &gt;&gt;&gt; from fractions import Fraction\n\n    &gt;&gt;&gt; my_complex_pow = Fraction(1, 2)\n    &gt;&gt;&gt; __pow__(my_complex_pow, 1)\n    Fraction(1, 2)\n    &gt;&gt;&gt; __pow__(my_complex_pow, 1, None)\n    Fraction(1, 2)\n    &gt;&gt;&gt; __pow__(my_complex_pow, 1, 1)  # type: ignore [operator]  # properly caught by Mypy\n    Traceback (most recent call last):\n      ...\n    TypeError: __pow__() takes 2 positional arguments but 3 were given\n\n    &gt;&gt;&gt; from decimal import Decimal\n    &gt;&gt;&gt; my_integral_pow: SupportsIntegralPow = Decimal(\"2\")\n    &gt;&gt;&gt; __pow__(my_integral_pow, 1)\n    Decimal('2')\n    &gt;&gt;&gt; __pow__(my_integral_pow, 1, None)\n    Decimal('2')\n    &gt;&gt;&gt; __pow__(my_integral_pow, 1, 2)\n    Decimal('0')\n\n    &gt;&gt;&gt; my_integral_pow = Decimal(\"1.2\")  # ruh-roh\n    &gt;&gt;&gt; __pow__(my_integral_pow, 1)\n    Decimal('1.2')\n    &gt;&gt;&gt; __pow__(my_integral_pow, 1, None)\n    Decimal('1.2')\n    &gt;&gt;&gt; __pow__(my_integral_pow, 1, 2)  # not catchable by Mypy, since it works *some* of the time\n    Traceback (most recent call last):\n      ...\n    decimal.InvalidOperation: [&lt;class 'decimal.InvalidOperation'&gt;]\n\n    &gt;&gt;&gt; my_integral_pow = 2\n    &gt;&gt;&gt; __pow__(my_integral_pow, 1)\n    2\n    &gt;&gt;&gt; __pow__(my_integral_pow, 1, None)\n    2\n    &gt;&gt;&gt; __pow__(my_integral_pow, 1, 2)\n    0\n\n    ```\n    \"\"\"\n    return pow(arg, exponent, modulus)\n</code></pre>"},{"location":"numerary.types/#numerary.types.__trunc__","title":"<code>__trunc__(operand: Union[SupportsFloat, SupportsTrunc])</code>","text":"<p>Helper function that wraps <code>math.trunc</code>.</p> <pre><code>&gt;&gt;&gt; from numerary.types import SupportsFloat, SupportsTrunc, __trunc__\n&gt;&gt;&gt; my_trunc: SupportsTrunc\n&gt;&gt;&gt; my_trunc = 1\n&gt;&gt;&gt; __trunc__(my_trunc)\n1\n&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; my_trunc = Fraction(1, 2)\n&gt;&gt;&gt; __trunc__(my_trunc)\n0\n&gt;&gt;&gt; my_trunc_float: SupportsFloat = 1.2\n&gt;&gt;&gt; __trunc__(my_trunc_float)\n1\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@beartype\ndef __trunc__(operand: Union[SupportsFloat, SupportsTrunc]):\nr\"\"\"\n    Helper function that wraps ``math.trunc``.\n\n    ``` python\n    &gt;&gt;&gt; from numerary.types import SupportsFloat, SupportsTrunc, __trunc__\n    &gt;&gt;&gt; my_trunc: SupportsTrunc\n    &gt;&gt;&gt; my_trunc = 1\n    &gt;&gt;&gt; __trunc__(my_trunc)\n    1\n    &gt;&gt;&gt; from fractions import Fraction\n    &gt;&gt;&gt; my_trunc = Fraction(1, 2)\n    &gt;&gt;&gt; __trunc__(my_trunc)\n    0\n    &gt;&gt;&gt; my_trunc_float: SupportsFloat = 1.2\n    &gt;&gt;&gt; __trunc__(my_trunc_float)\n    1\n\n    ```\n    \"\"\"\n    return math.trunc(operand)  # type: ignore [arg-type]\n</code></pre>"},{"location":"numerary.types/#numerary.types.__floor__","title":"<code>__floor__(operand: Union[SupportsFloat, SupportsFloorCeil])</code>","text":"<p>Helper function that wraps <code>math.floor</code>.</p> <pre><code>&gt;&gt;&gt; from numerary.types import SupportsFloat, SupportsFloorCeil, __floor__\n&gt;&gt;&gt; my_floor: SupportsFloorCeil\n&gt;&gt;&gt; my_floor = 1\n&gt;&gt;&gt; __floor__(my_floor)\n1\n&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; my_floor = Fraction(1, 2)\n&gt;&gt;&gt; __floor__(my_floor)\n0\n&gt;&gt;&gt; my_floor_float: SupportsFloat = 1.2\n&gt;&gt;&gt; __floor__(my_floor_float)\n1\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@beartype\ndef __floor__(operand: Union[SupportsFloat, SupportsFloorCeil]):\nr\"\"\"\n    Helper function that wraps ``math.floor``.\n\n    ``` python\n    &gt;&gt;&gt; from numerary.types import SupportsFloat, SupportsFloorCeil, __floor__\n    &gt;&gt;&gt; my_floor: SupportsFloorCeil\n    &gt;&gt;&gt; my_floor = 1\n    &gt;&gt;&gt; __floor__(my_floor)\n    1\n    &gt;&gt;&gt; from fractions import Fraction\n    &gt;&gt;&gt; my_floor = Fraction(1, 2)\n    &gt;&gt;&gt; __floor__(my_floor)\n    0\n    &gt;&gt;&gt; my_floor_float: SupportsFloat = 1.2\n    &gt;&gt;&gt; __floor__(my_floor_float)\n    1\n\n    ```\n    \"\"\"\n    return math.floor(operand)\n</code></pre>"},{"location":"numerary.types/#numerary.types.__ceil__","title":"<code>__ceil__(operand: Union[SupportsFloat, SupportsFloorCeil])</code>","text":"<p>Helper function that wraps <code>math.ceil</code>.</p> <pre><code>&gt;&gt;&gt; from numerary.types import SupportsFloat, SupportsFloorCeil, __ceil__\n&gt;&gt;&gt; my_ceil: SupportsFloorCeil\n&gt;&gt;&gt; my_ceil = 1\n&gt;&gt;&gt; __ceil__(my_ceil)\n1\n&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; my_ceil = Fraction(1, 2)\n&gt;&gt;&gt; __ceil__(my_ceil)\n1\n&gt;&gt;&gt; my_ceil_float: SupportsFloat = 1.2\n&gt;&gt;&gt; __ceil__(my_ceil_float)\n2\n</code></pre> Source code in <code>numerary/types.py</code> <pre><code>@beartype\ndef __ceil__(operand: Union[SupportsFloat, SupportsFloorCeil]):\nr\"\"\"\n    Helper function that wraps ``math.ceil``.\n\n    ``` python\n    &gt;&gt;&gt; from numerary.types import SupportsFloat, SupportsFloorCeil, __ceil__\n    &gt;&gt;&gt; my_ceil: SupportsFloorCeil\n    &gt;&gt;&gt; my_ceil = 1\n    &gt;&gt;&gt; __ceil__(my_ceil)\n    1\n    &gt;&gt;&gt; from fractions import Fraction\n    &gt;&gt;&gt; my_ceil = Fraction(1, 2)\n    &gt;&gt;&gt; __ceil__(my_ceil)\n    1\n    &gt;&gt;&gt; my_ceil_float: SupportsFloat = 1.2\n    &gt;&gt;&gt; __ceil__(my_ceil_float)\n    2\n\n    ```\n    \"\"\"\n    return math.ceil(operand)\n</code></pre>"},{"location":"numerary.types/#numerary.types.numerator","title":"<code>numerator(operand: SupportsNumeratorDenominatorMixedU)</code>","text":"<p>Helper function that extracts the numerator from operand including resolving non-compliant rational implementations that implement <code>numerator</code> as a method rather than a property.</p> <pre><code>&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; from numerary.types import numerator\n&gt;&gt;&gt; numerator(Fraction(22, 7))\n22\n</code></pre> <p>See SupportsNumeratorDenominator and SupportsNumeratorDenominatorMethods.</p> Source code in <code>numerary/types.py</code> <pre><code>@beartype\ndef numerator(operand: SupportsNumeratorDenominatorMixedU):\nr\"\"\"\n    Helper function that extracts the numerator from *operand* including resolving\n    non-compliant rational implementations that implement ``numerator`` as a method\n    rather than a property.\n\n    ``` python\n    &gt;&gt;&gt; from fractions import Fraction\n    &gt;&gt;&gt; from numerary.types import numerator\n    &gt;&gt;&gt; numerator(Fraction(22, 7))\n    22\n\n    ```\n\n    See\n    [SupportsNumeratorDenominator][numerary.types.SupportsNumeratorDenominator]\n    and\n    [SupportsNumeratorDenominatorMethods][numerary.types.SupportsNumeratorDenominatorMethods].\n    \"\"\"\n    if hasattr(operand, \"numerator\"):\n        if callable(operand.numerator):\n            return operand.numerator()\n        else:\n            return operand.numerator\n    else:\n        raise TypeError(f\"{operand!r} has no numerator\")\n</code></pre>"},{"location":"numerary.types/#numerary.types.denominator","title":"<code>denominator(operand: SupportsNumeratorDenominatorMixedU)</code>","text":"<p>Helper function that extracts the denominator from operand including resolving non-compliant rational implementations that implement <code>denominator</code> as a method rather than a property.</p> <pre><code>&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; from numerary.types import denominator\n&gt;&gt;&gt; denominator(Fraction(22, 7))\n7\n</code></pre> <p>See SupportsNumeratorDenominator and SupportsNumeratorDenominatorMethods.</p> Source code in <code>numerary/types.py</code> <pre><code>@beartype\ndef denominator(operand: SupportsNumeratorDenominatorMixedU):\nr\"\"\"\n    Helper function that extracts the denominator from *operand* including resolving\n    non-compliant rational implementations that implement ``denominator`` as a method\n    rather than a property.\n\n    ``` python\n    &gt;&gt;&gt; from fractions import Fraction\n    &gt;&gt;&gt; from numerary.types import denominator\n    &gt;&gt;&gt; denominator(Fraction(22, 7))\n    7\n\n    ```\n\n    See\n    [SupportsNumeratorDenominator][numerary.types.SupportsNumeratorDenominator]\n    and\n    [SupportsNumeratorDenominatorMethods][numerary.types.SupportsNumeratorDenominatorMethods].\n    \"\"\"\n    if hasattr(operand, \"denominator\"):\n        if callable(operand.denominator):\n            return operand.denominator()\n        else:\n            return operand.denominator\n    else:\n        raise TypeError(f\"{operand!r} has no denominator\")\n</code></pre>"},{"location":"numerary.types/#numerary.types.RationalLikeMixedT","title":"<code>RationalLikeMixedT = (RationalLike, RationalLikeMethods)</code>  <code>module-attribute</code>","text":""},{"location":"numerary.types/#numerary.types.RationalLikeMixedU","title":"<code>RationalLikeMixedU = Union[RationalLike, RationalLikeMethods]</code>  <code>module-attribute</code>","text":""},{"location":"numerary.types/#numerary.types.SupportsRealImagMixedT","title":"<code>SupportsRealImagMixedT = (SupportsRealImag, SupportsRealImagAsMethod)</code>  <code>module-attribute</code>","text":""},{"location":"numerary.types/#numerary.types.SupportsRealImagMixedU","title":"<code>SupportsRealImagMixedU = Union[SupportsRealImag, SupportsRealImagAsMethod]</code>  <code>module-attribute</code>","text":""},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMixedT","title":"<code>SupportsNumeratorDenominatorMixedT = (SupportsNumeratorDenominator, SupportsNumeratorDenominatorMethods)</code>  <code>module-attribute</code>","text":""},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMixedU","title":"<code>SupportsNumeratorDenominatorMixedU = Union[SupportsNumeratorDenominator, SupportsNumeratorDenominatorMethods]</code>  <code>module-attribute</code>","text":""},{"location":"numerary.types/#numerary.types._SupportsConjugate","title":"<code>_SupportsConjugate</code>","text":"<p>             Bases: <code>_Protocol</code></p> <p>The non-caching version of <code>SupportsConjugate</code>.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass _SupportsConjugate(_Protocol):\nr\"\"\"\n    The non-caching version of\n    [``SupportsConjugate``][numerary.types.SupportsConjugate].\n    \"\"\"\n\n    @abstractmethod\n    def conjugate(self) -&gt; Any:\n        pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsConjugate.conjugate","title":"<code>conjugate() -&gt; Any</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef conjugate(self) -&gt; Any:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsRealImag","title":"<code>_SupportsRealImag</code>","text":"<p>             Bases: <code>_Protocol</code></p> <p>The non-caching version of <code>SupportsRealImag</code>.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass _SupportsRealImag(_Protocol):\nr\"\"\"\n    The non-caching version of [``SupportsRealImag``][numerary.types.SupportsRealImag].\n    \"\"\"\n\n    @abstractproperty\n    def real(self) -&gt; Any:\n        pass\n\n    @abstractproperty\n    def imag(self) -&gt; Any:\n        pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsRealImag.imag","title":"<code>imag() -&gt; Any</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractproperty\ndef imag(self) -&gt; Any:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsRealImag.real","title":"<code>real() -&gt; Any</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractproperty\ndef real(self) -&gt; Any:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsRealImagAsMethod","title":"<code>_SupportsRealImagAsMethod</code>","text":"<p>             Bases: <code>_Protocol</code></p> <p>The non-caching version of <code>SupportsRealImagAsMethod</code>.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass _SupportsRealImagAsMethod(_Protocol):\nr\"\"\"\n    The non-caching version of\n    [``SupportsRealImagAsMethod``][numerary.types.SupportsRealImagAsMethod].\n    \"\"\"\n\n    @abstractmethod\n    def as_real_imag(self) -&gt; Tuple[Any, Any]:\n        pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsRealImagAsMethod.as_real_imag","title":"<code>as_real_imag() -&gt; Tuple[Any, Any]</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef as_real_imag(self) -&gt; Tuple[Any, Any]:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsTrunc","title":"<code>_SupportsTrunc</code>","text":"<p>             Bases: <code>_Protocol</code></p> <p>The non-caching version of <code>SupportsTrunc</code>.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass _SupportsTrunc(_Protocol):\nr\"\"\"\n    The non-caching version of [``SupportsTrunc``][numerary.types.SupportsTrunc].\n    \"\"\"\n\n    @abstractmethod\n    def __trunc__(self) -&gt; int:\n        pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsTrunc.__trunc__","title":"<code>__trunc__() -&gt; int</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __trunc__(self) -&gt; int:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsFloorCeil","title":"<code>_SupportsFloorCeil</code>","text":"<p>             Bases: <code>_Protocol</code></p> <p>The non-caching version of <code>SupportsFloorCeil</code>.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass _SupportsFloorCeil(_Protocol):\nr\"\"\"\n    The non-caching version of\n    [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil].\n    \"\"\"\n\n    @abstractmethod\n    def __floor__(self) -&gt; int:\n        pass\n\n    @abstractmethod\n    def __ceil__(self) -&gt; int:\n        pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsFloorCeil.__ceil__","title":"<code>__ceil__() -&gt; int</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __ceil__(self) -&gt; int:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsFloorCeil.__floor__","title":"<code>__floor__() -&gt; int</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __floor__(self) -&gt; int:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsDivmod","title":"<code>_SupportsDivmod</code>","text":"<p>             Bases: <code>_Protocol</code>, <code>Generic[_T_co]</code></p> <p>The non-caching version of <code>SupportsDivmod</code>.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass _SupportsDivmod(\n    _Protocol,\n    Generic[_T_co],\n):\nr\"\"\"\n    The non-caching version of [``SupportsDivmod``][numerary.types.SupportsDivmod].\n    \"\"\"\n\n    @abstractmethod\n    def __divmod__(self, other: Any) -&gt; Tuple[_T_co, _T_co]:\n        pass\n\n    @abstractmethod\n    def __rdivmod__(self, other: Any) -&gt; Tuple[_T_co, _T_co]:\n        pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsDivmod.__divmod__","title":"<code>__divmod__(other: Any) -&gt; Tuple[_T_co, _T_co]</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __divmod__(self, other: Any) -&gt; Tuple[_T_co, _T_co]:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsDivmod.__rdivmod__","title":"<code>__rdivmod__(other: Any) -&gt; Tuple[_T_co, _T_co]</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __rdivmod__(self, other: Any) -&gt; Tuple[_T_co, _T_co]:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominator","title":"<code>_SupportsNumeratorDenominator</code>","text":"<p>             Bases: <code>_Protocol</code></p> <p>The non-caching version of <code>SupportsNumeratorDenominator</code>.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass _SupportsNumeratorDenominator(_Protocol):\nr\"\"\"\n    The non-caching version of\n    [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator].\n    \"\"\"\n\n    @abstractproperty\n    def numerator(self) -&gt; int:\n        pass\n\n    @abstractproperty\n    def denominator(self) -&gt; int:\n        pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominator.denominator","title":"<code>denominator() -&gt; int</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractproperty\ndef denominator(self) -&gt; int:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominator.numerator","title":"<code>numerator() -&gt; int</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractproperty\ndef numerator(self) -&gt; int:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods","title":"<code>_SupportsNumeratorDenominatorMethods</code>","text":"<p>             Bases: <code>_Protocol</code></p> <p>The non-caching version of <code>SupportsNumeratorDenominatorMethods</code>.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass _SupportsNumeratorDenominatorMethods(_Protocol):\nr\"\"\"\n    The non-caching version of\n    [``SupportsNumeratorDenominatorMethods``][numerary.types.SupportsNumeratorDenominatorMethods].\n    \"\"\"\n\n    @abstractmethod\n    def numerator(self) -&gt; SupportsInt:\n        pass\n\n    @abstractmethod\n    def denominator(self) -&gt; SupportsInt:\n        pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods.denominator","title":"<code>denominator() -&gt; SupportsInt</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef denominator(self) -&gt; SupportsInt:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods.numerator","title":"<code>numerator() -&gt; SupportsInt</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef numerator(self) -&gt; SupportsInt:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsComplexOps","title":"<code>_SupportsComplexOps</code>","text":"<p>             Bases: <code>_Protocol</code>, <code>Generic[_T_co]</code></p> <p>The non-caching version of <code>SupportsComplexOps</code>.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass _SupportsComplexOps(\n    _Protocol,\n    Generic[_T_co],\n):\nr\"\"\"\n    The non-caching version of\n    [``SupportsComplexOps``][numerary.types.SupportsComplexOps].\n    \"\"\"\n\n    @abstractmethod\n    def __add__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __radd__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __sub__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __rsub__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __mul__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __rmul__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __truediv__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __rtruediv__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __neg__(self) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __pos__(self) -&gt; _T_co:\n        pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__add__","title":"<code>__add__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __add__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__mul__","title":"<code>__mul__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __mul__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__neg__","title":"<code>__neg__() -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __neg__(self) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__pos__","title":"<code>__pos__() -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __pos__(self) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__radd__","title":"<code>__radd__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __radd__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__rmul__","title":"<code>__rmul__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __rmul__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__rsub__","title":"<code>__rsub__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __rsub__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__rtruediv__","title":"<code>__rtruediv__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __rtruediv__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__sub__","title":"<code>__sub__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __sub__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__truediv__","title":"<code>__truediv__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __truediv__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsComplexPow","title":"<code>_SupportsComplexPow</code>","text":"<p>             Bases: <code>_Protocol</code></p> <p>The non-caching version of <code>SupportsComplexPow</code>.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass _SupportsComplexPow(_Protocol):\nr\"\"\"\n    The non-caching version of\n    [``SupportsComplexPow``][numerary.types.SupportsComplexPow].\n    \"\"\"\n\n    @abstractmethod\n    def __pow__(self, exponent: Any) -&gt; Any:\n        pass\n\n    @abstractmethod\n    def __rpow__(self, exponent: Any) -&gt; Any:\n        pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsComplexPow.__pow__","title":"<code>__pow__(exponent: Any) -&gt; Any</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __pow__(self, exponent: Any) -&gt; Any:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsComplexPow.__rpow__","title":"<code>__rpow__(exponent: Any) -&gt; Any</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __rpow__(self, exponent: Any) -&gt; Any:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsRealOps","title":"<code>_SupportsRealOps</code>","text":"<p>             Bases: <code>_Protocol</code>, <code>Generic[_T_co]</code></p> <p>The non-caching version of <code>SupportsRealOps</code>.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass _SupportsRealOps(\n    _Protocol,\n    Generic[_T_co],\n):\nr\"\"\"\n    The non-caching version of [``SupportsRealOps``][numerary.types.SupportsRealOps].\n    \"\"\"\n\n    @abstractmethod\n    def __lt__(self, other: Any) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def __le__(self, other: Any) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def __ge__(self, other: Any) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def __gt__(self, other: Any) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def __floordiv__(self, other: Any) -&gt; Any:  # TODO(posita): should be int\n        pass\n\n    @abstractmethod\n    def __rfloordiv__(self, other: Any) -&gt; Any:  # TODO(posita): should be int\n        pass\n\n    @abstractmethod\n    def __mod__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __rmod__(self, other: Any) -&gt; _T_co:\n        pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__floordiv__","title":"<code>__floordiv__(other: Any) -&gt; Any</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __floordiv__(self, other: Any) -&gt; Any:  # TODO(posita): should be int\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__ge__","title":"<code>__ge__(other: Any) -&gt; bool</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __ge__(self, other: Any) -&gt; bool:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__gt__","title":"<code>__gt__(other: Any) -&gt; bool</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __gt__(self, other: Any) -&gt; bool:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__le__","title":"<code>__le__(other: Any) -&gt; bool</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __le__(self, other: Any) -&gt; bool:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__lt__","title":"<code>__lt__(other: Any) -&gt; bool</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __lt__(self, other: Any) -&gt; bool:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__mod__","title":"<code>__mod__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __mod__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__rfloordiv__","title":"<code>__rfloordiv__(other: Any) -&gt; Any</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __rfloordiv__(self, other: Any) -&gt; Any:  # TODO(posita): should be int\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__rmod__","title":"<code>__rmod__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __rmod__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps","title":"<code>_SupportsIntegralOps</code>","text":"<p>             Bases: <code>_Protocol</code>, <code>Generic[_T_co]</code></p> <p>The non-caching version of <code>SupportsIntegralOps</code>.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass _SupportsIntegralOps(\n    _Protocol,\n    Generic[_T_co],\n):\nr\"\"\"\n    The non-caching version of\n    [``SupportsIntegralOps``][numerary.types.SupportsIntegralOps].\n    \"\"\"\n\n    @abstractmethod\n    def __lshift__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __rlshift__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __rshift__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __rrshift__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __and__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __rand__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __xor__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __rxor__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __or__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __ror__(self, other: Any) -&gt; _T_co:\n        pass\n\n    @abstractmethod\n    def __invert__(self) -&gt; _T_co:\n        pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__and__","title":"<code>__and__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __and__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__invert__","title":"<code>__invert__() -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __invert__(self) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__lshift__","title":"<code>__lshift__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __lshift__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__or__","title":"<code>__or__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __or__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rand__","title":"<code>__rand__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __rand__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rlshift__","title":"<code>__rlshift__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __rlshift__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__ror__","title":"<code>__ror__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __ror__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rrshift__","title":"<code>__rrshift__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __rrshift__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rshift__","title":"<code>__rshift__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __rshift__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rxor__","title":"<code>__rxor__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __rxor__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__xor__","title":"<code>__xor__(other: Any) -&gt; _T_co</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __xor__(self, other: Any) -&gt; _T_co:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow","title":"<code>_SupportsIntegralPow</code>","text":"<p>             Bases: <code>_Protocol</code></p> <p>The non-caching version of <code>SupportsIntegralPow</code>.</p> Source code in <code>numerary/types.py</code> <pre><code>@runtime_checkable\nclass _SupportsIntegralPow(_Protocol):\nr\"\"\"\n    The non-caching version of\n    [``SupportsIntegralPow``][numerary.types.SupportsIntegralPow].\n    \"\"\"\n\n    @abstractmethod\n    def __pow__(self, exponent: Any, modulus: Optional[Any] = None) -&gt; Any:\n        pass\n\n    @abstractmethod\n    def __rpow__(self, exponent: Any, modulus: Optional[Any] = None) -&gt; Any:\n        pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow.__pow__","title":"<code>__pow__(exponent: Any, modulus: Optional[Any] = None) -&gt; Any</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __pow__(self, exponent: Any, modulus: Optional[Any] = None) -&gt; Any:\n    pass\n</code></pre>"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow.__rpow__","title":"<code>__rpow__(exponent: Any, modulus: Optional[Any] = None) -&gt; Any</code>  <code>abstractmethod</code>","text":"Source code in <code>numerary/types.py</code> <pre><code>@abstractmethod\ndef __rpow__(self, exponent: Any, modulus: Optional[Any] = None) -&gt; Any:\n    pass\n</code></pre>"},{"location":"whytho/","title":"Why would you do this?","text":"<p>This story may feel familiar. If it does, you are in good company. Your pain is my pain. May it motivate us to grow and adapt.</p>"},{"location":"whytho/#the-calculation-functionan-allegory","title":"The calculation function\u2014An allegory","text":"<p>We have a simple vision. We want to define an API that works with reals (not just <code>float</code>s), performs a calculation, and returns integers (not just <code>int</code>s).</p> <pre><code>&gt;&gt;&gt; def deep_thought(arg):\n...   from time import sleep\n...   sleep(7_500_000 * 365.24219265 * 24 * 60 * 60)  # doctest: +SKIP\n...   assert arg != 0 and arg ** 0 == 1\n...   return 42\n</code></pre>"},{"location":"whytho/#native-primitives","title":"Native primitives","text":"<p>We want to tell the world how to call it and what to expect in return, so we annotate it according to the standard advice to just use native types:</p> <pre><code>&gt;&gt;&gt; def deep_thought_typed(arg: float) -&gt; int:\n...   assert arg != 0 and arg ** 0 == 1\n...   return 42\n</code></pre> <p>So simple! We\u2019re done, right? Not quite. We find that the runtime works well, but there are Mypy errors.</p> <pre><code>&gt;&gt;&gt; deep_thought_typed(1.0)  # this is fine ...\n42\n&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; deep_thought_typed(Fraction(1, 2))  # type: ignore [arg-type]  # ... but this fails\n42\n</code></pre> <p>Without the <code># type: ignore</code>, we get:</p> <pre><code>\u2026: error: Argument 1 to \"deep_thought_typed\" has incompatible type \"Fraction\"; expected \"float\"\n</code></pre>"},{"location":"whytho/#numeric-tower","title":"Numeric tower","text":"<p>With a little research, we learn about the numeric tower [cue angelic singing]. Surely, it has the answer! Both <code>float</code> and <code>Fraction</code> are <code>Real</code>s. Let\u2019s test that to make sure.</p> <pre><code>&gt;&gt;&gt; from numbers import Integral, Real\n&gt;&gt;&gt; isinstance(42, Integral)\nTrue\n&gt;&gt;&gt; isinstance(1.0, Real)\nTrue\n&gt;&gt;&gt; isinstance(Fraction(1, 2), Real)\nTrue\n</code></pre> <p>Huzzah! What could be simpler? It appears a small tweak is all that is required!</p> <pre><code>&gt;&gt;&gt; def deep_thought_towered(arg: Real) -&gt; Integral:\n...   assert arg != 0 and arg ** 0 == 1\n...   return 42  # type: ignore [return-value]  # now this fails\n</code></pre> <p>Without the <code># type: ignore</code>, we get:</p> <pre><code>\u2026: error: Incompatible return value type (got \"int\", expected \"Integral\")\n</code></pre> <p>Hold the phone. <code>isinstance(42, Integral)</code> was <code>True</code>, was it not? This is starting to get confusing.</p>"},{"location":"whytho/#erm-we-mean-native-primitives-or-the-numeric-tower","title":"Erm \u2026 we mean native primitives or the numeric tower?","text":"<pre><code>&gt;&gt;&gt; from typing import Union\n&gt;&gt;&gt; IntegralT = Union[int, Integral]\n&gt;&gt;&gt; RealT = Union[float, Real]\n\n&gt;&gt;&gt; def deep_thought_crumbling(arg: RealT) -&gt; IntegralT:\n...   assert arg != 0 and arg ** 0 == 1\n...   return 42\n</code></pre> <p>Well, that was odd, but such warts are a small price to pay. All is right in the world again!</p> <pre><code>&gt;&gt;&gt; deep_thought_crumbling(1.0)\n42\n&gt;&gt;&gt; deep_thought_crumbling(Fraction(1, 2))\n42\n&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt; deep_thought_crumbling(Decimal(\"0.123\"))  # type: ignore [arg-type]  # fail\n42\n</code></pre> <p>Without the <code># type: ignore</code>, we get:</p> <pre><code>\u2026: error: Argument 1 to \"deep_thought_crumbling\" has incompatible type \"Decimal\"; expected \"Union[float, Real]\"\n</code></pre> <p>Oh, come on!</p>"},{"location":"whytho/#native-primitives-the-numeric-tower-or-other-things-that-define-all-the-methods-but-didnt-or-couldnt-register-in-the-numeric-tower-for-some-reason","title":"Native primitives, the numeric tower, or other things that define all the methods, but didn\u2019t (or couldn\u2019t) register in the numeric tower for some reason","text":"<p>\ud83e\udd2c me. Do we just tack this onto the list?</p> <pre><code>&gt;&gt;&gt; RealAndDecimalT = Union[float, Real, Decimal]\n\n&gt;&gt;&gt; def deep_thought_toppled(arg: RealAndDecimalT) -&gt; IntegralT:\n...   assert arg != 0 and arg ** 0 == 1\n...   return 42\n&gt;&gt;&gt; deep_thought_toppled(Decimal(\"0.123\"))\n42\n</code></pre> <p>If we have to engage in these kinds of gymnastics just to reach escape velocity from the standard library, how the heck are we supposed to survive contact with numeric implementations we haven\u2019t even heard of yet?! We can\u2019t enumerate them all!</p> <p>For many years, the numeric tower was declared a \u201cdead end\u201d by maintainers. Unsurprisingly, many longstanding library authors didn\u2019t see much benefit to conforming to its API. Adoption has grown, but we can\u2019t rely on it.</p> <p>What should we rely on, then? Surely the exalted few who have steered us away from one thing are prepared to steer us toward something else, no? Sadly, the apparent attitude of many seems to be, \u201cSomething, something, protocols? Meh. I don\u2019t know. We\u2019ll figure it out later.\u201d</p>"},{"location":"whytho/#protocols","title":"Protocols!","text":"<p>Can we fix this with protocols? The standard library picked the low hanging fruit provides some simple precedents. Can we imitate those?</p> <pre><code>&gt;&gt;&gt; from typing import Protocol, runtime_checkable\n\n&gt;&gt;&gt; @runtime_checkable\n... class SupportsNumeratorDenominator(Protocol):\n...   @property\n...   def numerator(self) -&gt; int:\n...     pass\n...   @property\n...   def denominator(self) -&gt; int:\n...     pass\n\n&gt;&gt;&gt; def require_rational(arg: SupportsNumeratorDenominator) -&gt; None:\n...   assert isinstance(arg, SupportsNumeratorDenominator)\n\n&gt;&gt;&gt; require_rational(1)  # yup\n&gt;&gt;&gt; require_rational(Fraction(1, 2))  # nice\n&gt;&gt;&gt; require_rational(1.0)  # type: ignore [arg-type]  # floats don't have numerator/denominator properties\nTraceback (most recent call last):\n  ...\nAssertionError\n</code></pre> <p>Without the <code># type: ignore</code>, we get:</p> <pre><code>\u2026: error: Argument 1 to \"require_rational\" has incompatible type \"float\"; expected \"SupportsNumeratorDenominator\"\n\u2026: note: \"float\" is missing following \"SupportsNumeratorDenominator\" protocol members:\n\u2026: note:     denominator, numerator\n</code></pre> <p>Oh. My. Godetia. Could this be it? Have we stumbled into the promised land?</p>"},{"location":"whytho/#puh-roh-tih-caaahhhlllz","title":"Puh \u2026 ROH \u2026 tih \u2026 caaahhhlllz \u2026 !","text":"<p>Let\u2019s see how they perform. First, let\u2019s get a baseline.</p> <pre><code>%timeit isinstance(1, Rational)\n115 ns \u00b1 1.26 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n%timeit isinstance(Fraction(2, 1), Rational)\n119 ns \u00b1 0.366 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n%timeit isinstance(3.0, Rational)\n126 ns \u00b1 0.499 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n</code></pre> Source: <code>perf_rational_baseline.ipy</code> <pre><code>from fractions import Fraction\nfrom numbers import Rational\n\none_int = 1\ntwo_frac = Fraction(2)\nthree_float = 3.0\nvals = (one_int, two_frac, three_float)\n\nfor v in vals:\n  print(f\"%timeit isinstance({v!r}, Rational)\")\n  %timeit isinstance(v, Rational)\n</code></pre> <p>Now let\u2019s compare that with our two-property protocol.</p> <pre><code>%timeit isinstance(1, SupportsNumeratorDenominator)\n4.71 \u00b5s \u00b1 34.4 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n%timeit isinstance(Fraction(2, 1), SupportsNumeratorDenominator)\n5.01 \u00b5s \u00b1 36.9 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n%timeit isinstance(3.0, SupportsNumeratorDenominator)\n4.89 \u00b5s \u00b1 52.7 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n</code></pre> Source: <code>perf_rational_protocol.ipy</code> <pre><code>from fractions import Fraction\nfrom numbers import Rational\nfrom typing import Any, Protocol, runtime_checkable\n\none_int = 1\ntwo_frac = Fraction(2)\nthree_float = 3.0\nvals = (one_int, two_frac, three_float)\n\n@runtime_checkable\nclass SupportsNumeratorDenominator(Protocol):\n  __slots__: Any = ()\n  @property\n  def numerator(self) -&gt; int:\n    pass\n  @property\n  def denominator(self) -&gt; int:\n    pass\n\nfor v in vals:\n  print(f\"%timeit isinstance({v!r}, SupportsNumeratorDenominator)\")\n  %timeit isinstance(v, SupportsNumeratorDenominator)\n</code></pre> <p>That\u2019s forty times slower. \ud83d\ude36 And that\u2019s just with a two-property protocol. How much worse would it be if we had enumerated all the dunder methods? \ud83d\ude30</p> <pre><code>%timeit isinstance(1, SupportsLotsOfNumberStuff)\n49.8 \u00b5s \u00b1 169 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n%timeit isinstance(Fraction(2, 1), SupportsLotsOfNumberStuff)\n51.2 \u00b5s \u00b1 185 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n%timeit isinstance(3.0, SupportsLotsOfNumberStuff)\n47 \u00b5s \u00b1 795 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</code></pre> Source: <code>perf_rational_big_protocol.ipy</code> <pre><code>from abc import abstractproperty\nfrom fractions import Fraction\nfrom typing import (\n  Any,\n  Protocol,\n  SupportsAbs,\n  SupportsComplex,\n  SupportsFloat,\n  SupportsRound,\n  runtime_checkable,\n)\nfrom numerary.types import (  # \"raw\" (non-caching) versions\n  _SupportsComplexOps,\n  _SupportsConjugate,\n  _SupportsDivmod,\n  _SupportsFloorCeil,\n  _SupportsRealImag,\n  _SupportsRealOps,\n  _SupportsTrunc,\n)\n\none_int = 1\ntwo_frac = Fraction(2)\nthree_float = 3.0\nvals = (one_int, two_frac, three_float)\n\n@runtime_checkable\nclass SupportsLotsOfNumberStuff(\n  _SupportsRealOps,\n  _SupportsComplexOps,\n  _SupportsDivmod,\n  _SupportsTrunc,\n  _SupportsFloorCeil,\n  _SupportsConjugate,\n  _SupportsRealImag,\n  SupportsAbs,\n  SupportsFloat,\n  SupportsComplex,\n  SupportsRound,\n  Protocol,\n):\n  __slots__: Any = ()\n  @abstractproperty\n  def numerator(self) -&gt; int:\n    pass\n  @abstractproperty\n  def denominator(self) -&gt; int:\n    pass\n\nfor v in vals:\n  print(f\"%timeit isinstance({v!r}, SupportsLotsOfNumberStuff)\")\n  %timeit isinstance(v, SupportsLotsOfNumberStuff)\n</code></pre> <p>Over. Four. Hundred. Times. Slower. And that\u2019s not even all the methods!</p> <p></p> <p>You know what? Never mind that. Where there\u2019s a will, there\u2019s a way. Note to self: Self, solve the performance problems with protocols later. But we\u2019re definitely onto something!</p>"},{"location":"whytho/#lies-upon-lies-upon-lies-all-the-way-down","title":"Lies! Upon lies! Upon lies! All the way down!","text":"<p>Let\u2019s do another one. Real numbers have comparisons that complex ones don\u2019t. That seems as good a place as any to tackle next.</p> <pre><code>&gt;&gt;&gt; try:\n...   from typing import Protocol, runtime_checkable\n... except ImportError:\n...   from typing_extensions import Protocol, runtime_checkable  # type: ignore [assignment]\n\n&gt;&gt;&gt; from abc import abstractmethod\n&gt;&gt;&gt; from typing import Any\n\n&gt;&gt;&gt; @runtime_checkable\n... class SupportsRealComparisons(Protocol):\n...   @abstractmethod\n...   def __lt__(self, other: Any) -&gt; bool:\n...     pass\n...   @abstractmethod\n...   def __le__(self, other: Any) -&gt; bool:\n...     pass\n...   @abstractmethod\n...   def __ge__(self, other: Any) -&gt; bool:\n...     pass\n...   @abstractmethod\n...   def __gt__(self, other: Any) -&gt; bool:\n...     pass\n\n&gt;&gt;&gt; def require_real(arg: SupportsRealComparisons) -&gt; None:\n...   assert isinstance(arg, SupportsRealComparisons)\n\n&gt;&gt;&gt; require_real(1)\n&gt;&gt;&gt; require_real(Fraction(1, 2))\n&gt;&gt;&gt; require_real(1.0)\n&gt;&gt;&gt; require_real(complex(0))  # type: ignore [arg-type]  # should go ka-boom!\n</code></pre> <p>Where was the ka-boom? There was supposed to be an earth-shattering ka-boom! Mypy spotted the error. Without the <code># type: ignore</code>, we get:</p> <pre><code>\u2026: error: Argument 1 to \"require_real\" has incompatible type \"complex\"; expected \"SupportsRealComparisons\"\n</code></pre> <p>So what gives? Why does our protocol think a <code>complex</code> has comparisons at runtime? It\u2019s a complex number and complex numbers don\u2019t have those. The standard library says so!</p> <pre><code>&gt;&gt;&gt; from numbers import Complex\n&gt;&gt;&gt; isinstance(complex(0), Complex)\nTrue\n&gt;&gt;&gt; hasattr(Complex, \"__le__\")\nTrue\n&gt;&gt;&gt; complex(0).__le__  # type: ignore [operator]\n&lt;...method...complex...&gt;\n</code></pre> <p>What the shit? Do they work?</p> <pre><code>&gt;&gt;&gt; complex(0) &lt;= complex(0)  # type: ignore [operator]\nTraceback (most recent call last):\n  ...\nTypeError: '&lt;=' not supported between instances of 'complex' and 'complex'\n</code></pre> <p>Wait. Complex numbers implement comparisons in complete contradiction to the documentation just to return <code>NotImplemented</code>?! \ud83e\udd2c off!</p> <p>How does Mypy know? Because the type definitions for <code>complex</code> and <code>Complex</code> are lies that conveniently omit mention of those methods.</p> <p>Quote</p> <p>\u201cWhen it becomes serious, you have to lie.\u201d</p> <p>\u2014Jean-Claude Juncker</p> <p>Do you see?! Do you see now why we can\u2019t have nice things?! I mean, I get casting as a rare case, but who builds sophisticated deception tooling into the very fabric a type definition mechanism to claim that non-compliant native primitives comply? How can you trust anything anymore?! Shouldn\u2019t that be a pretty strong hint that maybe you should step back and rethink your approach?</p> <p>Astute readers may note <code>beartype</code> could help restore Truth for us.</p> <pre><code>from beartype import beartype\nfrom beartype.vale import Is\nfrom typing import Annotated\nSupportsRealComparisonsNotComplexLies = Annotated[\n  SupportsRealComparisons, Is[lambda arg: not isinstance(arg, complex)]\n]\n\n@beartype\ndef require_real(arg: SupportsRealComparisonsNotComplexLies) -&gt; None:\n  assert isinstance(arg, SupportsRealComparisonsNotComplexLies)\n</code></pre> <p>That\u2019s because Bear is hip to the scene. Bear is down. Bear knows what\u2019s what. If you have a typing problem, if no one else can help, and if you can find them1, maybe you can hire the Bear-Team.</p> <p>I digress.</p>"},{"location":"whytho/#what-do-we-do","title":"What do we do?!","text":"<p>Okay. Can we still work with any of this shit and have type-checking? Let\u2019s try. Because somebody \ud83e\udd2cing has to.</p> <ol> <li> <p>That should be easy I just gave you the link. Twice.\u00a0\u21a9</p> </li> </ol>"}]}