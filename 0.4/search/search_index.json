{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Copyright and other protections apply. Please see the accompanying LICENSE file for rights and restrictions governing use of this software. All rights not expressly waived or licensed are reserved. If that file is missing or appears to be modified from its original, then please contact the author before viewing or using this software in any capacity. Are you defining a numeric interface that should work with more than just int s and float s? Are you annotating that interface for documentation and type-checking? Were you excited by PEP 3141 \u2019s glitz and gloss promising a clean, straightforward number type definition mechanism, only to learn the hard way\u2014after many hours of searching, tweaking, hacking, and testing ever more convoluted code, again and again\u2014that you could\u2019t actually make it work with Python\u2019s type-checking system? Do you now wonder whether numbers were something new to computing in general because nothing else would explain such a gaping hole in a programming language so popular with the STEM crowd that has been around since the early 1990s? Does the number 3186 haunt you in your dreams? Do you find yourself shouting to no one in particular, \u201cThere has to be a better way?\u201d Well I\u2019m here to tell you there isn\u2019t. But until there is, there\u2019s \u2026 numerary \u2014Now with Protocol Power\u2122 That\u2019s right! For a hopefully limited time, you too can benefit from someone else\u2019s deranged work-arounds for the enormous chasms in Python that lie between the esoteric fields of computation that are \u201ctyping\u201d and \u201cnumbers\u201d instead of having to roll your own out of sheer desperation from first principles ! If you still have no idea what I\u2019m talking about, this may help illustrate . numerary is a pure-Python codified rant for signaling that your interface is usable with non-native numeric primitives 1 without breaking type-checking. More simply, numerary aspires to a world where numbers and types can work together. If you\u2019re thinking that you shouldn\u2019t need a \ud83e\udd2cing library for that, you\u2019re right . This madness should enjoy no audience. It should not exist. Yet here we are. Its author gauges its success by how quickly it can be forgotten, relegated to the annals of superfluous folly. numerary is licensed under the MIT License . See the accompanying LICENSE file for details. It should be considered experimental for now, but should settle down quickly. See the release notes for a summary of version-to-version changes. Source code is available on GitHub . If you find it lacking in any way, please don\u2019t hesitate to bring it to my attention . You had me at, \u201cnumbers and types can work together\u201d numerary strives to define composable, efficient protocols that one can use to construct numeric requirements. If all you deal with are integrals and reals, and what you want is broad arithmetic operator compatibility, this will probably get you where you likely want to go: 1 2 3 4 5 >>> from numerary import IntegralLike , RealLike >>> def deeper_thot ( arg : RealLike ) -> IntegralLike : ... assert arg != 0 and arg ** 0 == 1 ... return arg // arg + 42 Beyond default compositions for common use cases, numerary expands on the Supports pattern used in the standard library. For example, numerary.types.SupportsIntegralOps is a @typing.runtime_checkable protocol that approximates the unary and binary operators introduced by numbers.Integral . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from numerary.types import SupportsIntegralOps >>> def shift_right_one ( arg : SupportsIntegralOps ) -> SupportsIntegralOps : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg >> 1 >>> shift_right_one ( 2 ) 1 >>> from sympy import sympify >>> two = sympify ( \"2\" ) ; type ( two ) < class ' sympy . core . numbers . Integer '> >>> res = shift_right_one ( two ) ; res 1 >>> type ( res ) < class ' sympy . core . numbers . One '> >>> from fractions import Fraction >>> shift_right_one ( Fraction ( 1 , 2 )) # type: ignore [arg-type] # properly caught by Mypy Traceback ( most recent call last ): ... AssertionError Note Until 1.9, sympy.Integer lacked the requisite bitwise operators . numerary catches that! The above properly results in both a type-checking error as well as a runtime failure for SymPy versions prior to 1.9. numerary \u2019s Supports protocols can be composed to refine requirements. For example, let\u2019s say one wanted to ensure type compatibility with primitives that support both __abs__ and __divmod__ . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 >>> from beartype.typing import TypeVar >>> T_co = TypeVar ( \"T_co\" , covariant = True ) >>> from numerary.types import ( ... CachingProtocolMeta , Protocol , runtime_checkable , ... SupportsAbs , SupportsDivmod , ... ) >>> @runtime_checkable ... class MyType ( ... SupportsAbs [ T_co ], SupportsDivmod [ T_co ], ... Protocol , metaclass = CachingProtocolMeta , ... ): ... pass >>> my_type : MyType >>> my_type = 3.5 >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) 3.5 >>> divmod ( my_type , 2 ) ( 1.0 , 1.5 ) >>> from fractions import Fraction >>> my_type = Fraction ( 22 , 7 ) >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) Fraction ( 22 , 7 ) >>> divmod ( my_type , 2 ) ( 1 , Fraction ( 8 , 7 )) >>> from decimal import Decimal >>> my_type = Decimal ( \"5.2\" ) >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) Decimal ( '5.2' ) >>> divmod ( my_type , 2 ) ( Decimal ( '2' ), Decimal ( '1.2' )) >>> my_type = \"nope\" # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( my_type , MyType ) False Remember that scandal where complex defined exception-throwing comparators it wasn\u2019t supposed to have, which confused runtime protocol checking, and then its type definitions lied about it to cover it up ? Yeah, that shit ends here . 1 2 3 4 5 6 >>> from numerary.types import SupportsRealOps >>> isinstance ( 1.0 , SupportsRealOps ) # all good True >>> has_real_ops : SupportsRealOps = complex ( 1 ) # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( complex ( 1 ), SupportsRealOps ) # you're not fooling anyone, buddy False numerary not only caches runtime protocol evaluations, but allows overriding those evaluations when the default machinery gets it wrong. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class MySupportsOne ( Protocol , metaclass = CachingProtocolMeta ): ... @abstractmethod ... def one ( self ) -> int : ... pass >>> class Imposter : ... def one ( self ) -> str : ... return \"one\" >>> imp : MySupportsOne = Imposter () # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( imp , MySupportsOne ) # fool me once, shame on you ... True >>> MySupportsOne . excludes ( Imposter ) >>> isinstance ( imp , MySupportsOne ) # ... can't get fooled again False numerary has default overrides to correct for known oddities with native types (like our old friend, complex ) and with popular libraries like numpy and sympy . Others will be added as they are identified. If I\u2019ve missed any, or if you would like numerary to support additional number implementations out of the box, please let me know . Performance Enhanced Protocols\u2014A different kind of \u201cPEP\u201d for your step By default, protocols frustrate runtime type-checking performance . A lot. numerary applies two distinct, layered optimization strategies: Cached __instancecheck__ results for numerary -defined protocols; and Optional(-ish) short-circuit type enumerations. Cached __instancecheck__ results To understand why numerary protocols are faster for runtime checks, it helps to understand why non- numerary protocols are so slow. At runtime (i.e., via isinstance ), the default Protocol implementation delegates to type(Protocol).__instancecheck__ to perform a crude comparison of an instance\u2019s callable attributes against the protocol\u2019s. More attributes means more comparisons. Further, it performs these comparisons \u2026 Every. Single. \ud83e\udd2cing. Time. Protocols provided by numerary use instead CachingProtocolMeta as their meta class. CachingProtocolMeta derives from type(Protocol) and overrides __instancecheck__ to cache results based on instance type. Conceptually: 1 2 3 4 5 6 7 8 >>> isinstance ( 1 , SupportsIntegralOps ) # first check for an int is delegated to type(Protocol).__instancecheck__ True >>> isinstance ( 2 , SupportsIntegralOps ) # cached result True >>> isinstance ( 1.0 , SupportsIntegralOps ) # the first check for a float is delegated to type(Protocol).__instancecheck__ False >>> isinstance ( 2.0 , SupportsIntegralOps ) # cached result False These offer significant performance improvements, especially where protocols define many methods. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 % timeit isinstance ( builtins . int ( 1 ), _SupportsComplexOps ) 9.69 \u00b5s \u00b1 157 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) % timeit isinstance ( builtins . int ( 1 ), SupportsComplexOps ) 198 ns \u00b1 1.94 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) % timeit isinstance ( builtins . float ( 2.0 ), _SupportsComplexOps ) 9.99 \u00b5s \u00b1 923 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) % timeit isinstance ( builtins . float ( 2.0 ), SupportsComplexOps ) 202 ns \u00b1 2.57 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) % timeit isinstance ( decimal . Decimal ( 3 ), _SupportsComplexOps ) 9.94 \u00b5s \u00b1 267 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) % timeit isinstance ( decimal . Decimal ( 3 ), SupportsComplexOps ) 202 ns \u00b1 1.24 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) % timeit isinstance ( fractions . Fraction ( 4 ), _SupportsComplexOps ) 9.67 \u00b5s \u00b1 133 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) % timeit isinstance ( fractions . Fraction ( 4 ), SupportsComplexOps ) 209 ns \u00b1 5.67 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) % timeit isinstance ( sympy . core . numbers . Integer ( 5 ), _SupportsComplexOps ) 9.8 \u00b5s \u00b1 161 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) % timeit isinstance ( sympy . core . numbers . Integer ( 5 ), SupportsComplexOps ) 199 ns \u00b1 1.63 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) Source: perf_supports_complex.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from decimal import Decimal from fractions import Fraction from numerary.types import _SupportsComplexOps # non-caching version from numerary.types import SupportsComplexOps # CachingProtocolMeta version import sympy one_int = 1 two_float = 2.0 three_dec = Decimal ( 3 ) four_frac = Fraction ( 4 ) five_sym = sympy . sympify ( 5 ) vals = ( one_int , two_float , three_dec , four_frac , five_sym ) for v in vals : for t in ( _SupportsComplexOps , SupportsComplexOps , ): print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) print () Union s for inclusion Sometimes we might want types that don\u2019t comply with protocol definitions to validate anyway (e.g., because we know they will work at runtime). For example, float s in Python versions prior to 3.9 officially lacked __floor__ and __ceil__ methods, but were registered with the numeric tower and worked just fine with math.floor and math.ceil . How does numerary \u2019s SupportsFloorCeil deal with this situation? Not very well, unfortunately, at least not on its own. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> import math , sys >>> from numerary.types import SupportsFloorCeil >>> def my_dumb_floor_func ( arg : SupportsFloorCeil ) -> int : ... assert isinstance ( arg , SupportsFloorCeil ) # will work, even for floats, thanks to default overrides ... return math . floor ( arg ) # type: ignore [arg-type] # doesn't understand SupportsFloorCeil >>> float_val : float = 1.6180339887 >>> # For illustration only until <https://github.com/python/mypy/issues/5940> is fixed >>> if sys . version_info < ( 3 , 9 ): ... my_dumb_floor_func ( float_val ) # type: ignore [arg-type] # still results in a Mypy error for Python version <3.9 ... else : ... my_dumb_floor_func ( float_val ) # validates 1 Union s allow a work-around. 1 2 3 4 5 6 7 8 9 10 11 >>> from beartype.typing import Union >>> from numerary.types import SupportsFloorCeil , __floor__ >>> SupportsFloorCeilU = Union [ float , SupportsFloorCeil ] >>> import sys >>> def my_floor_func ( arg : SupportsFloorCeilU ) -> int : ... assert isinstance ( arg , SupportsFloorCeil ) ... return __floor__ ( arg ) >>> my_floor_func ( float ( 1.2 )) # works in 3.8+ 1 This is largely a contrived example, since math.floor and math.ceil happily accept SupportsFloat , but it is useful for illustration. Limitations There are some downsides, though. (Aren\u2019t there always?) Sometimes protocols are too trusting Protocols trust numeric tower registrations. TODO(@posita): Is this really true? But sometimes, out there in the real world, implementations lie . Consider: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 >>> from numbers import Integral >>> hasattr ( Integral , \"real\" ) and hasattr ( Integral , \"imag\" ) True >>> import sympy >>> pants_on_fire = sympy . Integer ( 1 ) >>> isinstance ( pants_on_fire , Integral ) True >>> hasattr ( pants_on_fire , \"real\" ) or hasattr ( pants_on_fire , \"imag\" ) # somebody's tellin' stories False >>> from numerary.types import SupportsRealImag >>> real_imag : SupportsRealImag = pants_on_fire # fails to detect the lie >>> real_imag . real Traceback ( most recent call last ): ... AttributeError : 'One' object has no attribute 'real' In this particular case, numerary provides us with a defensive mechanism. 1 2 3 4 5 6 >>> from numerary.types import SupportsRealImagMixedU , real , imag >>> real_imag_defense : SupportsRealImagMixedU = pants_on_fire >>> real ( real_imag_defense ) 1 >>> imag ( real_imag ) 0 Protocols loses fidelity during runtime checking At runtime, protocols match names , not signatures . For example, SupportsNumeratorDenominator \u2019s numerator and denominator properties will match sage.rings.integer.Integer \u2019s similarly named functions . In other words, isinstance(sage_integer, SupportsNumeratorDenominator) will return True . Further, if the short-circuiting approach is used, because sage.rings.integer.Integer registers itself with the numeric tower, this may 2 not be caught by Mypy. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 >>> class SageLikeRational : ... def __init__ ( self , numerator : int , denominator : int = 1 ): ... self . _numerator = numerator ... self . _denominator = denominator ... def numerator ( self ) -> int : ... return self . _numerator ... def denominator ( self ) -> int : ... return self . _denominator >>> from numerary.types import SupportsNumeratorDenominator >>> frac : SupportsNumeratorDenominator = Fraction ( 29 , 3 ) # no typing error >>> sage_rational1 : SupportsNumeratorDenominator = SageLikeRational ( 29 , 3 ) # type: ignore [assignment] # Mypy catches this >>> isinstance ( sage_rational1 , SupportsNumeratorDenominator ) # isinstance does not True >>> sage_rational1 . numerator <... method ... numerator ...> >>> frac . numerator 29 Known warts could be cured by cache overriding as discussed above. However, to combat this particular situation, numerary provides an alternative: the SupportsNumeratorDenominatorMethods protocol and the numerator and denominator helper functions. These accommodate rational implementations like Sage\u2019s that are mostly compliant with the exception of their respective numerator and denominator implementations. 1 2 3 4 5 6 7 8 9 10 >>> from numerary.types import numerator >>> numerator ( sage_rational1 ) 29 >>> numerator ( frac ) 29 >>> from numerary.types import SupportsNumeratorDenominatorMethods , numerator >>> sage_rational2 : SupportsNumeratorDenominatorMethods = SageLikeRational ( 3 , 29 ) # no type error >>> numerator ( sage_rational2 ) 3 numerary also defines: 1 2 3 4 5 6 7 8 SupportsNumeratorDenominatorMixedU = Union [ SupportsNumeratorDenominator , SupportsNumeratorDenominatorMethods , ] SupportsNumeratorDenominatorMixedT = ( SupportsNumeratorDenominator , SupportsNumeratorDenominatorMethods , ) 1 2 3 4 5 6 7 8 >>> from numerary.types import SupportsNumeratorDenominatorMixedU , numerator >>> chimera_rational : SupportsNumeratorDenominatorMixedU >>> chimera_rational = Fraction ( 29 , 3 ) # no type error >>> numerator ( chimera_rational ) 29 >>> chimera_rational = SageLikeRational ( 3 , 29 ) # still no type error >>> numerator ( chimera_rational ) 3 The SupportsNumeratorDenominator* primitives provide the basis for analogous numerary.types.RationalLike* primitives , which should provide sufficient (if idiosyncratic) coverage for dealing with (seemingly mis-appropriately named) rationals. Pass-through caching with composition is pretty sketchy This is really getting into where the sausage is made, but full transparency is important, because CachingProtocolMeta does change how protocols are validated at runtime. Let\u2019s say we register an errant implementation as non-compliant using the CachingProtocolMeta.excludes method . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> from numerary.types import SupportsFloat >>> class FloatImposter : ... def __float__ ( self ) -> float : ... raise NotImplementedError ( \"Haha! JK! @#$% you!\" ) ... def __int__ ( self ) -> int : ... return 42 >>> float_imp = FloatImposter () >>> isinstance ( float_imp , SupportsFloat ) True >>> SupportsFloat . excludes ( FloatImposter ) >>> isinstance ( float_imp , SupportsFloat ) False For registration to be ergonomic, it should be indelible, survive composition, and afford preference to subsequent overrides by inheritors. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 >>> from numerary.types import ( ... CachingProtocolMeta , Protocol , runtime_checkable , ... SupportsInt , ... ) >>> @runtime_checkable ... class MySupportsFloatInt ( ... SupportsFloat , SupportsInt , ... Protocol , ... ): ... pass >>> isinstance ( float_imp , MySupportsFloatInt ) # composition picks up override from base False >>> SupportsFloat . reset_for ( FloatImposter ) # base resets override >>> isinstance ( float_imp , SupportsFloat ) True >>> isinstance ( float_imp , MySupportsFloatInt ) # picks up base\u2019s changes True >>> MySupportsFloatInt . excludes ( FloatImposter ) # composition overrides >>> isinstance ( float_imp , MySupportsFloatInt ) False >>> SupportsFloat . includes ( FloatImposter ) # base changes >>> isinstance ( float_imp , FloatImposter ) True >>> isinstance ( float_imp , MySupportsFloatInt ) # composition remains unchanged False >>> MySupportsFloatInt . reset_for ( FloatImposter ) # removes override in composition >>> isinstance ( float_imp , MySupportsFloatInt ) # base is visible again True >>> SupportsFloat . excludes ( FloatImposter ) >>> isinstance ( float_imp , MySupportsFloatInt ) # base\u2019s changes are visible to composition again False For this to work under the current implementation, we cannot rely exclusively on the standard library\u2019s implementation of __instancecheck__ , since it flattens and inspects all properties (with some proprietary exceptions) of all classes in the inheritance tree (in order of the MRO). In practical terms, this means one can\u2019t easily delegate to an ancestor\u2019s __instancecheck__ method and a protocol\u2019s cache is effectively hidden from its progeny. In other words, leaning on the default behavior would require one to register exceptions with every inheritor. That would suck, so let\u2019s not do that. However, overriding the behavior is problematic, because the standard library uses non-public interfaces to perform its attribute enumeration. We certainly don\u2019t want to re-implement protocol runtime checking from scratch. (At least not yet.) beartype.typing.Protocol \u2019s meta class tries to work around this by sneakily limiting its evaluation to directly defined attributes, and then delegating isinstance evaluation to its __base__ classes. In doing so, it picks up its bases\u2019 then-cached values, but at the cost of re-implementing the attribute check as well as taking a dependency on various implementation details of the standard library, which creates a fragility. Further, for post-inheritance updates, CachingProtocolMeta extends beartype \u2019s version to implement a simplistic publish/subscribe mechanism that dirties non-overridden caches in inheritors when member protocols caches are updated. That\u2019s completely off the beaten path and there are probably some gremlins hiding out there. One subtlety is that the implementation deviates from performing checks in MRO order (and may perform redundant checks). This is probably fine as long as runtime comparisons remain limited to crude checks whether attributes merely exist. It would likely fail if runtime checking becomes more sophisticated, at which time, this implementation will need to be revisited. Hopefully by then, we can just delete numerary as the aspirationally unnecessary hack it is and move on with our lives. (See beartype.typing and numerary \u2019s extension for details.) License numerary is licensed under the MIT License . See the included LICENSE file for details. Source code is available on GitHub . Installation Installation can be performed via PyPI . 1 2 % pip install numerary ... Alternately, you can download the source and install manually. 1 2 3 4 5 % git clone https://github.com/posita/numerary.git ... % cd numerary % python -m pip install . # -or- python -c 'from setuptools import setup ; setup()' install . ... Requirements numerary requires a relatively modern version of Python: CPython (3.8+) PyPy (CPython 3.8+ compatible) It has the following runtime dependencies: beartype for caching protocols numerary will not use beartype internally unless the NUMERARY_BEARTYPE environment variable is set to a truthy 3 value before numerary is loaded. See the hacking quick-start for additional development and testing dependencies. Customers dyce - a pure-Python library for modeling arbitrarily complex dice mechanics and mother birthing code base of numerary ! \ud83d\udc7b phantom-types - predicates and other type constraints without runtime overhead The next one could be you ! \ud83d\udc4b Do you have a project that suffers problems made slightly less annoying by numerary ? Let me know , and I\u2019ll promote it here! And don\u2019t forget to do your part in perpetuating gratuitous badge-ification! 1 2 3 4 <!-- Markdown --> As of version 0.4.1, ``dyce`` is [ ![numerary-encumbered ]( https://raw.githubusercontent.com/posita/numerary/latest/docs/numerary-encumbered.svg )][numerary-encumbered]! [ numerary-encumbered ]: https://posita.github.io/numerary/ \"numerary-encumbered\" 1 2 3 4 5 6 7 8 9 .. reStructuredText - see https://docutils.sourceforge.io/docs/ref/rst/directives.html#image As of version 0.4.1, ``dyce`` is |numerary-encumbered|! .. |numerary-encumbered| image :: https://raw.githubusercontent.com/posita/numerary/latest/docs/numerary-encumbered.svg :align: top :target: https://posita.github.io/numerary/ :alt: numerary-encumbered 1 2 3 4 5 <!-- HTML --> As of version 0.4.1, < code > dyce </ code > is < a href = \"https://posita.github.io/numerary/\" >< img src = \"https://raw.githubusercontent.com/posita/numerary/latest/docs/numerary-encumbered.svg\" alt = \"numerary-encumbered\" style = \"vertical-align: middle;\" ></ a > ! You know, super weird, off-the-wall shit, like members of the numeric tower , or standard library primitives that remain non -members for some \ud83e\udd2ced up reason , or legitimate non-members because they predate PEP 3141 and conforming would amount to breaking changes , or\u2014I don\u2019t know\u2014oodles of libraries and applications that have been around for literally decades that bring huge value to vast scientific and mathematic audiences, but whose number primitives break type-checking if one abides by the ubiquitous bum steer, \u201cI don\u2019t have any experience trying to do what you\u2019re doing, but just use float , bro.\u201d Because, hey, \ud83e\udd2c numbers! Am I right? \u21a9 I say may because I don\u2019t really understand how Sage\u2019s number registrations work. \u21a9 I.E., one of: 1 , on , t , true , and yes . \u21a9","title":"Introduction"},{"location":"#numerarynow-with-protocol-powertm","text":"That\u2019s right! For a hopefully limited time, you too can benefit from someone else\u2019s deranged work-arounds for the enormous chasms in Python that lie between the esoteric fields of computation that are \u201ctyping\u201d and \u201cnumbers\u201d instead of having to roll your own out of sheer desperation from first principles ! If you still have no idea what I\u2019m talking about, this may help illustrate . numerary is a pure-Python codified rant for signaling that your interface is usable with non-native numeric primitives 1 without breaking type-checking. More simply, numerary aspires to a world where numbers and types can work together. If you\u2019re thinking that you shouldn\u2019t need a \ud83e\udd2cing library for that, you\u2019re right . This madness should enjoy no audience. It should not exist. Yet here we are. Its author gauges its success by how quickly it can be forgotten, relegated to the annals of superfluous folly. numerary is licensed under the MIT License . See the accompanying LICENSE file for details. It should be considered experimental for now, but should settle down quickly. See the release notes for a summary of version-to-version changes. Source code is available on GitHub . If you find it lacking in any way, please don\u2019t hesitate to bring it to my attention .","title":"numerary\u2014Now with Protocol Power\u2122"},{"location":"#you-had-me-at-numbers-and-types-can-work-together","text":"numerary strives to define composable, efficient protocols that one can use to construct numeric requirements. If all you deal with are integrals and reals, and what you want is broad arithmetic operator compatibility, this will probably get you where you likely want to go: 1 2 3 4 5 >>> from numerary import IntegralLike , RealLike >>> def deeper_thot ( arg : RealLike ) -> IntegralLike : ... assert arg != 0 and arg ** 0 == 1 ... return arg // arg + 42 Beyond default compositions for common use cases, numerary expands on the Supports pattern used in the standard library. For example, numerary.types.SupportsIntegralOps is a @typing.runtime_checkable protocol that approximates the unary and binary operators introduced by numbers.Integral . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from numerary.types import SupportsIntegralOps >>> def shift_right_one ( arg : SupportsIntegralOps ) -> SupportsIntegralOps : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg >> 1 >>> shift_right_one ( 2 ) 1 >>> from sympy import sympify >>> two = sympify ( \"2\" ) ; type ( two ) < class ' sympy . core . numbers . Integer '> >>> res = shift_right_one ( two ) ; res 1 >>> type ( res ) < class ' sympy . core . numbers . One '> >>> from fractions import Fraction >>> shift_right_one ( Fraction ( 1 , 2 )) # type: ignore [arg-type] # properly caught by Mypy Traceback ( most recent call last ): ... AssertionError Note Until 1.9, sympy.Integer lacked the requisite bitwise operators . numerary catches that! The above properly results in both a type-checking error as well as a runtime failure for SymPy versions prior to 1.9. numerary \u2019s Supports protocols can be composed to refine requirements. For example, let\u2019s say one wanted to ensure type compatibility with primitives that support both __abs__ and __divmod__ . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 >>> from beartype.typing import TypeVar >>> T_co = TypeVar ( \"T_co\" , covariant = True ) >>> from numerary.types import ( ... CachingProtocolMeta , Protocol , runtime_checkable , ... SupportsAbs , SupportsDivmod , ... ) >>> @runtime_checkable ... class MyType ( ... SupportsAbs [ T_co ], SupportsDivmod [ T_co ], ... Protocol , metaclass = CachingProtocolMeta , ... ): ... pass >>> my_type : MyType >>> my_type = 3.5 >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) 3.5 >>> divmod ( my_type , 2 ) ( 1.0 , 1.5 ) >>> from fractions import Fraction >>> my_type = Fraction ( 22 , 7 ) >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) Fraction ( 22 , 7 ) >>> divmod ( my_type , 2 ) ( 1 , Fraction ( 8 , 7 )) >>> from decimal import Decimal >>> my_type = Decimal ( \"5.2\" ) >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) Decimal ( '5.2' ) >>> divmod ( my_type , 2 ) ( Decimal ( '2' ), Decimal ( '1.2' )) >>> my_type = \"nope\" # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( my_type , MyType ) False Remember that scandal where complex defined exception-throwing comparators it wasn\u2019t supposed to have, which confused runtime protocol checking, and then its type definitions lied about it to cover it up ? Yeah, that shit ends here . 1 2 3 4 5 6 >>> from numerary.types import SupportsRealOps >>> isinstance ( 1.0 , SupportsRealOps ) # all good True >>> has_real_ops : SupportsRealOps = complex ( 1 ) # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( complex ( 1 ), SupportsRealOps ) # you're not fooling anyone, buddy False numerary not only caches runtime protocol evaluations, but allows overriding those evaluations when the default machinery gets it wrong. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class MySupportsOne ( Protocol , metaclass = CachingProtocolMeta ): ... @abstractmethod ... def one ( self ) -> int : ... pass >>> class Imposter : ... def one ( self ) -> str : ... return \"one\" >>> imp : MySupportsOne = Imposter () # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( imp , MySupportsOne ) # fool me once, shame on you ... True >>> MySupportsOne . excludes ( Imposter ) >>> isinstance ( imp , MySupportsOne ) # ... can't get fooled again False numerary has default overrides to correct for known oddities with native types (like our old friend, complex ) and with popular libraries like numpy and sympy . Others will be added as they are identified. If I\u2019ve missed any, or if you would like numerary to support additional number implementations out of the box, please let me know .","title":"You had me at, \u201cnumbers and types can work together\u201d"},{"location":"#performance-enhanced-protocolsa-different-kind-of-pep-for-your-step","text":"By default, protocols frustrate runtime type-checking performance . A lot. numerary applies two distinct, layered optimization strategies: Cached __instancecheck__ results for numerary -defined protocols; and Optional(-ish) short-circuit type enumerations.","title":"Performance Enhanced Protocols\u2014A different kind of \u201cPEP\u201d for your step"},{"location":"#cached-__instancecheck__-results","text":"To understand why numerary protocols are faster for runtime checks, it helps to understand why non- numerary protocols are so slow. At runtime (i.e., via isinstance ), the default Protocol implementation delegates to type(Protocol).__instancecheck__ to perform a crude comparison of an instance\u2019s callable attributes against the protocol\u2019s. More attributes means more comparisons. Further, it performs these comparisons \u2026 Every. Single. \ud83e\udd2cing. Time. Protocols provided by numerary use instead CachingProtocolMeta as their meta class. CachingProtocolMeta derives from type(Protocol) and overrides __instancecheck__ to cache results based on instance type. Conceptually: 1 2 3 4 5 6 7 8 >>> isinstance ( 1 , SupportsIntegralOps ) # first check for an int is delegated to type(Protocol).__instancecheck__ True >>> isinstance ( 2 , SupportsIntegralOps ) # cached result True >>> isinstance ( 1.0 , SupportsIntegralOps ) # the first check for a float is delegated to type(Protocol).__instancecheck__ False >>> isinstance ( 2.0 , SupportsIntegralOps ) # cached result False These offer significant performance improvements, especially where protocols define many methods. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 % timeit isinstance ( builtins . int ( 1 ), _SupportsComplexOps ) 9.69 \u00b5s \u00b1 157 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) % timeit isinstance ( builtins . int ( 1 ), SupportsComplexOps ) 198 ns \u00b1 1.94 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) % timeit isinstance ( builtins . float ( 2.0 ), _SupportsComplexOps ) 9.99 \u00b5s \u00b1 923 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) % timeit isinstance ( builtins . float ( 2.0 ), SupportsComplexOps ) 202 ns \u00b1 2.57 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) % timeit isinstance ( decimal . Decimal ( 3 ), _SupportsComplexOps ) 9.94 \u00b5s \u00b1 267 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) % timeit isinstance ( decimal . Decimal ( 3 ), SupportsComplexOps ) 202 ns \u00b1 1.24 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) % timeit isinstance ( fractions . Fraction ( 4 ), _SupportsComplexOps ) 9.67 \u00b5s \u00b1 133 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) % timeit isinstance ( fractions . Fraction ( 4 ), SupportsComplexOps ) 209 ns \u00b1 5.67 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) % timeit isinstance ( sympy . core . numbers . Integer ( 5 ), _SupportsComplexOps ) 9.8 \u00b5s \u00b1 161 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) % timeit isinstance ( sympy . core . numbers . Integer ( 5 ), SupportsComplexOps ) 199 ns \u00b1 1.63 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) Source: perf_supports_complex.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from decimal import Decimal from fractions import Fraction from numerary.types import _SupportsComplexOps # non-caching version from numerary.types import SupportsComplexOps # CachingProtocolMeta version import sympy one_int = 1 two_float = 2.0 three_dec = Decimal ( 3 ) four_frac = Fraction ( 4 ) five_sym = sympy . sympify ( 5 ) vals = ( one_int , two_float , three_dec , four_frac , five_sym ) for v in vals : for t in ( _SupportsComplexOps , SupportsComplexOps , ): print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) print ()","title":"Cached __instancecheck__ results"},{"location":"#unions-for-inclusion","text":"Sometimes we might want types that don\u2019t comply with protocol definitions to validate anyway (e.g., because we know they will work at runtime). For example, float s in Python versions prior to 3.9 officially lacked __floor__ and __ceil__ methods, but were registered with the numeric tower and worked just fine with math.floor and math.ceil . How does numerary \u2019s SupportsFloorCeil deal with this situation? Not very well, unfortunately, at least not on its own. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> import math , sys >>> from numerary.types import SupportsFloorCeil >>> def my_dumb_floor_func ( arg : SupportsFloorCeil ) -> int : ... assert isinstance ( arg , SupportsFloorCeil ) # will work, even for floats, thanks to default overrides ... return math . floor ( arg ) # type: ignore [arg-type] # doesn't understand SupportsFloorCeil >>> float_val : float = 1.6180339887 >>> # For illustration only until <https://github.com/python/mypy/issues/5940> is fixed >>> if sys . version_info < ( 3 , 9 ): ... my_dumb_floor_func ( float_val ) # type: ignore [arg-type] # still results in a Mypy error for Python version <3.9 ... else : ... my_dumb_floor_func ( float_val ) # validates 1 Union s allow a work-around. 1 2 3 4 5 6 7 8 9 10 11 >>> from beartype.typing import Union >>> from numerary.types import SupportsFloorCeil , __floor__ >>> SupportsFloorCeilU = Union [ float , SupportsFloorCeil ] >>> import sys >>> def my_floor_func ( arg : SupportsFloorCeilU ) -> int : ... assert isinstance ( arg , SupportsFloorCeil ) ... return __floor__ ( arg ) >>> my_floor_func ( float ( 1.2 )) # works in 3.8+ 1 This is largely a contrived example, since math.floor and math.ceil happily accept SupportsFloat , but it is useful for illustration.","title":"Unions for inclusion"},{"location":"#limitations","text":"There are some downsides, though. (Aren\u2019t there always?)","title":"Limitations"},{"location":"#sometimes-protocols-are-too-trusting","text":"Protocols trust numeric tower registrations. TODO(@posita): Is this really true? But sometimes, out there in the real world, implementations lie . Consider: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 >>> from numbers import Integral >>> hasattr ( Integral , \"real\" ) and hasattr ( Integral , \"imag\" ) True >>> import sympy >>> pants_on_fire = sympy . Integer ( 1 ) >>> isinstance ( pants_on_fire , Integral ) True >>> hasattr ( pants_on_fire , \"real\" ) or hasattr ( pants_on_fire , \"imag\" ) # somebody's tellin' stories False >>> from numerary.types import SupportsRealImag >>> real_imag : SupportsRealImag = pants_on_fire # fails to detect the lie >>> real_imag . real Traceback ( most recent call last ): ... AttributeError : 'One' object has no attribute 'real' In this particular case, numerary provides us with a defensive mechanism. 1 2 3 4 5 6 >>> from numerary.types import SupportsRealImagMixedU , real , imag >>> real_imag_defense : SupportsRealImagMixedU = pants_on_fire >>> real ( real_imag_defense ) 1 >>> imag ( real_imag ) 0","title":"Sometimes protocols are too trusting"},{"location":"#protocols-loses-fidelity-during-runtime-checking","text":"At runtime, protocols match names , not signatures . For example, SupportsNumeratorDenominator \u2019s numerator and denominator properties will match sage.rings.integer.Integer \u2019s similarly named functions . In other words, isinstance(sage_integer, SupportsNumeratorDenominator) will return True . Further, if the short-circuiting approach is used, because sage.rings.integer.Integer registers itself with the numeric tower, this may 2 not be caught by Mypy. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 >>> class SageLikeRational : ... def __init__ ( self , numerator : int , denominator : int = 1 ): ... self . _numerator = numerator ... self . _denominator = denominator ... def numerator ( self ) -> int : ... return self . _numerator ... def denominator ( self ) -> int : ... return self . _denominator >>> from numerary.types import SupportsNumeratorDenominator >>> frac : SupportsNumeratorDenominator = Fraction ( 29 , 3 ) # no typing error >>> sage_rational1 : SupportsNumeratorDenominator = SageLikeRational ( 29 , 3 ) # type: ignore [assignment] # Mypy catches this >>> isinstance ( sage_rational1 , SupportsNumeratorDenominator ) # isinstance does not True >>> sage_rational1 . numerator <... method ... numerator ...> >>> frac . numerator 29 Known warts could be cured by cache overriding as discussed above. However, to combat this particular situation, numerary provides an alternative: the SupportsNumeratorDenominatorMethods protocol and the numerator and denominator helper functions. These accommodate rational implementations like Sage\u2019s that are mostly compliant with the exception of their respective numerator and denominator implementations. 1 2 3 4 5 6 7 8 9 10 >>> from numerary.types import numerator >>> numerator ( sage_rational1 ) 29 >>> numerator ( frac ) 29 >>> from numerary.types import SupportsNumeratorDenominatorMethods , numerator >>> sage_rational2 : SupportsNumeratorDenominatorMethods = SageLikeRational ( 3 , 29 ) # no type error >>> numerator ( sage_rational2 ) 3 numerary also defines: 1 2 3 4 5 6 7 8 SupportsNumeratorDenominatorMixedU = Union [ SupportsNumeratorDenominator , SupportsNumeratorDenominatorMethods , ] SupportsNumeratorDenominatorMixedT = ( SupportsNumeratorDenominator , SupportsNumeratorDenominatorMethods , ) 1 2 3 4 5 6 7 8 >>> from numerary.types import SupportsNumeratorDenominatorMixedU , numerator >>> chimera_rational : SupportsNumeratorDenominatorMixedU >>> chimera_rational = Fraction ( 29 , 3 ) # no type error >>> numerator ( chimera_rational ) 29 >>> chimera_rational = SageLikeRational ( 3 , 29 ) # still no type error >>> numerator ( chimera_rational ) 3 The SupportsNumeratorDenominator* primitives provide the basis for analogous numerary.types.RationalLike* primitives , which should provide sufficient (if idiosyncratic) coverage for dealing with (seemingly mis-appropriately named) rationals.","title":"Protocols loses fidelity during runtime checking"},{"location":"#pass-through-caching-with-composition-is-pretty-sketchy","text":"This is really getting into where the sausage is made, but full transparency is important, because CachingProtocolMeta does change how protocols are validated at runtime. Let\u2019s say we register an errant implementation as non-compliant using the CachingProtocolMeta.excludes method . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> from numerary.types import SupportsFloat >>> class FloatImposter : ... def __float__ ( self ) -> float : ... raise NotImplementedError ( \"Haha! JK! @#$% you!\" ) ... def __int__ ( self ) -> int : ... return 42 >>> float_imp = FloatImposter () >>> isinstance ( float_imp , SupportsFloat ) True >>> SupportsFloat . excludes ( FloatImposter ) >>> isinstance ( float_imp , SupportsFloat ) False For registration to be ergonomic, it should be indelible, survive composition, and afford preference to subsequent overrides by inheritors. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 >>> from numerary.types import ( ... CachingProtocolMeta , Protocol , runtime_checkable , ... SupportsInt , ... ) >>> @runtime_checkable ... class MySupportsFloatInt ( ... SupportsFloat , SupportsInt , ... Protocol , ... ): ... pass >>> isinstance ( float_imp , MySupportsFloatInt ) # composition picks up override from base False >>> SupportsFloat . reset_for ( FloatImposter ) # base resets override >>> isinstance ( float_imp , SupportsFloat ) True >>> isinstance ( float_imp , MySupportsFloatInt ) # picks up base\u2019s changes True >>> MySupportsFloatInt . excludes ( FloatImposter ) # composition overrides >>> isinstance ( float_imp , MySupportsFloatInt ) False >>> SupportsFloat . includes ( FloatImposter ) # base changes >>> isinstance ( float_imp , FloatImposter ) True >>> isinstance ( float_imp , MySupportsFloatInt ) # composition remains unchanged False >>> MySupportsFloatInt . reset_for ( FloatImposter ) # removes override in composition >>> isinstance ( float_imp , MySupportsFloatInt ) # base is visible again True >>> SupportsFloat . excludes ( FloatImposter ) >>> isinstance ( float_imp , MySupportsFloatInt ) # base\u2019s changes are visible to composition again False For this to work under the current implementation, we cannot rely exclusively on the standard library\u2019s implementation of __instancecheck__ , since it flattens and inspects all properties (with some proprietary exceptions) of all classes in the inheritance tree (in order of the MRO). In practical terms, this means one can\u2019t easily delegate to an ancestor\u2019s __instancecheck__ method and a protocol\u2019s cache is effectively hidden from its progeny. In other words, leaning on the default behavior would require one to register exceptions with every inheritor. That would suck, so let\u2019s not do that. However, overriding the behavior is problematic, because the standard library uses non-public interfaces to perform its attribute enumeration. We certainly don\u2019t want to re-implement protocol runtime checking from scratch. (At least not yet.) beartype.typing.Protocol \u2019s meta class tries to work around this by sneakily limiting its evaluation to directly defined attributes, and then delegating isinstance evaluation to its __base__ classes. In doing so, it picks up its bases\u2019 then-cached values, but at the cost of re-implementing the attribute check as well as taking a dependency on various implementation details of the standard library, which creates a fragility. Further, for post-inheritance updates, CachingProtocolMeta extends beartype \u2019s version to implement a simplistic publish/subscribe mechanism that dirties non-overridden caches in inheritors when member protocols caches are updated. That\u2019s completely off the beaten path and there are probably some gremlins hiding out there. One subtlety is that the implementation deviates from performing checks in MRO order (and may perform redundant checks). This is probably fine as long as runtime comparisons remain limited to crude checks whether attributes merely exist. It would likely fail if runtime checking becomes more sophisticated, at which time, this implementation will need to be revisited. Hopefully by then, we can just delete numerary as the aspirationally unnecessary hack it is and move on with our lives. (See beartype.typing and numerary \u2019s extension for details.)","title":"Pass-through caching with composition is pretty sketchy"},{"location":"#license","text":"numerary is licensed under the MIT License . See the included LICENSE file for details. Source code is available on GitHub .","title":"License"},{"location":"#installation","text":"Installation can be performed via PyPI . 1 2 % pip install numerary ... Alternately, you can download the source and install manually. 1 2 3 4 5 % git clone https://github.com/posita/numerary.git ... % cd numerary % python -m pip install . # -or- python -c 'from setuptools import setup ; setup()' install . ...","title":"Installation"},{"location":"#requirements","text":"numerary requires a relatively modern version of Python: CPython (3.8+) PyPy (CPython 3.8+ compatible) It has the following runtime dependencies: beartype for caching protocols numerary will not use beartype internally unless the NUMERARY_BEARTYPE environment variable is set to a truthy 3 value before numerary is loaded. See the hacking quick-start for additional development and testing dependencies.","title":"Requirements"},{"location":"#customers","text":"dyce - a pure-Python library for modeling arbitrarily complex dice mechanics and mother birthing code base of numerary ! \ud83d\udc7b phantom-types - predicates and other type constraints without runtime overhead The next one could be you ! \ud83d\udc4b Do you have a project that suffers problems made slightly less annoying by numerary ? Let me know , and I\u2019ll promote it here! And don\u2019t forget to do your part in perpetuating gratuitous badge-ification! 1 2 3 4 <!-- Markdown --> As of version 0.4.1, ``dyce`` is [ ![numerary-encumbered ]( https://raw.githubusercontent.com/posita/numerary/latest/docs/numerary-encumbered.svg )][numerary-encumbered]! [ numerary-encumbered ]: https://posita.github.io/numerary/ \"numerary-encumbered\" 1 2 3 4 5 6 7 8 9 .. reStructuredText - see https://docutils.sourceforge.io/docs/ref/rst/directives.html#image As of version 0.4.1, ``dyce`` is |numerary-encumbered|! .. |numerary-encumbered| image :: https://raw.githubusercontent.com/posita/numerary/latest/docs/numerary-encumbered.svg :align: top :target: https://posita.github.io/numerary/ :alt: numerary-encumbered 1 2 3 4 5 <!-- HTML --> As of version 0.4.1, < code > dyce </ code > is < a href = \"https://posita.github.io/numerary/\" >< img src = \"https://raw.githubusercontent.com/posita/numerary/latest/docs/numerary-encumbered.svg\" alt = \"numerary-encumbered\" style = \"vertical-align: middle;\" ></ a > ! You know, super weird, off-the-wall shit, like members of the numeric tower , or standard library primitives that remain non -members for some \ud83e\udd2ced up reason , or legitimate non-members because they predate PEP 3141 and conforming would amount to breaking changes , or\u2014I don\u2019t know\u2014oodles of libraries and applications that have been around for literally decades that bring huge value to vast scientific and mathematic audiences, but whose number primitives break type-checking if one abides by the ubiquitous bum steer, \u201cI don\u2019t have any experience trying to do what you\u2019re doing, but just use float , bro.\u201d Because, hey, \ud83e\udd2c numbers! Am I right? \u21a9 I say may because I don\u2019t really understand how Sage\u2019s number registrations work. \u21a9 I.E., one of: 1 , on , t , true , and yes . \u21a9","title":"Customers"},{"location":"contrib/","text":"Contributing to numerary There are many ways you can contribute. You have only but to try. Starting discussions and filing issues You can file new issues as you find them. Please try to avoid duplicating issues. \u201cWriting Effective Bug Reports\u201d by Elisabeth Hendrickson (PDF) may be helpful. For more free-flow discussions (beefs, rants, ideas, recipes, etc.), consider starting or joining a discussion . Hacking quick-start An easy way to bootstrap an isolated development environment is: 1 2 3 4 5 6 7 8 9 10 % git clone --recurse-submodules https://github.com/posita/numerary.git \u2026 % cd numerary % /path/to/python -m venv .venv \u2026 % . .venv/bin/activate % pip install --upgrade --editable '.[dev]' \u2026 % python -m pre_commit install \u2026 Substitute your preferred virtual environment process for venv . The [dev] variant includes additional dependencies necessary for development and testing. See the [options.extras_require] section in setup.cfg . Unit tests are run with pytest via Tox . 1 2 3 4 % cd \u2026/path/to/numerary % . .venv/bin/activate % tox [ TOX_ARGS... [ -- PYTEST_ARGS... ]] \u2026 Submission guidelines If you are willing and able, consider submitting a pull request with a fix. See the docs if you\u2019re not already familiar with pull requests. numerary releases from master (although not always immediately), so a lot of these workflows are helpful. There are only a few additional guidelines: If it is not already present, please add your name (and optionally your email, GitHub username, website address, or other contact information) to the LICENSE file. 1 2 3 ... * [ Matt Bogosian ]( mailto:matt@bogosian.net?Subject=numerary ); GitHub \u2013 [ **@posita** ](https://github.com/posita) ... Use Black to format your changes. Do your best to follow the source conventions as you observe them. If it\u2019s important to you, Existing comments are wrapped at 88 characters per line to match Black\u2019s default. (Don\u2019t spend too much effort on strict conformance, though. I can clean things up later if they really bother me.) Provide tests where feasible and appropriate. At the very least, existing tests should not fail. (There are exceptions, but if there is any doubt, they probably do not apply.) Unit tests live in tests . If you want feedback on a work-in-progress, consider \u201cmentioning\u201d me ( @posita ), and describe specifically how I can help. Consider prefixing your pull request\u2019s title with something like, \u201c NEED FEEDBACK \u2013 \u201d. If your pull request is still in progress, but you are not blocked on anything, consider using the draft feature . Once you are ready for a merge, resolve any conflicts, squash your commits, and provide a useful commit message. ( This and this may be helpful.) If your pull request started out as a draft, promote it by requesting a review. Consider prefixing the pull request\u2019s title to something like, \u201c READY FOR MERGE \u2013 \u201d. I will try to get to it as soon as I can.","title":"Contributing"},{"location":"contrib/#contributing-to-numerary","text":"There are many ways you can contribute. You have only but to try.","title":"Contributing to numerary"},{"location":"contrib/#starting-discussions-and-filing-issues","text":"You can file new issues as you find them. Please try to avoid duplicating issues. \u201cWriting Effective Bug Reports\u201d by Elisabeth Hendrickson (PDF) may be helpful. For more free-flow discussions (beefs, rants, ideas, recipes, etc.), consider starting or joining a discussion .","title":"Starting discussions and filing issues"},{"location":"contrib/#hacking-quick-start","text":"An easy way to bootstrap an isolated development environment is: 1 2 3 4 5 6 7 8 9 10 % git clone --recurse-submodules https://github.com/posita/numerary.git \u2026 % cd numerary % /path/to/python -m venv .venv \u2026 % . .venv/bin/activate % pip install --upgrade --editable '.[dev]' \u2026 % python -m pre_commit install \u2026 Substitute your preferred virtual environment process for venv . The [dev] variant includes additional dependencies necessary for development and testing. See the [options.extras_require] section in setup.cfg . Unit tests are run with pytest via Tox . 1 2 3 4 % cd \u2026/path/to/numerary % . .venv/bin/activate % tox [ TOX_ARGS... [ -- PYTEST_ARGS... ]] \u2026","title":"Hacking quick-start"},{"location":"contrib/#submission-guidelines","text":"If you are willing and able, consider submitting a pull request with a fix. See the docs if you\u2019re not already familiar with pull requests. numerary releases from master (although not always immediately), so a lot of these workflows are helpful. There are only a few additional guidelines: If it is not already present, please add your name (and optionally your email, GitHub username, website address, or other contact information) to the LICENSE file. 1 2 3 ... * [ Matt Bogosian ]( mailto:matt@bogosian.net?Subject=numerary ); GitHub \u2013 [ **@posita** ](https://github.com/posita) ... Use Black to format your changes. Do your best to follow the source conventions as you observe them. If it\u2019s important to you, Existing comments are wrapped at 88 characters per line to match Black\u2019s default. (Don\u2019t spend too much effort on strict conformance, though. I can clean things up later if they really bother me.) Provide tests where feasible and appropriate. At the very least, existing tests should not fail. (There are exceptions, but if there is any doubt, they probably do not apply.) Unit tests live in tests . If you want feedback on a work-in-progress, consider \u201cmentioning\u201d me ( @posita ), and describe specifically how I can help. Consider prefixing your pull request\u2019s title with something like, \u201c NEED FEEDBACK \u2013 \u201d. If your pull request is still in progress, but you are not blocked on anything, consider using the draft feature . Once you are ready for a merge, resolve any conflicts, squash your commits, and provide a useful commit message. ( This and this may be helpful.) If your pull request started out as a draft, promote it by requesting a review. Consider prefixing the pull request\u2019s title to something like, \u201c READY FOR MERGE \u2013 \u201d. I will try to get to it as soon as I can.","title":"Submission guidelines"},{"location":"license/","text":"License and credits The MIT License (MIT) Copyright \u00a9 2015-2022 Matt Bogosian ( @posita ). Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Contributors The following individuals or entities have contributed to this software: Matt Bogosian ; GitHub \u2013 @posita By adding your name to this list, you grant a nonexclusive, perpetual license to your contributions to this software under the same terms as its license, above. Further, you warrant that your contributions to this software are exclusively your own creations and no one else has any superior right or claim to them. Finally, you agree to indemnify and hold harmless this software\u2019s owner against any colorable claim of infringement by a third party for this software\u2019s owner\u2019s otherwise lawful use of your contribution, whether or not such use was contemplated by you at the time you made it.","title":"License"},{"location":"license/#license-and-credits","text":"","title":"License and credits"},{"location":"license/#the-mit-license-mit","text":"Copyright \u00a9 2015-2022 Matt Bogosian ( @posita ). Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License (MIT)"},{"location":"license/#contributors","text":"The following individuals or entities have contributed to this software: Matt Bogosian ; GitHub \u2013 @posita By adding your name to this list, you grant a nonexclusive, perpetual license to your contributions to this software under the same terms as its license, above. Further, you warrant that your contributions to this software are exclusively your own creations and no one else has any superior right or claim to them. Finally, you agree to indemnify and hold harmless this software\u2019s owner against any colorable claim of infringement by a third party for this software\u2019s owner\u2019s otherwise lawful use of your contribution, whether or not such use was contemplated by you at the time you made it.","title":"Contributors"},{"location":"notes/","text":"numerary release notes 0.4.1 Minor corrections to required Python version. 0.4.0 Now relies on beartype . typing . Protocol as the underlying caching protocol implementation. This means that beartype has emerged as numerary \u2019s sole runtime dependency. ( numerary still layers on its own runtime override mechanism via CachingProtocolMeta , which derives from beartype \u2019s.) It also means that numerary loses Python 3.7 support, but that was largely illusory anyway. This decision was not made lightly. numerary is intended as a temporary work-around. It\u2019s obsolescence will be something to celebrate. Caching protocols, however, have much broader performance applications. They deserve more. beartype will provide what numerary was never meant to: a loving, stable, and permanent home. 0.3.0 Removes misleading advice that SCUs offer a performance benefit over merely using caching protocols. They could under very specific circumstances (where numerary probably isn\u2019t going to be helpful anyway), but not always, and probably aren\u2019t worth the trouble if performance is the only concern. Actually, removes SCUs altogether and documents a surgical example for those rare occasions where it might be needed. Finally removes SupportsNumeratorDenominatorProperties as promised. 0.2.1 Fixes trailing issues for sympy import issue resulting in ValueError s being thrown on import in some environments. 0.2.0 numerary goes beta! Splits SupportsRealImagAsMethod out of SupportsRealImag and provides the real and imag helper functions for better support of sympy \u2019s number primitives. Renames SupportsNumeratorDenominatorProperties to SupportsNumeratorDenominator to mirror SupportsRealImag and reflect that it captures the numeric tower interface. SupportsNumeratorDenominatorProperties and SupportsNumeratorDenominatorPropertiesSCU are maintained as aliases for limited backward compatibility and will be removed in the next version. Removes enum.Flag from testing as a non-sequitur. (It matches none of the presented protocols.) Introduces __pow__ helper function and renames trunc , floor , and ceil to __trunc__ , __floor__ , and __ceil__ , respectively. Fixes sympy import issue resulting in AttributeError s being thrown on import in some environments. 0.1.1 Removes obsoleted \u2026SCT aliases. Corrects release notes which erroneously identified version 0.1.0 as 0.0.6. Adds enum.IntEnum , enum.IntFlag , and enum.Flag to testing. Merges SupportsFloor and SupportsCeil into SupportsFloorCeil . Gets rid of MANIFEST.in nonsense since we\u2019re not distributing sources via PyPI anymore. Adds a ton of examples to protocol docs. Better identifies false positives in tests. 0.1.0 Adds CachingProtocolMeta.includes , CachingProtocolMeta.excludes , and CachingProtocolMeta.reset_for cache override functions. Retires \u2026SCT tuples as unnecessary, especially in light of cache overrides. (Runtime isinstance protocol checking is fast enough.) For limited backward compatibility, they are now merely type aliases for similarly named protocols and will be removed in the next version. Updates docs. Custom runtime comparison implementation allows composition to lean on base types\u2019 caches. (\u26a0\ufe0f WARNING: Severe jank alert! \u26a0\ufe0f) 0.0.5 Updates license to the MIT License . Gets rid of self redundancy in __isinstance__ checks. 0.0.4 numerary finally leaves the dyce nest to become its own library! It didn\u2019t quite leave before because its maintainer is a bonehead who doesn\u2019t understand setuptools\u2019 multitude of oh-so-simple packaging mechanisms. No, it stuck around most weekends to do laundry while eating all of dyce \u2019s food. Now it has officially left the nest.","title":"Release notes"},{"location":"notes/#numerary-release-notes","text":"","title":"numerary release notes"},{"location":"notes/#041","text":"Minor corrections to required Python version.","title":"0.4.1"},{"location":"notes/#040","text":"Now relies on beartype . typing . Protocol as the underlying caching protocol implementation. This means that beartype has emerged as numerary \u2019s sole runtime dependency. ( numerary still layers on its own runtime override mechanism via CachingProtocolMeta , which derives from beartype \u2019s.) It also means that numerary loses Python 3.7 support, but that was largely illusory anyway. This decision was not made lightly. numerary is intended as a temporary work-around. It\u2019s obsolescence will be something to celebrate. Caching protocols, however, have much broader performance applications. They deserve more. beartype will provide what numerary was never meant to: a loving, stable, and permanent home.","title":"0.4.0"},{"location":"notes/#030","text":"Removes misleading advice that SCUs offer a performance benefit over merely using caching protocols. They could under very specific circumstances (where numerary probably isn\u2019t going to be helpful anyway), but not always, and probably aren\u2019t worth the trouble if performance is the only concern. Actually, removes SCUs altogether and documents a surgical example for those rare occasions where it might be needed. Finally removes SupportsNumeratorDenominatorProperties as promised.","title":"0.3.0"},{"location":"notes/#021","text":"Fixes trailing issues for sympy import issue resulting in ValueError s being thrown on import in some environments.","title":"0.2.1"},{"location":"notes/#020","text":"numerary goes beta! Splits SupportsRealImagAsMethod out of SupportsRealImag and provides the real and imag helper functions for better support of sympy \u2019s number primitives. Renames SupportsNumeratorDenominatorProperties to SupportsNumeratorDenominator to mirror SupportsRealImag and reflect that it captures the numeric tower interface. SupportsNumeratorDenominatorProperties and SupportsNumeratorDenominatorPropertiesSCU are maintained as aliases for limited backward compatibility and will be removed in the next version. Removes enum.Flag from testing as a non-sequitur. (It matches none of the presented protocols.) Introduces __pow__ helper function and renames trunc , floor , and ceil to __trunc__ , __floor__ , and __ceil__ , respectively. Fixes sympy import issue resulting in AttributeError s being thrown on import in some environments.","title":"0.2.0"},{"location":"notes/#011","text":"Removes obsoleted \u2026SCT aliases. Corrects release notes which erroneously identified version 0.1.0 as 0.0.6. Adds enum.IntEnum , enum.IntFlag , and enum.Flag to testing. Merges SupportsFloor and SupportsCeil into SupportsFloorCeil . Gets rid of MANIFEST.in nonsense since we\u2019re not distributing sources via PyPI anymore. Adds a ton of examples to protocol docs. Better identifies false positives in tests.","title":"0.1.1"},{"location":"notes/#010","text":"Adds CachingProtocolMeta.includes , CachingProtocolMeta.excludes , and CachingProtocolMeta.reset_for cache override functions. Retires \u2026SCT tuples as unnecessary, especially in light of cache overrides. (Runtime isinstance protocol checking is fast enough.) For limited backward compatibility, they are now merely type aliases for similarly named protocols and will be removed in the next version. Updates docs. Custom runtime comparison implementation allows composition to lean on base types\u2019 caches. (\u26a0\ufe0f WARNING: Severe jank alert! \u26a0\ufe0f)","title":"0.1.0"},{"location":"notes/#005","text":"Updates license to the MIT License . Gets rid of self redundancy in __isinstance__ checks.","title":"0.0.5"},{"location":"notes/#004","text":"numerary finally leaves the dyce nest to become its own library! It didn\u2019t quite leave before because its maintainer is a bonehead who doesn\u2019t understand setuptools\u2019 multitude of oh-so-simple packaging mechanisms. No, it stuck around most weekends to do laundry while eating all of dyce \u2019s food. Now it has officially left the nest.","title":"0.0.4"},{"location":"numerary/","text":"numerary package reference Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. These are composition protocols that should suit common use cases. IntegralLike Bases: SupportsAbs [ _T_co ] , SupportsFloat , SupportsIndex , SupportsInt , SupportsIntegralOps [ _T_co ] , SupportsIntegralPow , SupportsRealOps [ _T_co ] , SupportsComplexOps [ _T_co ] , Protocol , Generic [ _T_co ] A caching ABC that defines a core set of operations for interacting with integrals. It is a composition of: SupportsAbs SupportsFloat SupportsIndex SupportsInt SupportsIntegralOps SupportsIntegralPow SupportsRealOps SupportsComplexOps Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from beartype.typing import Protocol , TypeVar from numerary.types import CachingProtocolMeta , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class IntegralLike ( SupportsAbs [ T_co ], SupportsFloat , SupportsIndex , SupportsInt , SupportsIntegralOps [ T_co ], SupportsIntegralPow [ T_co ], SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): pass This is intended as a practically useful, but incomplete list. To enforce equivalence to numbers . Integral , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloorCeil SupportsDivmod SupportsNumeratorDenominator Source code in numerary/types.py 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 @runtime_checkable class IntegralLike ( SupportsAbs [ _T_co ], SupportsFloat , SupportsIndex , SupportsInt , SupportsIntegralOps [ _T_co ], SupportsIntegralPow , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC that defines a core set of operations for interacting with integrals. It is a composition of: * [``SupportsAbs``][numerary.types.SupportsAbs] * [``SupportsFloat``][numerary.types.SupportsFloat] * [``SupportsIndex``][numerary.types.SupportsIndex] * [``SupportsInt``][numerary.types.SupportsInt] * [``SupportsIntegralOps``][numerary.types.SupportsIntegralOps] * [``SupportsIntegralPow``][numerary.types.SupportsIntegralPow] * [``SupportsRealOps``][numerary.types.SupportsRealOps] * [``SupportsComplexOps``][numerary.types.SupportsComplexOps] Basically: ``` python from beartype.typing import Protocol, TypeVar from numerary.types import CachingProtocolMeta, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class IntegralLike( SupportsAbs[T_co], SupportsFloat, SupportsIndex, SupportsInt, SupportsIntegralOps[T_co], SupportsIntegralPow[T_co], SupportsRealOps[T_co], SupportsComplexOps[T_co], Protocol, Generic[_T_co], metaclass=CachingProtocolMeta, ): pass ``` This is intended as a practically useful, but incomplete list. To enforce equivalence to ``#!python numbers.Integral``, one would also need: * [``SupportsComplex``][numerary.types.SupportsComplex] * [``SupportsConjugate``][numerary.types.SupportsConjugate] * [``SupportsRealImag``][numerary.types.SupportsRealImag] * [``SupportsRound``][numerary.types.SupportsRound] * [``SupportsTrunc``][numerary.types.SupportsTrunc] * [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil] * [``SupportsDivmod``][numerary.types.SupportsDivmod] * [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator] \"\"\" # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass RealLike Bases: SupportsAbs [ _T_co ] , SupportsFloat , SupportsRealOps [ _T_co ] , SupportsComplexOps [ _T_co ] , SupportsComplexPow , Protocol , Generic [ _T_co ] A caching ABC that defines a core set of operations for interacting with reals. It is a composition of: SupportsAbs SupportsFloat SupportsRealOps SupportsComplexOps SupportsComplexPow Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from beartype.typing import Protocol , TypeVar from numerary.types import CachingProtocolMeta , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class RealLike ( SupportsAbs [ T_co ], SupportsFloat , SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], SupportsComplexPow [ T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): pass This is intended as a practically useful, but incomplete list. To enforce equivalence to numbers . Real , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloorCeil SupportsDivmod Source code in numerary/types.py 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 @runtime_checkable class RealLike ( SupportsAbs [ _T_co ], SupportsFloat , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], SupportsComplexPow , Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC that defines a core set of operations for interacting with reals. It is a composition of: * [``SupportsAbs``][numerary.types.SupportsAbs] * [``SupportsFloat``][numerary.types.SupportsFloat] * [``SupportsRealOps``][numerary.types.SupportsRealOps] * [``SupportsComplexOps``][numerary.types.SupportsComplexOps] * [``SupportsComplexPow``][numerary.types.SupportsComplexPow] Basically: ``` python from beartype.typing import Protocol, TypeVar from numerary.types import CachingProtocolMeta, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class RealLike( SupportsAbs[T_co], SupportsFloat, SupportsRealOps[T_co], SupportsComplexOps[T_co], SupportsComplexPow[T_co], Protocol, Generic[_T_co], metaclass=CachingProtocolMeta, ): pass ``` This is intended as a practically useful, but incomplete list. To enforce equivalence to ``#!python numbers.Real``, one would also need: * [``SupportsComplex``][numerary.types.SupportsComplex] * [``SupportsConjugate``][numerary.types.SupportsConjugate] * [``SupportsRealImag``][numerary.types.SupportsRealImag] * [``SupportsRound``][numerary.types.SupportsRound] * [``SupportsTrunc``][numerary.types.SupportsTrunc] * [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil] * [``SupportsDivmod``][numerary.types.SupportsDivmod] \"\"\" # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass","title":"<tt>numerary</tt>"},{"location":"numerary/#numerary-package-reference","text":"Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. These are composition protocols that should suit common use cases.","title":"numerary package reference"},{"location":"numerary/#numerary.types.IntegralLike","text":"Bases: SupportsAbs [ _T_co ] , SupportsFloat , SupportsIndex , SupportsInt , SupportsIntegralOps [ _T_co ] , SupportsIntegralPow , SupportsRealOps [ _T_co ] , SupportsComplexOps [ _T_co ] , Protocol , Generic [ _T_co ] A caching ABC that defines a core set of operations for interacting with integrals. It is a composition of: SupportsAbs SupportsFloat SupportsIndex SupportsInt SupportsIntegralOps SupportsIntegralPow SupportsRealOps SupportsComplexOps Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from beartype.typing import Protocol , TypeVar from numerary.types import CachingProtocolMeta , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class IntegralLike ( SupportsAbs [ T_co ], SupportsFloat , SupportsIndex , SupportsInt , SupportsIntegralOps [ T_co ], SupportsIntegralPow [ T_co ], SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): pass This is intended as a practically useful, but incomplete list. To enforce equivalence to numbers . Integral , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloorCeil SupportsDivmod SupportsNumeratorDenominator Source code in numerary/types.py 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 @runtime_checkable class IntegralLike ( SupportsAbs [ _T_co ], SupportsFloat , SupportsIndex , SupportsInt , SupportsIntegralOps [ _T_co ], SupportsIntegralPow , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC that defines a core set of operations for interacting with integrals. It is a composition of: * [``SupportsAbs``][numerary.types.SupportsAbs] * [``SupportsFloat``][numerary.types.SupportsFloat] * [``SupportsIndex``][numerary.types.SupportsIndex] * [``SupportsInt``][numerary.types.SupportsInt] * [``SupportsIntegralOps``][numerary.types.SupportsIntegralOps] * [``SupportsIntegralPow``][numerary.types.SupportsIntegralPow] * [``SupportsRealOps``][numerary.types.SupportsRealOps] * [``SupportsComplexOps``][numerary.types.SupportsComplexOps] Basically: ``` python from beartype.typing import Protocol, TypeVar from numerary.types import CachingProtocolMeta, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class IntegralLike( SupportsAbs[T_co], SupportsFloat, SupportsIndex, SupportsInt, SupportsIntegralOps[T_co], SupportsIntegralPow[T_co], SupportsRealOps[T_co], SupportsComplexOps[T_co], Protocol, Generic[_T_co], metaclass=CachingProtocolMeta, ): pass ``` This is intended as a practically useful, but incomplete list. To enforce equivalence to ``#!python numbers.Integral``, one would also need: * [``SupportsComplex``][numerary.types.SupportsComplex] * [``SupportsConjugate``][numerary.types.SupportsConjugate] * [``SupportsRealImag``][numerary.types.SupportsRealImag] * [``SupportsRound``][numerary.types.SupportsRound] * [``SupportsTrunc``][numerary.types.SupportsTrunc] * [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil] * [``SupportsDivmod``][numerary.types.SupportsDivmod] * [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator] \"\"\" # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass","title":"IntegralLike"},{"location":"numerary/#numerary.types.RealLike","text":"Bases: SupportsAbs [ _T_co ] , SupportsFloat , SupportsRealOps [ _T_co ] , SupportsComplexOps [ _T_co ] , SupportsComplexPow , Protocol , Generic [ _T_co ] A caching ABC that defines a core set of operations for interacting with reals. It is a composition of: SupportsAbs SupportsFloat SupportsRealOps SupportsComplexOps SupportsComplexPow Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from beartype.typing import Protocol , TypeVar from numerary.types import CachingProtocolMeta , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class RealLike ( SupportsAbs [ T_co ], SupportsFloat , SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], SupportsComplexPow [ T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): pass This is intended as a practically useful, but incomplete list. To enforce equivalence to numbers . Real , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloorCeil SupportsDivmod Source code in numerary/types.py 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 @runtime_checkable class RealLike ( SupportsAbs [ _T_co ], SupportsFloat , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], SupportsComplexPow , Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC that defines a core set of operations for interacting with reals. It is a composition of: * [``SupportsAbs``][numerary.types.SupportsAbs] * [``SupportsFloat``][numerary.types.SupportsFloat] * [``SupportsRealOps``][numerary.types.SupportsRealOps] * [``SupportsComplexOps``][numerary.types.SupportsComplexOps] * [``SupportsComplexPow``][numerary.types.SupportsComplexPow] Basically: ``` python from beartype.typing import Protocol, TypeVar from numerary.types import CachingProtocolMeta, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class RealLike( SupportsAbs[T_co], SupportsFloat, SupportsRealOps[T_co], SupportsComplexOps[T_co], SupportsComplexPow[T_co], Protocol, Generic[_T_co], metaclass=CachingProtocolMeta, ): pass ``` This is intended as a practically useful, but incomplete list. To enforce equivalence to ``#!python numbers.Real``, one would also need: * [``SupportsComplex``][numerary.types.SupportsComplex] * [``SupportsConjugate``][numerary.types.SupportsConjugate] * [``SupportsRealImag``][numerary.types.SupportsRealImag] * [``SupportsRound``][numerary.types.SupportsRound] * [``SupportsTrunc``][numerary.types.SupportsTrunc] * [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil] * [``SupportsDivmod``][numerary.types.SupportsDivmod] \"\"\" # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass","title":"RealLike"},{"location":"numerary.types/","text":"numerary . types package reference Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. numerary has donated its core caching protocol implementation to (and now depends on) beartype . beartype is awesome , and its author is even awesomer . 1 CachingProtocolMeta Bases: _BeartypeCachingProtocolMeta An extension of beartype . typing . Protocol that allows overriding runtime checks. Source code in numerary/_protocol.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class CachingProtocolMeta ( _BeartypeCachingProtocolMeta ): # TODO(posita): Add more precise link to beartype.typing.Protocol documentation once # it becomes available. r \"\"\" An extension of [``#!python beartype.typing.Protocol``](https://github.com/beartype/beartype) that allows overriding runtime checks. \"\"\" _abc_inst_check_cache_overridden : Dict [ Type , bool ] _abc_inst_check_cache_listeners : Set [ CachingProtocolMeta ] # Defined in beartype.typing.Protocol from which we inherit _abc_inst_check_cache : Dict [ type , bool ] def __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any , ) -> _TT : cls = super () . __new__ ( mcls , name , bases , namespace , ** kw ) # Prefixing this class member with \"_abc_\" is necessary to prevent it from being # considered part of the Protocol. (See # <https://github.com/python/cpython/blob/main/Lib/typing.py>.) cls . _abc_inst_check_cache_overridden = defaultdict ( bool ) # defaults to False cls . _abc_inst_check_cache_listeners = set () for base in bases : if hasattr ( base , \"_abc_inst_check_cache_listeners\" ): base . _abc_inst_check_cache_listeners . add ( cls ) return cls def includes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsSpam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def spam(self) -> str: ... pass >>> class NoSpam: ... pass >>> isinstance(NoSpam(), SupportsSpam) False >>> SupportsSpam.includes(NoSpam) >>> isinstance(NoSpam(), SupportsSpam) True ``` !!! note This does not affect static type-checking. ``` python >>> my_spam: SupportsSpam = NoSpam() # type: ignore [assignment] # still generates a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = True cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t ) def excludes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsHam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def ham(self) -> str: ... pass >>> class NoHam: ... def ham(self) -> str: ... raise NotImplementedError >>> isinstance(NoHam(), SupportsHam) True >>> SupportsHam.excludes(NoHam) >>> isinstance(NoHam(), SupportsHam) False ``` !!! note This does not affect static type-checking. ``` python >>> my_ham: SupportsHam = NoHam() # does *not* generate a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = False cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t ) def reset_for ( cls , inst_t : Type ) -> None : r \"\"\" Clears any cached instance check for *inst_t*. \"\"\" if inst_t in cls . _abc_inst_check_cache : del cls . _abc_inst_check_cache [ inst_t ] del cls . _abc_inst_check_cache_overridden [ inst_t ] cls . _dirty_for ( inst_t ) def _dirty_for ( cls , inst_t : Type ) -> None : for inheriting_cls in cls . _abc_inst_check_cache_listeners : if ( inst_t in inheriting_cls . _abc_inst_check_cache and not inheriting_cls . _abc_inst_check_cache_overridden [ inst_t ] ): del inheriting_cls . _abc_inst_check_cache [ inst_t ] del inheriting_cls . _abc_inst_check_cache_overridden [ inst_t ] excludes ( inst_t : Type ) -> None Registers inst_t as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsHam ( ... Protocol , ... metaclass = CachingProtocolMeta ... ): ... @abstractmethod ... def ham ( self ) -> str : ... pass >>> class NoHam : ... def ham ( self ) -> str : ... raise NotImplementedError >>> isinstance ( NoHam (), SupportsHam ) True >>> SupportsHam . excludes ( NoHam ) >>> isinstance ( NoHam (), SupportsHam ) False Note This does not affect static type-checking. 1 >>> my_ham : SupportsHam = NoHam () # does *not* generate a Mypy warning Source code in numerary/_protocol.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def excludes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsHam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def ham(self) -> str: ... pass >>> class NoHam: ... def ham(self) -> str: ... raise NotImplementedError >>> isinstance(NoHam(), SupportsHam) True >>> SupportsHam.excludes(NoHam) >>> isinstance(NoHam(), SupportsHam) False ``` !!! note This does not affect static type-checking. ``` python >>> my_ham: SupportsHam = NoHam() # does *not* generate a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = False cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t ) includes ( inst_t : Type ) -> None Registers inst_t as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsSpam ( ... Protocol , ... metaclass = CachingProtocolMeta ... ): ... @abstractmethod ... def spam ( self ) -> str : ... pass >>> class NoSpam : ... pass >>> isinstance ( NoSpam (), SupportsSpam ) False >>> SupportsSpam . includes ( NoSpam ) >>> isinstance ( NoSpam (), SupportsSpam ) True Note This does not affect static type-checking. 1 >>> my_spam : SupportsSpam = NoSpam () # type: ignore [assignment] # still generates a Mypy warning Source code in numerary/_protocol.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def includes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsSpam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def spam(self) -> str: ... pass >>> class NoSpam: ... pass >>> isinstance(NoSpam(), SupportsSpam) False >>> SupportsSpam.includes(NoSpam) >>> isinstance(NoSpam(), SupportsSpam) True ``` !!! note This does not affect static type-checking. ``` python >>> my_spam: SupportsSpam = NoSpam() # type: ignore [assignment] # still generates a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = True cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t ) reset_for ( inst_t : Type ) -> None Clears any cached instance check for inst_t . Source code in numerary/_protocol.py 156 157 158 159 160 161 162 163 def reset_for ( cls , inst_t : Type ) -> None : r \"\"\" Clears any cached instance check for *inst_t*. \"\"\" if inst_t in cls . _abc_inst_check_cache : del cls . _abc_inst_check_cache [ inst_t ] del cls . _abc_inst_check_cache_overridden [ inst_t ] cls . _dirty_for ( inst_t ) RationalLike Bases: SupportsAbs [ _T_co ] , SupportsFloat , SupportsNumeratorDenominator , SupportsRealOps [ _T_co ] , SupportsComplexOps [ _T_co ] , SupportsComplexPow , Protocol , Generic [ _T_co ] A caching ABC that defines a core set of operations for interacting with rationals. It is a composition of: SupportsAbs SupportsFloat SupportsNumeratorDenominator SupportsRealOps SupportsComplexOps SupportsComplexPow Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from beartype.typing import Protocol , TypeVar from numerary.types import CachingProtocolMeta , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class RationalLike ( SupportsAbs [ T_co ], SupportsFloat , SupportsNumeratorDenominator , SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], SupportsComplexPow [ T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): pass This is intended as a practically useful, but incomplete list. To enforce equivalence to numbers . Rational , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloorCeil SupportsDivmod Source code in numerary/types.py 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 @runtime_checkable class RationalLike ( SupportsAbs [ _T_co ], SupportsFloat , SupportsNumeratorDenominator , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], SupportsComplexPow , Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC that defines a core set of operations for interacting with rationals. It is a composition of: * [``SupportsAbs``][numerary.types.SupportsAbs] * [``SupportsFloat``][numerary.types.SupportsFloat] * [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator] * [``SupportsRealOps``][numerary.types.SupportsRealOps] * [``SupportsComplexOps``][numerary.types.SupportsComplexOps] * [``SupportsComplexPow``][numerary.types.SupportsComplexPow] Basically: ``` python from beartype.typing import Protocol, TypeVar from numerary.types import CachingProtocolMeta, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class RationalLike( SupportsAbs[T_co], SupportsFloat, SupportsNumeratorDenominator, SupportsRealOps[T_co], SupportsComplexOps[T_co], SupportsComplexPow[T_co], Protocol, Generic[_T_co], metaclass=CachingProtocolMeta, ): pass ``` This is intended as a practically useful, but incomplete list. To enforce equivalence to ``#!python numbers.Rational``, one would also need: * [``SupportsComplex``][numerary.types.SupportsComplex] * [``SupportsConjugate``][numerary.types.SupportsConjugate] * [``SupportsRealImag``][numerary.types.SupportsRealImag] * [``SupportsRound``][numerary.types.SupportsRound] * [``SupportsTrunc``][numerary.types.SupportsTrunc] * [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil] * [``SupportsDivmod``][numerary.types.SupportsDivmod] \"\"\" # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass RationalLikeMethods Bases: SupportsAbs [ _T_co ] , SupportsFloat , SupportsNumeratorDenominatorMethods , SupportsRealOps [ _T_co ] , SupportsComplexOps [ _T_co ] , SupportsComplexPow , Protocol , Generic [ _T_co ] A caching ABC that defines a core set of operations for interacting with rationals. It is identical to RationalLike with one important exception. Instead of SupportsNumeratorDenominator , this protocol provides SupportsNumeratorDenominatorMethods . Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from beartype.typing import Protocol , TypeVar from numerary.types import CachingProtocolMeta , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class RationalLikeMethods ( SupportsAbs [ T_co ], SupportsFloat , SupportsNumeratorDenominatorMethods , SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], SupportsComplexPow [ T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): pass This is probably not very useful on its own, but is important to the construction of RationalLikeMixedU and RationalLikeMixedT . See also the numerator and denominator helper functions. Source code in numerary/types.py 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 @runtime_checkable class RationalLikeMethods ( SupportsAbs [ _T_co ], SupportsFloat , SupportsNumeratorDenominatorMethods , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], SupportsComplexPow , Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC that defines a core set of operations for interacting with rationals. It is identical to [``RationalLike``][numerary.types.RationalLike] with one important exception. Instead of [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator], this protocol provides [``SupportsNumeratorDenominatorMethods``][numerary.types.SupportsNumeratorDenominatorMethods]. Basically: ``` python from beartype.typing import Protocol, TypeVar from numerary.types import CachingProtocolMeta, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class RationalLikeMethods( SupportsAbs[T_co], SupportsFloat, SupportsNumeratorDenominatorMethods, SupportsRealOps[T_co], SupportsComplexOps[T_co], SupportsComplexPow[T_co], Protocol, Generic[_T_co], metaclass=CachingProtocolMeta, ): pass ``` This is probably not very useful on its own, but is important to the construction of [``RationalLikeMixedU``][numerary.types.RationalLikeMixedU] and [``RationalLikeMixedT``][numerary.types.RationalLikeMixedT]. See also the [``numerator``][numerary.types.numerator] and [``denominator``][numerary.types.denominator] helper functions. \"\"\" # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass SupportsAbs Bases: _SupportsAbs [ _T_co ] , Protocol , Generic [ _T_co ] A derivative of beartype.typing.SupportsAbs with an override-able cache. Source code in numerary/types.py 68 69 70 71 72 73 74 75 76 77 @runtime_checkable class SupportsAbs ( _SupportsAbs [ _T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A derivative of ``beartype.typing.SupportsAbs`` with an override-able cache. \"\"\" SupportsComplex Bases: _SupportsComplex , Protocol A derivative of beartype.typing.SupportsComplex with an override-able cache. Source code in numerary/types.py 83 84 85 86 87 88 89 90 91 @runtime_checkable class SupportsComplex ( _SupportsComplex , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A derivative of ``beartype.typing.SupportsComplex`` with an override-able cache. \"\"\" SupportsFloat Bases: _SupportsFloat , Protocol A derivative of beartype.typing.SupportsFloat with an override-able cache. Source code in numerary/types.py 97 98 99 100 101 102 103 104 105 @runtime_checkable class SupportsFloat ( _SupportsFloat , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A derivative of ``beartype.typing.SupportsFloat`` with an override-able cache. \"\"\" SupportsInt Bases: _SupportsInt , Protocol A derivative of beartype.typing.SupportsInt with an override-able cache. Source code in numerary/types.py 111 112 113 114 115 116 117 118 119 @runtime_checkable class SupportsInt ( _SupportsInt , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A derivative of ``beartype.typing.SupportsInt`` with an override-able cache. \"\"\" SupportsIndex Bases: _SupportsIndex , Protocol A derivative of beartype.typing.SupportsIndex with an override-able cache. Source code in numerary/types.py 125 126 127 128 129 130 131 132 133 @runtime_checkable class SupportsIndex ( _SupportsIndex , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A derivative of ``beartype.typing.SupportsIndex`` with an override-able cache. \"\"\" SupportsRound Bases: _SupportsRound [ _T_co ] , Protocol , Generic [ _T_co ] A derivative of beartype.typing.SupportsRound with an override-able cache. Source code in numerary/types.py 139 140 141 142 143 144 145 146 147 148 @runtime_checkable class SupportsRound ( _SupportsRound [ _T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A derivative of ``beartype.typing.SupportsRound`` with an override-able cache. \"\"\" SupportsConjugate Bases: _SupportsConjugate , Protocol A caching ABC defining the conjugate method . ( _SupportsConjugate is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import TypeVar >>> from numerary.types import SupportsConjugate >>> MyConjugateT = TypeVar ( \"MyConjugateT\" , bound = SupportsConjugate ) >>> def conjugate_my_thing ( arg : MyConjugateT ) -> MyConjugateT : ... assert isinstance ( arg , SupportsConjugate ) ... return arg . conjugate () >>> conjugate_my_thing ( 3 ) 3 >>> from decimal import Decimal >>> conjugate_my_thing ( Decimal ( 2.5 )) Decimal ( '2.5' ) >>> import sympy >>> conjugate_my_thing ( sympy . Float ( 3.5 )) 3.5 >>> type ( _ ) < class ' sympy . core . numbers . Float '> >>> # error: Value of type variable \"MyConjugateT\" of \"conjugate_my_thing\" cannot be \"str\" >>> conjugate_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 @runtime_checkable class SupportsConjugate ( _SupportsConjugate , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``conjugate`` method](https://docs.python.org/3/library/numbers.html#numbers.Complex.conjugate). ([``_SupportsConjugate``][numerary.types._SupportsConjugate] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import TypeVar >>> from numerary.types import SupportsConjugate >>> MyConjugateT = TypeVar(\"MyConjugateT\", bound=SupportsConjugate) >>> def conjugate_my_thing(arg: MyConjugateT) -> MyConjugateT: ... assert isinstance(arg, SupportsConjugate) ... return arg.conjugate() >>> conjugate_my_thing(3) 3 >>> from decimal import Decimal >>> conjugate_my_thing(Decimal(2.5)) Decimal('2.5') >>> import sympy >>> conjugate_my_thing(sympy.Float(3.5)) 3.5 >>> type(_) <class 'sympy.core.numbers.Float'> >>> # error: Value of type variable \"MyConjugateT\" of \"conjugate_my_thing\" cannot be \"str\" >>> conjugate_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" SupportsRealImag Bases: _SupportsRealImag , Protocol A caching ABC defining the real and imag properties. ( _SupportsRealImag is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsRealImag , real , imag >>> MyRealImagT = TypeVar ( \"MyRealImagT\" , bound = SupportsRealImag ) >>> def real_imag_my_thing ( arg : MyRealImagT ) -> Tuple [ Any , Any ]: ... assert isinstance ( arg , SupportsRealImag ) ... return ( real ( arg ), imag ( arg )) >>> real_imag_my_thing ( 3 ) ( 3 , 0 ) >>> from decimal import Decimal >>> real_imag_my_thing ( Decimal ( 2.5 )) ( Decimal ( '2.5' ), Decimal ( '0' )) >>> # error: Value of type variable \"MyRealImagT\" of \"real_imag_my_thing\" cannot be \"str\" >>> real_imag_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @runtime_checkable class SupportsRealImag ( _SupportsRealImag , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``real``](https://docs.python.org/3/library/numbers.html#numbers.Complex.real) and [``imag``](https://docs.python.org/3/library/numbers.html#numbers.Complex.imag) properties. ([``_SupportsRealImag``][numerary.types._SupportsRealImag] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsRealImag, real, imag >>> MyRealImagT = TypeVar(\"MyRealImagT\", bound=SupportsRealImag) >>> def real_imag_my_thing(arg: MyRealImagT) -> Tuple[Any, Any]: ... assert isinstance(arg, SupportsRealImag) ... return (real(arg), imag(arg)) >>> real_imag_my_thing(3) (3, 0) >>> from decimal import Decimal >>> real_imag_my_thing(Decimal(2.5)) (Decimal('2.5'), Decimal('0')) >>> # error: Value of type variable \"MyRealImagT\" of \"real_imag_my_thing\" cannot be \"str\" >>> real_imag_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" SupportsRealImagAsMethod Bases: _SupportsRealImagAsMethod , Protocol A caching ABC defining the as_real_imag method that returns a 2-tuple. ( _SupportsRealImagAsMethod is the raw, non-caching version that defines the actual methods.) See also the real and imag helper functions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsRealImagAsMethod , real , imag >>> MyRealImagAsMethodT = TypeVar ( \"MyRealImagAsMethodT\" , bound = SupportsRealImagAsMethod ) >>> def as_real_imag_my_thing ( arg : MyRealImagAsMethodT ) -> Tuple [ Any , Any ]: ... assert isinstance ( arg , SupportsRealImagAsMethod ) ... return ( real ( arg ), imag ( arg )) >>> as_real_imag_my_thing ( sympy . Float ( 3.5 )) ( 3.5 , 0 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' sympy . core . numbers . Float '>, <class ' sympy . core . numbers . Zero '>) >>> # error: Value of type variable \"MyRealImagAsMethodT\" of \"as_real_imag_my_thing\" cannot be \"str\" >>> as_real_imag_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 @runtime_checkable class SupportsRealImagAsMethod ( _SupportsRealImagAsMethod , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the ``#!python as_real_imag`` method that returns a 2-tuple. ([``_SupportsRealImagAsMethod``][numerary.types._SupportsRealImagAsMethod] is the raw, non-caching version that defines the actual methods.) See also the [``real``][numerary.types.real] and [``imag``][numerary.types.imag] helper functions. ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsRealImagAsMethod, real, imag >>> MyRealImagAsMethodT = TypeVar(\"MyRealImagAsMethodT\", bound=SupportsRealImagAsMethod) >>> def as_real_imag_my_thing(arg: MyRealImagAsMethodT) -> Tuple[Any, Any]: ... assert isinstance(arg, SupportsRealImagAsMethod) ... return (real(arg), imag(arg)) >>> as_real_imag_my_thing(sympy.Float(3.5)) (3.5, 0) >>> tuple(type(i) for i in _) (<class 'sympy.core.numbers.Float'>, <class 'sympy.core.numbers.Zero'>) >>> # error: Value of type variable \"MyRealImagAsMethodT\" of \"as_real_imag_my_thing\" cannot be \"str\" >>> as_real_imag_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" SupportsTrunc Bases: _SupportsTrunc , Protocol A caching ABC defining the __trunc__ method . See also the __trunc__ helper function . ( _SupportsTrunc is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsTrunc , __trunc__ >>> MyTruncT = TypeVar ( \"MyTruncT\" , bound = SupportsTrunc ) >>> def trunc_my_thing ( arg : MyTruncT ) -> Tuple [ Any , Any ]: ... assert isinstance ( arg , SupportsTrunc ) ... return __trunc__ ( arg ) >>> trunc_my_thing ( 3 ) 3 >>> from decimal import Decimal >>> trunc_my_thing ( Decimal ( 2.5 )) 2 >>> import sympy >>> trunc_my_thing ( sympy . Float ( 3.5 )) 3 >>> type ( _ ) < class ' sympy . core . numbers . Integer '> >>> # error: Value of type variable \"MyTruncT\" of \"trunc_my_thing\" cannot be \"str\" >>> trunc_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 @runtime_checkable class SupportsTrunc ( _SupportsTrunc , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``__trunc__`` method](https://docs.python.org/3/reference/datamodel.html#object.__trunc__). See also the [``__trunc__`` helper function][numerary.types.__trunc__]. ([``_SupportsTrunc``][numerary.types._SupportsTrunc] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsTrunc, __trunc__ >>> MyTruncT = TypeVar(\"MyTruncT\", bound=SupportsTrunc) >>> def trunc_my_thing(arg: MyTruncT) -> Tuple[Any, Any]: ... assert isinstance(arg, SupportsTrunc) ... return __trunc__(arg) >>> trunc_my_thing(3) 3 >>> from decimal import Decimal >>> trunc_my_thing(Decimal(2.5)) 2 >>> import sympy >>> trunc_my_thing(sympy.Float(3.5)) 3 >>> type(_) <class 'sympy.core.numbers.Integer'> >>> # error: Value of type variable \"MyTruncT\" of \"trunc_my_thing\" cannot be \"str\" >>> trunc_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" SupportsFloorCeil Bases: _SupportsFloorCeil , Protocol A caching ABC defining the __floor__ . and __ceil__ methods. ( _SupportsFloorCeil is the raw, non-caching version that defines the actual methods.) Note This is of limited value for Python versions prior to 3.9, since float . __floor__ and float . __ceil__ were not defined. If support for those environments is important, consider using SupportsFloat instead. See also the __floor__ and __ceil__ helper functions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsFloorCeil , __ceil__ , __floor__ >>> MyFloorCeilT = TypeVar ( \"MyFloorCeilT\" , bound = SupportsFloorCeil ) >>> def floor_ceil_my_thing ( arg : MyFloorCeilT ) -> Tuple [ int , int ]: ... assert isinstance ( arg , SupportsFloorCeil ) ... return __floor__ ( arg ), __ceil__ ( arg ) >>> floor_ceil_my_thing ( 3 ) ( 3 , 3 ) >>> from decimal import Decimal >>> floor_ceil_my_thing ( Decimal ( 2.5 )) ( 2 , 3 ) >>> import sympy >>> floor_ceil_my_thing ( sympy . Float ( 3.5 )) ( 3 , 4 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' sympy . core . numbers . Integer '>, <class ' sympy . core . numbers . Integer '>) >>> # error: Value of type variable \"MyFloorCeilT\" of \"floor_ceil_my_thing\" cannot be \"str\" >>> floor_ceil_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 @runtime_checkable class SupportsFloorCeil ( _SupportsFloorCeil , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``__floor__``](https://docs.python.org/3/reference/datamodel.html#object.__floor__). and [``__ceil__``](https://docs.python.org/3/reference/datamodel.html#object.__ceil__) methods. ([``_SupportsFloorCeil``][numerary.types._SupportsFloorCeil] is the raw, non-caching version that defines the actual methods.) !!! note This is of limited value for Python versions prior to 3.9, since ``#!python float.__floor__`` and ``#!python float.__ceil__`` were not defined. If support for those environments is important, consider using [``SupportsFloat``][numerary.types.SupportsFloat] instead. See also the [``__floor__``][numerary.types.__floor__] and [``__ceil__``][numerary.types.__ceil__] helper functions. ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsFloorCeil, __ceil__, __floor__ >>> MyFloorCeilT = TypeVar(\"MyFloorCeilT\", bound=SupportsFloorCeil) >>> def floor_ceil_my_thing(arg: MyFloorCeilT) -> Tuple[int, int]: ... assert isinstance(arg, SupportsFloorCeil) ... return __floor__(arg), __ceil__(arg) >>> floor_ceil_my_thing(3) (3, 3) >>> from decimal import Decimal >>> floor_ceil_my_thing(Decimal(2.5)) (2, 3) >>> import sympy >>> floor_ceil_my_thing(sympy.Float(3.5)) (3, 4) >>> tuple(type(i) for i in _) (<class 'sympy.core.numbers.Integer'>, <class 'sympy.core.numbers.Integer'>) >>> # error: Value of type variable \"MyFloorCeilT\" of \"floor_ceil_my_thing\" cannot be \"str\" >>> floor_ceil_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" SupportsDivmod Bases: _SupportsDivmod [ _T_co ] , Protocol , Generic [ _T_co ] A caching ABC defining the __divmod__ and __rdivmod__ methods. Each returns a 2-tuple of covariants. ( _SupportsDivmod is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsDivmod >>> MyDivmodT = TypeVar ( \"MyDivmodT\" , bound = SupportsDivmod ) >>> def divmod_my_thing ( arg : MyDivmodT , other : Any ) -> Tuple [ MyDivmodT , MyDivmodT ]: ... assert isinstance ( arg , SupportsDivmod ) ... return divmod ( arg , other ) >>> divmod_my_thing ( 2 , 1 ) ( 2 , 0 ) >>> from decimal import Decimal >>> divmod_my_thing ( Decimal ( 2.5 ), Decimal ( 1.5 )) ( Decimal ( '1' ), Decimal ( '1.0' )) >>> import sympy >>> divmod_my_thing ( sympy . Float ( 3.5 ), sympy . Float ( 1.5 )) ( 2 , 0.5 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' sympy . core . numbers . Integer '>, <class ' sympy . core . numbers . Float '>) >>> # error: Value of type variable \"MyDivmodT\" of \"divmod_my_thing\" cannot be \"str\" >>> divmod_my_thing ( \"not-a-number\" , \"still-not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 @runtime_checkable class SupportsDivmod ( _SupportsDivmod [ _T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``__divmod__``](https://docs.python.org/3/reference/datamodel.html#object.__divmod__) and [``__rdivmod__``](https://docs.python.org/3/reference/datamodel.html#object.__rdivmod__) methods. Each returns a 2-tuple of covariants. ([``_SupportsDivmod``][numerary.types._SupportsDivmod] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsDivmod >>> MyDivmodT = TypeVar(\"MyDivmodT\", bound=SupportsDivmod) >>> def divmod_my_thing(arg: MyDivmodT, other: Any) -> Tuple[MyDivmodT, MyDivmodT]: ... assert isinstance(arg, SupportsDivmod) ... return divmod(arg, other) >>> divmod_my_thing(2, 1) (2, 0) >>> from decimal import Decimal >>> divmod_my_thing(Decimal(2.5), Decimal(1.5)) (Decimal('1'), Decimal('1.0')) >>> import sympy >>> divmod_my_thing(sympy.Float(3.5), sympy.Float(1.5)) (2, 0.5) >>> tuple(type(i) for i in _) (<class 'sympy.core.numbers.Integer'>, <class 'sympy.core.numbers.Float'>) >>> # error: Value of type variable \"MyDivmodT\" of \"divmod_my_thing\" cannot be \"str\" >>> divmod_my_thing(\"not-a-number\", \"still-not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" SupportsNumeratorDenominator Bases: _SupportsNumeratorDenominator , Protocol A caching ABC defining the numerator and denominator properties. ( _SupportsNumeratorDenominator is the raw, non-caching version that defines the actual properties.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsNumeratorDenominator , denominator , numerator >>> MyNumDenomT = TypeVar ( \"MyNumDenomT\" , bound = SupportsNumeratorDenominator ) >>> def num_denom_my_thing ( arg : MyNumDenomT ) -> Tuple [ int , int ]: ... assert isinstance ( arg , SupportsNumeratorDenominator ) ... return numerator ( arg ), denominator ( arg ) >>> num_denom_my_thing ( 3 ) ( 3 , 1 ) >>> from fractions import Fraction >>> num_denom_my_thing ( Fraction ( 2 , 3 )) ( 2 , 3 ) >>> import sympy >>> num_denom_my_thing ( sympy . Rational ( 3 , 4 )) ( 3 , 4 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' int '>, <class ' int '>) >>> # error: Value of type variable \"MyNumDenomT\" of \"num_denom_my_thing\" cannot be \"str\" >>> num_denom_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 @runtime_checkable class SupportsNumeratorDenominator ( _SupportsNumeratorDenominator , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``numerator``](https://docs.python.org/3/library/numbers.html#numbers.Rational.numerator) and [``denominator``](https://docs.python.org/3/library/numbers.html#numbers.Rational.denominator) properties. ([``_SupportsNumeratorDenominator``][numerary.types._SupportsNumeratorDenominator] is the raw, non-caching version that defines the actual properties.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsNumeratorDenominator, denominator, numerator >>> MyNumDenomT = TypeVar(\"MyNumDenomT\", bound=SupportsNumeratorDenominator) >>> def num_denom_my_thing(arg: MyNumDenomT) -> Tuple[int, int]: ... assert isinstance(arg, SupportsNumeratorDenominator) ... return numerator(arg), denominator(arg) >>> num_denom_my_thing(3) (3, 1) >>> from fractions import Fraction >>> num_denom_my_thing(Fraction(2, 3)) (2, 3) >>> import sympy >>> num_denom_my_thing(sympy.Rational(3, 4)) (3, 4) >>> tuple(type(i) for i in _) (<class 'int'>, <class 'int'>) >>> # error: Value of type variable \"MyNumDenomT\" of \"num_denom_my_thing\" cannot be \"str\" >>> num_denom_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" SupportsNumeratorDenominatorMethods Bases: _SupportsNumeratorDenominatorMethods , Protocol A caching ABC defining numerator and denominator methods. Each returns a SupportsInt . ( _SupportsNumeratorDenominatorMethods is the raw, non-caching version that defines the actual methods.) See also the numerator and denominator helper functions. Source code in numerary/types.py 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 @runtime_checkable class SupportsNumeratorDenominatorMethods ( _SupportsNumeratorDenominatorMethods , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining ``#!python numerator`` and ``#!python denominator`` methods. Each returns a [``SupportsInt``][numerary.types.SupportsInt]. ([``_SupportsNumeratorDenominatorMethods``][numerary.types._SupportsNumeratorDenominatorMethods] is the raw, non-caching version that defines the actual methods.) See also the [``numerator``][numerary.types.numerator] and [``denominator``][numerary.types.denominator] helper functions. \"\"\" SupportsComplexOps Bases: _SupportsComplexOps [ _T_co ] , Protocol , Generic [ _T_co ] A caching ABC defining the Complex operator methods with covariant return values. ( _SupportsComplexOps is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsComplexOps >>> MyComplexOpsT = TypeVar ( \"MyComplexOpsT\" , bound = SupportsComplexOps ) >>> def complex_ops_my_thing ( arg : MyComplexOpsT ) -> MyComplexOpsT : ... assert isinstance ( arg , SupportsComplexOps ) ... return arg * - 2 + 5 >>> complex_ops_my_thing ( 3 ) - 1 >>> from decimal import Decimal >>> complex_ops_my_thing ( Decimal ( \"2.5\" )) Decimal ( '0.0' ) >>> import sympy >>> complex_ops_my_thing ( sympy . Float ( 3.5 )) - 2.0 >>> type ( _ ) < class ' sympy . core . numbers . Float '> >>> # error: Value of type variable \"MyComplexOpsT\" of \"complex_ops_my_thing\" cannot be \"str\" >>> complex_ops_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 @runtime_checkable class SupportsComplexOps ( _SupportsComplexOps [ _T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``Complex`` operator methods](https://docs.python.org/3/library/numbers.html#numbers.Complex) with covariant return values. ([``_SupportsComplexOps``][numerary.types._SupportsComplexOps] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsComplexOps >>> MyComplexOpsT = TypeVar(\"MyComplexOpsT\", bound=SupportsComplexOps) >>> def complex_ops_my_thing(arg: MyComplexOpsT) -> MyComplexOpsT: ... assert isinstance(arg, SupportsComplexOps) ... return arg * -2 + 5 >>> complex_ops_my_thing(3) -1 >>> from decimal import Decimal >>> complex_ops_my_thing(Decimal(\"2.5\")) Decimal('0.0') >>> import sympy >>> complex_ops_my_thing(sympy.Float(3.5)) -2.0 >>> type(_) <class 'sympy.core.numbers.Float'> >>> # error: Value of type variable \"MyComplexOpsT\" of \"complex_ops_my_thing\" cannot be \"str\" >>> complex_ops_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" SupportsComplexPow Bases: _SupportsComplexPow , Protocol A caching ABC defining the Complex (i.e., non-modulo) versions of the __pow__ and __rpow__ . ( _SupportsComplexPow is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsComplexPow >>> MyComplexPowT = TypeVar ( \"MyComplexPowT\" , bound = SupportsComplexPow ) >>> def complex_pow_my_thing ( arg : MyComplexPowT ) -> MyComplexPowT : ... assert isinstance ( arg , SupportsComplexPow ) ... return arg ** - 2 >>> complex_pow_my_thing ( 3 ) 0.1111111111111111 >>> from decimal import Decimal >>> complex_pow_my_thing ( Decimal ( \"2.5\" )) Decimal ( '0.16' ) >>> import sympy >>> complex_pow_my_thing ( sympy . Float ( 3.5 )) 0.0816326530612245 >>> type ( _ ) < class ' sympy . core . numbers . Float '> >>> # error: Value of type variable \"MyComplexPowT\" of \"complex_pow_my_thing\" cannot be \"str\" >>> complex_pow_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 @runtime_checkable class SupportsComplexPow ( _SupportsComplexPow , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the ``#!python Complex`` (i.e., non-modulo) versions of the [``__pow__``](https://docs.python.org/3/reference/datamodel.html#object.__pow__) and [``__rpow__``](https://docs.python.org/3/reference/datamodel.html#object.__rpow__). ([``_SupportsComplexPow``][numerary.types._SupportsComplexPow] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsComplexPow >>> MyComplexPowT = TypeVar(\"MyComplexPowT\", bound=SupportsComplexPow) >>> def complex_pow_my_thing(arg: MyComplexPowT) -> MyComplexPowT: ... assert isinstance(arg, SupportsComplexPow) ... return arg ** -2 >>> complex_pow_my_thing(3) 0.1111111111111111 >>> from decimal import Decimal >>> complex_pow_my_thing(Decimal(\"2.5\")) Decimal('0.16') >>> import sympy >>> complex_pow_my_thing(sympy.Float(3.5)) 0.0816326530612245 >>> type(_) <class 'sympy.core.numbers.Float'> >>> # error: Value of type variable \"MyComplexPowT\" of \"complex_pow_my_thing\" cannot be \"str\" >>> complex_pow_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" SupportsRealOps Bases: _SupportsRealOps [ _T_co ] , Protocol , Generic [ _T_co ] A caching ABC defining the Real operator methods with covariant return values. ( _SupportsRealOps is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsRealOps >>> MyRealOpsT = TypeVar ( \"MyRealOpsT\" , bound = SupportsRealOps ) >>> def real_ops_my_thing ( arg : MyRealOpsT ) -> Any : ... assert isinstance ( arg , SupportsRealOps ) ... return arg // - 2 >>> real_ops_my_thing ( 3 ) - 2 >>> from decimal import Decimal >>> real_ops_my_thing ( Decimal ( \"2.5\" )) Decimal ( '-1' ) >>> import sympy >>> real_ops_my_thing ( sympy . Float ( 3.5 )) - 2 >>> type ( _ ) < class ' sympy . core . numbers . Integer '> >>> # error: Value of type variable \"MyRealOpsT\" of \"real_ops_my_thing\" cannot be \"str\" >>> real_ops_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 @runtime_checkable class SupportsRealOps ( _SupportsRealOps [ _T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``Real`` operator methods](https://docs.python.org/3/library/numbers.html#numbers.Real) with covariant return values. ([``_SupportsRealOps``][numerary.types._SupportsRealOps] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsRealOps >>> MyRealOpsT = TypeVar(\"MyRealOpsT\", bound=SupportsRealOps) >>> def real_ops_my_thing(arg: MyRealOpsT) -> Any: ... assert isinstance(arg, SupportsRealOps) ... return arg // -2 >>> real_ops_my_thing(3) -2 >>> from decimal import Decimal >>> real_ops_my_thing(Decimal(\"2.5\")) Decimal('-1') >>> import sympy >>> real_ops_my_thing(sympy.Float(3.5)) -2 >>> type(_) <class 'sympy.core.numbers.Integer'> >>> # error: Value of type variable \"MyRealOpsT\" of \"real_ops_my_thing\" cannot be \"str\" >>> real_ops_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" SupportsIntegralOps Bases: _SupportsIntegralOps [ _T_co ] , Protocol , Generic [ _T_co ] A caching ABC defining the Integral operator methods with covariant return values. ( _SupportsIntegralOps is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsIntegralOps >>> MyIntegralOpsT = TypeVar ( \"MyIntegralOpsT\" , bound = SupportsIntegralOps ) >>> def integral_ops_my_thing ( arg : MyIntegralOpsT ) -> MyIntegralOpsT : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg << 1 >>> integral_ops_my_thing ( 3 ) 6 >>> import sympy >>> integral_ops_my_thing ( sympy . Integer ( 3 )) 6 >>> type ( _ ) < class ' sympy . core . numbers . Integer '> >>> # error: Value of type variable \"MyIntegralOpsT\" of \"integral_ops_my_thing\" cannot be \"str\" >>> integral_ops_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 @runtime_checkable class SupportsIntegralOps ( _SupportsIntegralOps [ _T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``Integral`` operator methods](https://docs.python.org/3/library/numbers.html#numbers.Integral) with covariant return values. ([``_SupportsIntegralOps``][numerary.types._SupportsIntegralOps] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsIntegralOps >>> MyIntegralOpsT = TypeVar(\"MyIntegralOpsT\", bound=SupportsIntegralOps) >>> def integral_ops_my_thing(arg: MyIntegralOpsT) -> MyIntegralOpsT: ... assert isinstance(arg, SupportsIntegralOps) ... return arg << 1 >>> integral_ops_my_thing(3) 6 >>> import sympy >>> integral_ops_my_thing(sympy.Integer(3)) 6 >>> type(_) <class 'sympy.core.numbers.Integer'> >>> # error: Value of type variable \"MyIntegralOpsT\" of \"integral_ops_my_thing\" cannot be \"str\" >>> integral_ops_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" SupportsIntegralPow Bases: _SupportsIntegralPow , Protocol A caching ABC defining the Integral (i.e., modulo) versions of the __pow__ and __rpow__ methods. ( _SupportsIntegralPow is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsIntegralPow >>> MyIntegralPowT = TypeVar ( \"MyIntegralPowT\" , bound = SupportsIntegralPow ) >>> def integral_pow_my_thing ( arg : MyIntegralPowT ) -> MyIntegralPowT : ... assert isinstance ( arg , SupportsIntegralPow ) ... return pow ( arg , 2 , 2 ) >>> integral_pow_my_thing ( 3 ) 1 >>> import sympy >>> integral_pow_my_thing ( sympy . Integer ( 3 )) 1 >>> type ( _ ) < class ' int '> >>> # error: Value of type variable \"MyIntegralPowT\" of \"integral_pow_my_thing\" cannot be \"str\" >>> integral_pow_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 @runtime_checkable class SupportsIntegralPow ( _SupportsIntegralPow , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the ``#!python Integral`` (i.e., modulo) versions of the [``__pow__``](https://docs.python.org/3/reference/datamodel.html#object.__pow__) and [``__rpow__``](https://docs.python.org/3/reference/datamodel.html#object.__rpow__) methods. ([``_SupportsIntegralPow``][numerary.types._SupportsIntegralPow] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsIntegralPow >>> MyIntegralPowT = TypeVar(\"MyIntegralPowT\", bound=SupportsIntegralPow) >>> def integral_pow_my_thing(arg: MyIntegralPowT) -> MyIntegralPowT: ... assert isinstance(arg, SupportsIntegralPow) ... return pow(arg, 2, 2) >>> integral_pow_my_thing(3) 1 >>> import sympy >>> integral_pow_my_thing(sympy.Integer(3)) 1 >>> type(_) <class 'int'> >>> # error: Value of type variable \"MyIntegralPowT\" of \"integral_pow_my_thing\" cannot be \"str\" >>> integral_pow_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" real ( operand : SupportsRealImagMixedU ) Helper function that extracts the real part from operand including resolving non-compliant implementations that implement such extraction via a as_real_imag method rather than as properties. 1 2 3 4 >>> import sympy >>> from numerary.types import real >>> real ( sympy . Float ( 3.5 )) 3.5 See SupportsRealImag and SupportsRealImagAsMethod . Source code in numerary/types.py 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 @beartype def real ( operand : SupportsRealImagMixedU ): r \"\"\" Helper function that extracts the real part from *operand* including resolving non-compliant implementations that implement such extraction via a ``as_real_imag`` method rather than as properties. ``` python >>> import sympy >>> from numerary.types import real >>> real(sympy.Float(3.5)) 3.5 ``` See [SupportsRealImag][numerary.types.SupportsRealImag] and [SupportsRealImagAsMethod][numerary.types.SupportsRealImagAsMethod]. \"\"\" if callable ( getattr ( operand , \"as_real_imag\" , None )): real_part , _ = operand . as_real_imag () # type: ignore [union-attr] return real_part elif hasattr ( operand , \"real\" ): return operand . real # type: ignore [union-attr] else : raise TypeError ( f \" { operand !r} has no real or as_real_imag\" ) imag ( operand : SupportsRealImagMixedU ) Helper function that extracts the imaginary part from operand including resolving non-compliant implementations that implement such extraction via a as_real_imag method rather than as properties. 1 2 3 4 >>> import sympy >>> from numerary.types import real >>> imag ( sympy . Float ( 3.5 )) 0 See SupportsRealImag and SupportsRealImagAsMethod . Source code in numerary/types.py 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 @beartype def imag ( operand : SupportsRealImagMixedU ): r \"\"\" Helper function that extracts the imaginary part from *operand* including resolving non-compliant implementations that implement such extraction via a ``as_real_imag`` method rather than as properties. ``` python >>> import sympy >>> from numerary.types import real >>> imag(sympy.Float(3.5)) 0 ``` See [SupportsRealImag][numerary.types.SupportsRealImag] and [SupportsRealImagAsMethod][numerary.types.SupportsRealImagAsMethod]. \"\"\" if callable ( getattr ( operand , \"as_real_imag\" , None )): _ , imag_part = operand . as_real_imag () # type: ignore [union-attr] return imag_part elif hasattr ( operand , \"imag\" ): return operand . imag # type: ignore [union-attr] else : raise TypeError ( f \" { operand !r} has no real or as_real_imag\" ) __pow__ ( arg : Union [ SupportsComplexPow , SupportsIntegralPow ], exponent : Any , modulus : Optional [ Any ] = None ) -> Any Helper function that wraps pow to work with SupportsComplexPow , SupportsIntegralPow . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 >>> from numerary.types import SupportsComplexPow , SupportsIntegralPow , __pow__ >>> my_complex_pow : SupportsComplexPow = complex ( 2 ) >>> __pow__ ( my_complex_pow , 1 ) ( 2 + 0 j ) >>> __pow__ ( my_complex_pow , 1 , None ) ( 2 + 0 j ) >>> __pow__ ( my_complex_pow , 1 , 1 ) # type: ignore [operator] # properly caught by Mypy Traceback ( most recent call last ): ... ValueError : complex modulo >>> my_complex_pow = 1.2 >>> __pow__ ( my_complex_pow , 1 ) 1.2 >>> __pow__ ( my_complex_pow , 1 , None ) 1.2 >>> __pow__ ( my_complex_pow , 1 , 1 ) # ugh; *not* caught by Mypy because it treats floats as equivalent to ints? Traceback ( most recent call last ): ... TypeError : pow () 3 rd argument not allowed unless all arguments are integers >>> from fractions import Fraction >>> my_complex_pow = Fraction ( 1 , 2 ) >>> __pow__ ( my_complex_pow , 1 ) Fraction ( 1 , 2 ) >>> __pow__ ( my_complex_pow , 1 , None ) Fraction ( 1 , 2 ) >>> __pow__ ( my_complex_pow , 1 , 1 ) # type: ignore [operator] # properly caught by Mypy Traceback ( most recent call last ): ... TypeError : __pow__ () takes 2 positional arguments but 3 were given >>> from decimal import Decimal >>> my_integral_pow : SupportsIntegralPow = Decimal ( \"2\" ) >>> __pow__ ( my_integral_pow , 1 ) Decimal ( '2' ) >>> __pow__ ( my_integral_pow , 1 , None ) Decimal ( '2' ) >>> __pow__ ( my_integral_pow , 1 , 2 ) Decimal ( '0' ) >>> my_integral_pow = Decimal ( \"1.2\" ) # ruh-roh >>> __pow__ ( my_integral_pow , 1 ) Decimal ( '1.2' ) >>> __pow__ ( my_integral_pow , 1 , None ) Decimal ( '1.2' ) >>> __pow__ ( my_integral_pow , 1 , 2 ) # not catchable by Mypy, since it works *some* of the time Traceback ( most recent call last ): ... decimal . InvalidOperation : [ < class ' decimal . InvalidOperation '>] >>> my_integral_pow = 2 >>> __pow__ ( my_integral_pow , 1 ) 2 >>> __pow__ ( my_integral_pow , 1 , None ) 2 >>> __pow__ ( my_integral_pow , 1 , 2 ) 0 Source code in numerary/types.py 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 @beartype def __pow__ ( arg : Union [ SupportsComplexPow , SupportsIntegralPow ], exponent : Any , modulus : Optional [ Any ] = None , ) -> Any : r \"\"\" Helper function that wraps ``pow`` to work with [``SupportsComplexPow``][numerary.types.SupportsComplexPow], [``SupportsIntegralPow``][numerary.types.SupportsIntegralPow]. ``` python >>> from numerary.types import SupportsComplexPow, SupportsIntegralPow, __pow__ >>> my_complex_pow: SupportsComplexPow = complex(2) >>> __pow__(my_complex_pow, 1) (2+0j) >>> __pow__(my_complex_pow, 1, None) (2+0j) >>> __pow__(my_complex_pow, 1, 1) # type: ignore [operator] # properly caught by Mypy Traceback (most recent call last): ... ValueError: complex modulo >>> my_complex_pow = 1.2 >>> __pow__(my_complex_pow, 1) 1.2 >>> __pow__(my_complex_pow, 1, None) 1.2 >>> __pow__(my_complex_pow, 1, 1) # ugh; *not* caught by Mypy because it treats floats as equivalent to ints? Traceback (most recent call last): ... TypeError: pow() 3rd argument not allowed unless all arguments are integers >>> from fractions import Fraction >>> my_complex_pow = Fraction(1, 2) >>> __pow__(my_complex_pow, 1) Fraction(1, 2) >>> __pow__(my_complex_pow, 1, None) Fraction(1, 2) >>> __pow__(my_complex_pow, 1, 1) # type: ignore [operator] # properly caught by Mypy Traceback (most recent call last): ... TypeError: __pow__() takes 2 positional arguments but 3 were given >>> from decimal import Decimal >>> my_integral_pow: SupportsIntegralPow = Decimal(\"2\") >>> __pow__(my_integral_pow, 1) Decimal('2') >>> __pow__(my_integral_pow, 1, None) Decimal('2') >>> __pow__(my_integral_pow, 1, 2) Decimal('0') >>> my_integral_pow = Decimal(\"1.2\") # ruh-roh >>> __pow__(my_integral_pow, 1) Decimal('1.2') >>> __pow__(my_integral_pow, 1, None) Decimal('1.2') >>> __pow__(my_integral_pow, 1, 2) # not catchable by Mypy, since it works *some* of the time Traceback (most recent call last): ... decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>] >>> my_integral_pow = 2 >>> __pow__(my_integral_pow, 1) 2 >>> __pow__(my_integral_pow, 1, None) 2 >>> __pow__(my_integral_pow, 1, 2) 0 ``` \"\"\" return pow ( arg , exponent , modulus ) __trunc__ ( operand : Union [ SupportsFloat , SupportsTrunc ]) Helper function that wraps math.trunc . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsTrunc , __trunc__ >>> my_trunc : SupportsTrunc >>> my_trunc = 1 >>> __trunc__ ( my_trunc ) 1 >>> from fractions import Fraction >>> my_trunc = Fraction ( 1 , 2 ) >>> __trunc__ ( my_trunc ) 0 >>> my_trunc_float : SupportsFloat = 1.2 >>> __trunc__ ( my_trunc_float ) 1 Source code in numerary/types.py 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 @beartype def __trunc__ ( operand : Union [ SupportsFloat , SupportsTrunc ]): r \"\"\" Helper function that wraps ``math.trunc``. ``` python >>> from numerary.types import SupportsFloat, SupportsTrunc, __trunc__ >>> my_trunc: SupportsTrunc >>> my_trunc = 1 >>> __trunc__(my_trunc) 1 >>> from fractions import Fraction >>> my_trunc = Fraction(1, 2) >>> __trunc__(my_trunc) 0 >>> my_trunc_float: SupportsFloat = 1.2 >>> __trunc__(my_trunc_float) 1 ``` \"\"\" return math . trunc ( operand ) # type: ignore [arg-type] __floor__ ( operand : Union [ SupportsFloat , SupportsFloorCeil ]) Helper function that wraps math.floor . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsFloorCeil , __floor__ >>> my_floor : SupportsFloorCeil >>> my_floor = 1 >>> __floor__ ( my_floor ) 1 >>> from fractions import Fraction >>> my_floor = Fraction ( 1 , 2 ) >>> __floor__ ( my_floor ) 0 >>> my_floor_float : SupportsFloat = 1.2 >>> __floor__ ( my_floor_float ) 1 Source code in numerary/types.py 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 @beartype def __floor__ ( operand : Union [ SupportsFloat , SupportsFloorCeil ]): r \"\"\" Helper function that wraps ``math.floor``. ``` python >>> from numerary.types import SupportsFloat, SupportsFloorCeil, __floor__ >>> my_floor: SupportsFloorCeil >>> my_floor = 1 >>> __floor__(my_floor) 1 >>> from fractions import Fraction >>> my_floor = Fraction(1, 2) >>> __floor__(my_floor) 0 >>> my_floor_float: SupportsFloat = 1.2 >>> __floor__(my_floor_float) 1 ``` \"\"\" return math . floor ( operand ) # type: ignore [arg-type] __ceil__ ( operand : Union [ SupportsFloat , SupportsFloorCeil ]) Helper function that wraps math.ceil . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsFloorCeil , __ceil__ >>> my_ceil : SupportsFloorCeil >>> my_ceil = 1 >>> __ceil__ ( my_ceil ) 1 >>> from fractions import Fraction >>> my_ceil = Fraction ( 1 , 2 ) >>> __ceil__ ( my_ceil ) 1 >>> my_ceil_float : SupportsFloat = 1.2 >>> __ceil__ ( my_ceil_float ) 2 Source code in numerary/types.py 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 @beartype def __ceil__ ( operand : Union [ SupportsFloat , SupportsFloorCeil ]): r \"\"\" Helper function that wraps ``math.ceil``. ``` python >>> from numerary.types import SupportsFloat, SupportsFloorCeil, __ceil__ >>> my_ceil: SupportsFloorCeil >>> my_ceil = 1 >>> __ceil__(my_ceil) 1 >>> from fractions import Fraction >>> my_ceil = Fraction(1, 2) >>> __ceil__(my_ceil) 1 >>> my_ceil_float: SupportsFloat = 1.2 >>> __ceil__(my_ceil_float) 2 ``` \"\"\" return math . ceil ( operand ) # type: ignore [arg-type] numerator ( operand : SupportsNumeratorDenominatorMixedU ) Helper function that extracts the numerator from operand including resolving non-compliant rational implementations that implement numerator as a method rather than a property. 1 2 3 4 >>> from fractions import Fraction >>> from numerary.types import numerator >>> numerator ( Fraction ( 22 , 7 )) 22 See SupportsNumeratorDenominator and SupportsNumeratorDenominatorMethods . Source code in numerary/types.py 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 @beartype def numerator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" Helper function that extracts the numerator from *operand* including resolving non-compliant rational implementations that implement ``numerator`` as a method rather than a property. ``` python >>> from fractions import Fraction >>> from numerary.types import numerator >>> numerator(Fraction(22, 7)) 22 ``` See [SupportsNumeratorDenominator][numerary.types.SupportsNumeratorDenominator] and [SupportsNumeratorDenominatorMethods][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" if hasattr ( operand , \"numerator\" ): if callable ( operand . numerator ): return operand . numerator () else : return operand . numerator else : raise TypeError ( f \" { operand !r} has no numerator\" ) denominator ( operand : SupportsNumeratorDenominatorMixedU ) Helper function that extracts the denominator from operand including resolving non-compliant rational implementations that implement denominator as a method rather than a property. 1 2 3 4 >>> from fractions import Fraction >>> from numerary.types import denominator >>> denominator ( Fraction ( 22 , 7 )) 7 See SupportsNumeratorDenominator and SupportsNumeratorDenominatorMethods . Source code in numerary/types.py 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 @beartype def denominator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" Helper function that extracts the denominator from *operand* including resolving non-compliant rational implementations that implement ``denominator`` as a method rather than a property. ``` python >>> from fractions import Fraction >>> from numerary.types import denominator >>> denominator(Fraction(22, 7)) 7 ``` See [SupportsNumeratorDenominator][numerary.types.SupportsNumeratorDenominator] and [SupportsNumeratorDenominatorMethods][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" if hasattr ( operand , \"denominator\" ): if callable ( operand . denominator ): return operand . denominator () else : return operand . denominator else : raise TypeError ( f \" { operand !r} has no denominator\" ) RationalLikeMixedT = ( RationalLike , RationalLikeMethods ) module-attribute RationalLikeMixedU = Union [ RationalLike , RationalLikeMethods ] module-attribute SupportsRealImagMixedT = ( SupportsRealImag , SupportsRealImagAsMethod ) module-attribute SupportsRealImagMixedU = Union [ SupportsRealImag , SupportsRealImagAsMethod ] module-attribute SupportsNumeratorDenominatorMixedT = ( SupportsNumeratorDenominator , SupportsNumeratorDenominatorMethods ) module-attribute SupportsNumeratorDenominatorMixedU = Union [ SupportsNumeratorDenominator , SupportsNumeratorDenominatorMethods ] module-attribute _SupportsConjugate Bases: _Protocol The non-caching version of SupportsConjugate . Source code in numerary/types.py 154 155 156 157 158 159 160 161 162 163 @runtime_checkable class _SupportsConjugate ( _Protocol ): r \"\"\" The non-caching version of [``SupportsConjugate``][numerary.types.SupportsConjugate]. \"\"\" @abstractmethod def conjugate ( self ) -> Any : pass conjugate () -> Any abstractmethod Source code in numerary/types.py 161 162 163 @abstractmethod def conjugate ( self ) -> Any : pass _SupportsRealImag Bases: _Protocol The non-caching version of SupportsRealImag . Source code in numerary/types.py 216 217 218 219 220 221 222 223 224 225 226 227 228 @runtime_checkable class _SupportsRealImag ( _Protocol ): r \"\"\" The non-caching version of [``SupportsRealImag``][numerary.types.SupportsRealImag]. \"\"\" @property def real ( self ) -> Any : pass @property def imag ( self ) -> Any : pass imag () -> Any property Source code in numerary/types.py 226 227 228 @property def imag ( self ) -> Any : pass real () -> Any property Source code in numerary/types.py 222 223 224 @property def real ( self ) -> Any : pass _SupportsRealImagAsMethod Bases: _Protocol The non-caching version of SupportsRealImagAsMethod . Source code in numerary/types.py 275 276 277 278 279 280 281 282 283 284 @runtime_checkable class _SupportsRealImagAsMethod ( _Protocol ): r \"\"\" The non-caching version of [``SupportsRealImagAsMethod``][numerary.types.SupportsRealImagAsMethod]. \"\"\" @abstractmethod def as_real_imag ( self ) -> Tuple [ Any , Any ]: pass as_real_imag () -> Tuple [ Any , Any ] abstractmethod Source code in numerary/types.py 282 283 284 @abstractmethod def as_real_imag ( self ) -> Tuple [ Any , Any ]: pass _SupportsTrunc Bases: _Protocol The non-caching version of SupportsTrunc . Source code in numerary/types.py 344 345 346 347 348 349 350 351 352 @runtime_checkable class _SupportsTrunc ( _Protocol ): r \"\"\" The non-caching version of [``SupportsTrunc``][numerary.types.SupportsTrunc]. \"\"\" @abstractmethod def __trunc__ ( self ) -> int : pass __trunc__ () -> int abstractmethod Source code in numerary/types.py 350 351 352 @abstractmethod def __trunc__ ( self ) -> int : pass _SupportsFloorCeil Bases: _Protocol The non-caching version of SupportsFloorCeil . Source code in numerary/types.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 @runtime_checkable class _SupportsFloorCeil ( _Protocol ): r \"\"\" The non-caching version of [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil]. \"\"\" @abstractmethod def __floor__ ( self ) -> int : pass @abstractmethod def __ceil__ ( self ) -> int : pass __ceil__ () -> int abstractmethod Source code in numerary/types.py 416 417 418 @abstractmethod def __ceil__ ( self ) -> int : pass __floor__ () -> int abstractmethod Source code in numerary/types.py 412 413 414 @abstractmethod def __floor__ ( self ) -> int : pass _SupportsDivmod Bases: _Protocol , Generic [ _T_co ] The non-caching version of SupportsDivmod . Source code in numerary/types.py 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 @runtime_checkable class _SupportsDivmod ( _Protocol , Generic [ _T_co ], ): r \"\"\" The non-caching version of [``SupportsDivmod``][numerary.types.SupportsDivmod]. \"\"\" @abstractmethod def __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass @abstractmethod def __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass __divmod__ ( other : Any ) -> Tuple [ _T_co , _T_co ] abstractmethod Source code in numerary/types.py 497 498 499 @abstractmethod def __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass __rdivmod__ ( other : Any ) -> Tuple [ _T_co , _T_co ] abstractmethod Source code in numerary/types.py 501 502 503 @abstractmethod def __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass _SupportsNumeratorDenominator Bases: _Protocol The non-caching version of SupportsNumeratorDenominator . Source code in numerary/types.py 560 561 562 563 564 565 566 567 568 569 570 571 572 573 @runtime_checkable class _SupportsNumeratorDenominator ( _Protocol ): r \"\"\" The non-caching version of [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator]. \"\"\" @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass denominator () -> int property Source code in numerary/types.py 571 572 573 @property def denominator ( self ) -> int : pass numerator () -> int property Source code in numerary/types.py 567 568 569 @property def numerator ( self ) -> int : pass _SupportsNumeratorDenominatorMethods Bases: _Protocol The non-caching version of SupportsNumeratorDenominatorMethods . Source code in numerary/types.py 627 628 629 630 631 632 633 634 635 636 637 638 639 640 @runtime_checkable class _SupportsNumeratorDenominatorMethods ( _Protocol ): r \"\"\" The non-caching version of [``SupportsNumeratorDenominatorMethods``][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" @abstractmethod def numerator ( self ) -> SupportsInt : pass @abstractmethod def denominator ( self ) -> SupportsInt : pass denominator () -> SupportsInt abstractmethod Source code in numerary/types.py 638 639 640 @abstractmethod def denominator ( self ) -> SupportsInt : pass numerator () -> SupportsInt abstractmethod Source code in numerary/types.py 634 635 636 @abstractmethod def numerator ( self ) -> SupportsInt : pass _SupportsComplexOps Bases: _Protocol , Generic [ _T_co ] The non-caching version of SupportsComplexOps . Source code in numerary/types.py 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 @runtime_checkable class _SupportsComplexOps ( _Protocol , Generic [ _T_co ], ): r \"\"\" The non-caching version of [``SupportsComplexOps``][numerary.types.SupportsComplexOps]. \"\"\" @abstractmethod def __add__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __radd__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __sub__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rsub__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __mul__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rmul__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __truediv__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rtruediv__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __neg__ ( self ) -> _T_co : pass @abstractmethod def __pos__ ( self ) -> _T_co : pass __add__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 689 690 691 @abstractmethod def __add__ ( self , other : Any ) -> _T_co : pass __mul__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 705 706 707 @abstractmethod def __mul__ ( self , other : Any ) -> _T_co : pass __neg__ () -> _T_co abstractmethod Source code in numerary/types.py 721 722 723 @abstractmethod def __neg__ ( self ) -> _T_co : pass __pos__ () -> _T_co abstractmethod Source code in numerary/types.py 725 726 727 @abstractmethod def __pos__ ( self ) -> _T_co : pass __radd__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 693 694 695 @abstractmethod def __radd__ ( self , other : Any ) -> _T_co : pass __rmul__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 709 710 711 @abstractmethod def __rmul__ ( self , other : Any ) -> _T_co : pass __rsub__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 701 702 703 @abstractmethod def __rsub__ ( self , other : Any ) -> _T_co : pass __rtruediv__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 717 718 719 @abstractmethod def __rtruediv__ ( self , other : Any ) -> _T_co : pass __sub__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 697 698 699 @abstractmethod def __sub__ ( self , other : Any ) -> _T_co : pass __truediv__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 713 714 715 @abstractmethod def __truediv__ ( self , other : Any ) -> _T_co : pass _SupportsComplexPow Bases: _Protocol The non-caching version of SupportsComplexPow . Source code in numerary/types.py 780 781 782 783 784 785 786 787 788 789 790 791 792 793 @runtime_checkable class _SupportsComplexPow ( _Protocol ): r \"\"\" The non-caching version of [``SupportsComplexPow``][numerary.types.SupportsComplexPow]. \"\"\" @abstractmethod def __pow__ ( self , exponent : Any ) -> Any : pass @abstractmethod def __rpow__ ( self , exponent : Any ) -> Any : pass __pow__ ( exponent : Any ) -> Any abstractmethod Source code in numerary/types.py 787 788 789 @abstractmethod def __pow__ ( self , exponent : Any ) -> Any : pass __rpow__ ( exponent : Any ) -> Any abstractmethod Source code in numerary/types.py 791 792 793 @abstractmethod def __rpow__ ( self , exponent : Any ) -> Any : pass _SupportsRealOps Bases: _Protocol , Generic [ _T_co ] The non-caching version of SupportsRealOps . Source code in numerary/types.py 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 @runtime_checkable class _SupportsRealOps ( _Protocol , Generic [ _T_co ], ): r \"\"\" The non-caching version of [``SupportsRealOps``][numerary.types.SupportsRealOps]. \"\"\" @abstractmethod def __lt__ ( self , other : Any ) -> bool : pass @abstractmethod def __le__ ( self , other : Any ) -> bool : pass @abstractmethod def __ge__ ( self , other : Any ) -> bool : pass @abstractmethod def __gt__ ( self , other : Any ) -> bool : pass @abstractmethod def __floordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass @abstractmethod def __rfloordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass @abstractmethod def __mod__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rmod__ ( self , other : Any ) -> _T_co : pass __floordiv__ ( other : Any ) -> Any abstractmethod Source code in numerary/types.py 870 871 872 @abstractmethod def __floordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass __ge__ ( other : Any ) -> bool abstractmethod Source code in numerary/types.py 862 863 864 @abstractmethod def __ge__ ( self , other : Any ) -> bool : pass __gt__ ( other : Any ) -> bool abstractmethod Source code in numerary/types.py 866 867 868 @abstractmethod def __gt__ ( self , other : Any ) -> bool : pass __le__ ( other : Any ) -> bool abstractmethod Source code in numerary/types.py 858 859 860 @abstractmethod def __le__ ( self , other : Any ) -> bool : pass __lt__ ( other : Any ) -> bool abstractmethod Source code in numerary/types.py 854 855 856 @abstractmethod def __lt__ ( self , other : Any ) -> bool : pass __mod__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 878 879 880 @abstractmethod def __mod__ ( self , other : Any ) -> _T_co : pass __rfloordiv__ ( other : Any ) -> Any abstractmethod Source code in numerary/types.py 874 875 876 @abstractmethod def __rfloordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass __rmod__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 882 883 884 @abstractmethod def __rmod__ ( self , other : Any ) -> _T_co : pass _SupportsIntegralOps Bases: _Protocol , Generic [ _T_co ] The non-caching version of SupportsIntegralOps . Source code in numerary/types.py 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 @runtime_checkable class _SupportsIntegralOps ( _Protocol , Generic [ _T_co ], ): r \"\"\" The non-caching version of [``SupportsIntegralOps``][numerary.types.SupportsIntegralOps]. \"\"\" @abstractmethod def __lshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rlshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rrshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __and__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rand__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __xor__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rxor__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __or__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __ror__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __invert__ ( self ) -> _T_co : pass __and__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 965 966 967 @abstractmethod def __and__ ( self , other : Any ) -> _T_co : pass __invert__ () -> _T_co abstractmethod Source code in numerary/types.py 989 990 991 @abstractmethod def __invert__ ( self ) -> _T_co : pass __lshift__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 949 950 951 @abstractmethod def __lshift__ ( self , other : Any ) -> _T_co : pass __or__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 981 982 983 @abstractmethod def __or__ ( self , other : Any ) -> _T_co : pass __rand__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 969 970 971 @abstractmethod def __rand__ ( self , other : Any ) -> _T_co : pass __rlshift__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 953 954 955 @abstractmethod def __rlshift__ ( self , other : Any ) -> _T_co : pass __ror__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 985 986 987 @abstractmethod def __ror__ ( self , other : Any ) -> _T_co : pass __rrshift__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 961 962 963 @abstractmethod def __rrshift__ ( self , other : Any ) -> _T_co : pass __rshift__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 957 958 959 @abstractmethod def __rshift__ ( self , other : Any ) -> _T_co : pass __rxor__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 977 978 979 @abstractmethod def __rxor__ ( self , other : Any ) -> _T_co : pass __xor__ ( other : Any ) -> _T_co abstractmethod Source code in numerary/types.py 973 974 975 @abstractmethod def __xor__ ( self , other : Any ) -> _T_co : pass _SupportsIntegralPow Bases: _Protocol The non-caching version of SupportsIntegralPow . Source code in numerary/types.py 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 @runtime_checkable class _SupportsIntegralPow ( _Protocol ): r \"\"\" The non-caching version of [``SupportsIntegralPow``][numerary.types.SupportsIntegralPow]. \"\"\" @abstractmethod def __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass @abstractmethod def __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass __pow__ ( exponent : Any , modulus : Optional [ Any ] = None ) -> Any abstractmethod Source code in numerary/types.py 1047 1048 1049 @abstractmethod def __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass __rpow__ ( exponent : Any , modulus : Optional [ Any ] = None ) -> Any abstractmethod Source code in numerary/types.py 1051 1052 1053 @abstractmethod def __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass I acknowledge that the subject of who is awesomer, beartype or the man who made it, is hotly contested . \u21a9","title":"<tt>numerary.types</tt>"},{"location":"numerary.types/#numerarytypes-package-reference","text":"Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. numerary has donated its core caching protocol implementation to (and now depends on) beartype . beartype is awesome , and its author is even awesomer . 1","title":"numerary.types package reference"},{"location":"numerary.types/#numerary._protocol.CachingProtocolMeta","text":"Bases: _BeartypeCachingProtocolMeta An extension of beartype . typing . Protocol that allows overriding runtime checks. Source code in numerary/_protocol.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class CachingProtocolMeta ( _BeartypeCachingProtocolMeta ): # TODO(posita): Add more precise link to beartype.typing.Protocol documentation once # it becomes available. r \"\"\" An extension of [``#!python beartype.typing.Protocol``](https://github.com/beartype/beartype) that allows overriding runtime checks. \"\"\" _abc_inst_check_cache_overridden : Dict [ Type , bool ] _abc_inst_check_cache_listeners : Set [ CachingProtocolMeta ] # Defined in beartype.typing.Protocol from which we inherit _abc_inst_check_cache : Dict [ type , bool ] def __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any , ) -> _TT : cls = super () . __new__ ( mcls , name , bases , namespace , ** kw ) # Prefixing this class member with \"_abc_\" is necessary to prevent it from being # considered part of the Protocol. (See # <https://github.com/python/cpython/blob/main/Lib/typing.py>.) cls . _abc_inst_check_cache_overridden = defaultdict ( bool ) # defaults to False cls . _abc_inst_check_cache_listeners = set () for base in bases : if hasattr ( base , \"_abc_inst_check_cache_listeners\" ): base . _abc_inst_check_cache_listeners . add ( cls ) return cls def includes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsSpam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def spam(self) -> str: ... pass >>> class NoSpam: ... pass >>> isinstance(NoSpam(), SupportsSpam) False >>> SupportsSpam.includes(NoSpam) >>> isinstance(NoSpam(), SupportsSpam) True ``` !!! note This does not affect static type-checking. ``` python >>> my_spam: SupportsSpam = NoSpam() # type: ignore [assignment] # still generates a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = True cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t ) def excludes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsHam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def ham(self) -> str: ... pass >>> class NoHam: ... def ham(self) -> str: ... raise NotImplementedError >>> isinstance(NoHam(), SupportsHam) True >>> SupportsHam.excludes(NoHam) >>> isinstance(NoHam(), SupportsHam) False ``` !!! note This does not affect static type-checking. ``` python >>> my_ham: SupportsHam = NoHam() # does *not* generate a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = False cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t ) def reset_for ( cls , inst_t : Type ) -> None : r \"\"\" Clears any cached instance check for *inst_t*. \"\"\" if inst_t in cls . _abc_inst_check_cache : del cls . _abc_inst_check_cache [ inst_t ] del cls . _abc_inst_check_cache_overridden [ inst_t ] cls . _dirty_for ( inst_t ) def _dirty_for ( cls , inst_t : Type ) -> None : for inheriting_cls in cls . _abc_inst_check_cache_listeners : if ( inst_t in inheriting_cls . _abc_inst_check_cache and not inheriting_cls . _abc_inst_check_cache_overridden [ inst_t ] ): del inheriting_cls . _abc_inst_check_cache [ inst_t ] del inheriting_cls . _abc_inst_check_cache_overridden [ inst_t ]","title":"CachingProtocolMeta"},{"location":"numerary.types/#numerary._protocol.CachingProtocolMeta.excludes","text":"Registers inst_t as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsHam ( ... Protocol , ... metaclass = CachingProtocolMeta ... ): ... @abstractmethod ... def ham ( self ) -> str : ... pass >>> class NoHam : ... def ham ( self ) -> str : ... raise NotImplementedError >>> isinstance ( NoHam (), SupportsHam ) True >>> SupportsHam . excludes ( NoHam ) >>> isinstance ( NoHam (), SupportsHam ) False Note This does not affect static type-checking. 1 >>> my_ham : SupportsHam = NoHam () # does *not* generate a Mypy warning Source code in numerary/_protocol.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def excludes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsHam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def ham(self) -> str: ... pass >>> class NoHam: ... def ham(self) -> str: ... raise NotImplementedError >>> isinstance(NoHam(), SupportsHam) True >>> SupportsHam.excludes(NoHam) >>> isinstance(NoHam(), SupportsHam) False ``` !!! note This does not affect static type-checking. ``` python >>> my_ham: SupportsHam = NoHam() # does *not* generate a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = False cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t )","title":"excludes()"},{"location":"numerary.types/#numerary._protocol.CachingProtocolMeta.includes","text":"Registers inst_t as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsSpam ( ... Protocol , ... metaclass = CachingProtocolMeta ... ): ... @abstractmethod ... def spam ( self ) -> str : ... pass >>> class NoSpam : ... pass >>> isinstance ( NoSpam (), SupportsSpam ) False >>> SupportsSpam . includes ( NoSpam ) >>> isinstance ( NoSpam (), SupportsSpam ) True Note This does not affect static type-checking. 1 >>> my_spam : SupportsSpam = NoSpam () # type: ignore [assignment] # still generates a Mypy warning Source code in numerary/_protocol.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def includes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsSpam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def spam(self) -> str: ... pass >>> class NoSpam: ... pass >>> isinstance(NoSpam(), SupportsSpam) False >>> SupportsSpam.includes(NoSpam) >>> isinstance(NoSpam(), SupportsSpam) True ``` !!! note This does not affect static type-checking. ``` python >>> my_spam: SupportsSpam = NoSpam() # type: ignore [assignment] # still generates a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = True cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t )","title":"includes()"},{"location":"numerary.types/#numerary._protocol.CachingProtocolMeta.reset_for","text":"Clears any cached instance check for inst_t . Source code in numerary/_protocol.py 156 157 158 159 160 161 162 163 def reset_for ( cls , inst_t : Type ) -> None : r \"\"\" Clears any cached instance check for *inst_t*. \"\"\" if inst_t in cls . _abc_inst_check_cache : del cls . _abc_inst_check_cache [ inst_t ] del cls . _abc_inst_check_cache_overridden [ inst_t ] cls . _dirty_for ( inst_t )","title":"reset_for()"},{"location":"numerary.types/#numerary.types.RationalLike","text":"Bases: SupportsAbs [ _T_co ] , SupportsFloat , SupportsNumeratorDenominator , SupportsRealOps [ _T_co ] , SupportsComplexOps [ _T_co ] , SupportsComplexPow , Protocol , Generic [ _T_co ] A caching ABC that defines a core set of operations for interacting with rationals. It is a composition of: SupportsAbs SupportsFloat SupportsNumeratorDenominator SupportsRealOps SupportsComplexOps SupportsComplexPow Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from beartype.typing import Protocol , TypeVar from numerary.types import CachingProtocolMeta , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class RationalLike ( SupportsAbs [ T_co ], SupportsFloat , SupportsNumeratorDenominator , SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], SupportsComplexPow [ T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): pass This is intended as a practically useful, but incomplete list. To enforce equivalence to numbers . Rational , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloorCeil SupportsDivmod Source code in numerary/types.py 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 @runtime_checkable class RationalLike ( SupportsAbs [ _T_co ], SupportsFloat , SupportsNumeratorDenominator , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], SupportsComplexPow , Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC that defines a core set of operations for interacting with rationals. It is a composition of: * [``SupportsAbs``][numerary.types.SupportsAbs] * [``SupportsFloat``][numerary.types.SupportsFloat] * [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator] * [``SupportsRealOps``][numerary.types.SupportsRealOps] * [``SupportsComplexOps``][numerary.types.SupportsComplexOps] * [``SupportsComplexPow``][numerary.types.SupportsComplexPow] Basically: ``` python from beartype.typing import Protocol, TypeVar from numerary.types import CachingProtocolMeta, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class RationalLike( SupportsAbs[T_co], SupportsFloat, SupportsNumeratorDenominator, SupportsRealOps[T_co], SupportsComplexOps[T_co], SupportsComplexPow[T_co], Protocol, Generic[_T_co], metaclass=CachingProtocolMeta, ): pass ``` This is intended as a practically useful, but incomplete list. To enforce equivalence to ``#!python numbers.Rational``, one would also need: * [``SupportsComplex``][numerary.types.SupportsComplex] * [``SupportsConjugate``][numerary.types.SupportsConjugate] * [``SupportsRealImag``][numerary.types.SupportsRealImag] * [``SupportsRound``][numerary.types.SupportsRound] * [``SupportsTrunc``][numerary.types.SupportsTrunc] * [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil] * [``SupportsDivmod``][numerary.types.SupportsDivmod] \"\"\" # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass","title":"RationalLike"},{"location":"numerary.types/#numerary.types.RationalLikeMethods","text":"Bases: SupportsAbs [ _T_co ] , SupportsFloat , SupportsNumeratorDenominatorMethods , SupportsRealOps [ _T_co ] , SupportsComplexOps [ _T_co ] , SupportsComplexPow , Protocol , Generic [ _T_co ] A caching ABC that defines a core set of operations for interacting with rationals. It is identical to RationalLike with one important exception. Instead of SupportsNumeratorDenominator , this protocol provides SupportsNumeratorDenominatorMethods . Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from beartype.typing import Protocol , TypeVar from numerary.types import CachingProtocolMeta , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class RationalLikeMethods ( SupportsAbs [ T_co ], SupportsFloat , SupportsNumeratorDenominatorMethods , SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], SupportsComplexPow [ T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): pass This is probably not very useful on its own, but is important to the construction of RationalLikeMixedU and RationalLikeMixedT . See also the numerator and denominator helper functions. Source code in numerary/types.py 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 @runtime_checkable class RationalLikeMethods ( SupportsAbs [ _T_co ], SupportsFloat , SupportsNumeratorDenominatorMethods , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], SupportsComplexPow , Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC that defines a core set of operations for interacting with rationals. It is identical to [``RationalLike``][numerary.types.RationalLike] with one important exception. Instead of [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator], this protocol provides [``SupportsNumeratorDenominatorMethods``][numerary.types.SupportsNumeratorDenominatorMethods]. Basically: ``` python from beartype.typing import Protocol, TypeVar from numerary.types import CachingProtocolMeta, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class RationalLikeMethods( SupportsAbs[T_co], SupportsFloat, SupportsNumeratorDenominatorMethods, SupportsRealOps[T_co], SupportsComplexOps[T_co], SupportsComplexPow[T_co], Protocol, Generic[_T_co], metaclass=CachingProtocolMeta, ): pass ``` This is probably not very useful on its own, but is important to the construction of [``RationalLikeMixedU``][numerary.types.RationalLikeMixedU] and [``RationalLikeMixedT``][numerary.types.RationalLikeMixedT]. See also the [``numerator``][numerary.types.numerator] and [``denominator``][numerary.types.denominator] helper functions. \"\"\" # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass","title":"RationalLikeMethods"},{"location":"numerary.types/#numerary.types.SupportsAbs","text":"Bases: _SupportsAbs [ _T_co ] , Protocol , Generic [ _T_co ] A derivative of beartype.typing.SupportsAbs with an override-able cache. Source code in numerary/types.py 68 69 70 71 72 73 74 75 76 77 @runtime_checkable class SupportsAbs ( _SupportsAbs [ _T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A derivative of ``beartype.typing.SupportsAbs`` with an override-able cache. \"\"\"","title":"SupportsAbs"},{"location":"numerary.types/#numerary.types.SupportsComplex","text":"Bases: _SupportsComplex , Protocol A derivative of beartype.typing.SupportsComplex with an override-able cache. Source code in numerary/types.py 83 84 85 86 87 88 89 90 91 @runtime_checkable class SupportsComplex ( _SupportsComplex , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A derivative of ``beartype.typing.SupportsComplex`` with an override-able cache. \"\"\"","title":"SupportsComplex"},{"location":"numerary.types/#numerary.types.SupportsFloat","text":"Bases: _SupportsFloat , Protocol A derivative of beartype.typing.SupportsFloat with an override-able cache. Source code in numerary/types.py 97 98 99 100 101 102 103 104 105 @runtime_checkable class SupportsFloat ( _SupportsFloat , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A derivative of ``beartype.typing.SupportsFloat`` with an override-able cache. \"\"\"","title":"SupportsFloat"},{"location":"numerary.types/#numerary.types.SupportsInt","text":"Bases: _SupportsInt , Protocol A derivative of beartype.typing.SupportsInt with an override-able cache. Source code in numerary/types.py 111 112 113 114 115 116 117 118 119 @runtime_checkable class SupportsInt ( _SupportsInt , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A derivative of ``beartype.typing.SupportsInt`` with an override-able cache. \"\"\"","title":"SupportsInt"},{"location":"numerary.types/#numerary.types.SupportsIndex","text":"Bases: _SupportsIndex , Protocol A derivative of beartype.typing.SupportsIndex with an override-able cache. Source code in numerary/types.py 125 126 127 128 129 130 131 132 133 @runtime_checkable class SupportsIndex ( _SupportsIndex , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A derivative of ``beartype.typing.SupportsIndex`` with an override-able cache. \"\"\"","title":"SupportsIndex"},{"location":"numerary.types/#numerary.types.SupportsRound","text":"Bases: _SupportsRound [ _T_co ] , Protocol , Generic [ _T_co ] A derivative of beartype.typing.SupportsRound with an override-able cache. Source code in numerary/types.py 139 140 141 142 143 144 145 146 147 148 @runtime_checkable class SupportsRound ( _SupportsRound [ _T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A derivative of ``beartype.typing.SupportsRound`` with an override-able cache. \"\"\"","title":"SupportsRound"},{"location":"numerary.types/#numerary.types.SupportsConjugate","text":"Bases: _SupportsConjugate , Protocol A caching ABC defining the conjugate method . ( _SupportsConjugate is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import TypeVar >>> from numerary.types import SupportsConjugate >>> MyConjugateT = TypeVar ( \"MyConjugateT\" , bound = SupportsConjugate ) >>> def conjugate_my_thing ( arg : MyConjugateT ) -> MyConjugateT : ... assert isinstance ( arg , SupportsConjugate ) ... return arg . conjugate () >>> conjugate_my_thing ( 3 ) 3 >>> from decimal import Decimal >>> conjugate_my_thing ( Decimal ( 2.5 )) Decimal ( '2.5' ) >>> import sympy >>> conjugate_my_thing ( sympy . Float ( 3.5 )) 3.5 >>> type ( _ ) < class ' sympy . core . numbers . Float '> >>> # error: Value of type variable \"MyConjugateT\" of \"conjugate_my_thing\" cannot be \"str\" >>> conjugate_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 @runtime_checkable class SupportsConjugate ( _SupportsConjugate , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``conjugate`` method](https://docs.python.org/3/library/numbers.html#numbers.Complex.conjugate). ([``_SupportsConjugate``][numerary.types._SupportsConjugate] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import TypeVar >>> from numerary.types import SupportsConjugate >>> MyConjugateT = TypeVar(\"MyConjugateT\", bound=SupportsConjugate) >>> def conjugate_my_thing(arg: MyConjugateT) -> MyConjugateT: ... assert isinstance(arg, SupportsConjugate) ... return arg.conjugate() >>> conjugate_my_thing(3) 3 >>> from decimal import Decimal >>> conjugate_my_thing(Decimal(2.5)) Decimal('2.5') >>> import sympy >>> conjugate_my_thing(sympy.Float(3.5)) 3.5 >>> type(_) <class 'sympy.core.numbers.Float'> >>> # error: Value of type variable \"MyConjugateT\" of \"conjugate_my_thing\" cannot be \"str\" >>> conjugate_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\"","title":"SupportsConjugate"},{"location":"numerary.types/#numerary.types.SupportsRealImag","text":"Bases: _SupportsRealImag , Protocol A caching ABC defining the real and imag properties. ( _SupportsRealImag is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsRealImag , real , imag >>> MyRealImagT = TypeVar ( \"MyRealImagT\" , bound = SupportsRealImag ) >>> def real_imag_my_thing ( arg : MyRealImagT ) -> Tuple [ Any , Any ]: ... assert isinstance ( arg , SupportsRealImag ) ... return ( real ( arg ), imag ( arg )) >>> real_imag_my_thing ( 3 ) ( 3 , 0 ) >>> from decimal import Decimal >>> real_imag_my_thing ( Decimal ( 2.5 )) ( Decimal ( '2.5' ), Decimal ( '0' )) >>> # error: Value of type variable \"MyRealImagT\" of \"real_imag_my_thing\" cannot be \"str\" >>> real_imag_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @runtime_checkable class SupportsRealImag ( _SupportsRealImag , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``real``](https://docs.python.org/3/library/numbers.html#numbers.Complex.real) and [``imag``](https://docs.python.org/3/library/numbers.html#numbers.Complex.imag) properties. ([``_SupportsRealImag``][numerary.types._SupportsRealImag] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsRealImag, real, imag >>> MyRealImagT = TypeVar(\"MyRealImagT\", bound=SupportsRealImag) >>> def real_imag_my_thing(arg: MyRealImagT) -> Tuple[Any, Any]: ... assert isinstance(arg, SupportsRealImag) ... return (real(arg), imag(arg)) >>> real_imag_my_thing(3) (3, 0) >>> from decimal import Decimal >>> real_imag_my_thing(Decimal(2.5)) (Decimal('2.5'), Decimal('0')) >>> # error: Value of type variable \"MyRealImagT\" of \"real_imag_my_thing\" cannot be \"str\" >>> real_imag_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\"","title":"SupportsRealImag"},{"location":"numerary.types/#numerary.types.SupportsRealImagAsMethod","text":"Bases: _SupportsRealImagAsMethod , Protocol A caching ABC defining the as_real_imag method that returns a 2-tuple. ( _SupportsRealImagAsMethod is the raw, non-caching version that defines the actual methods.) See also the real and imag helper functions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsRealImagAsMethod , real , imag >>> MyRealImagAsMethodT = TypeVar ( \"MyRealImagAsMethodT\" , bound = SupportsRealImagAsMethod ) >>> def as_real_imag_my_thing ( arg : MyRealImagAsMethodT ) -> Tuple [ Any , Any ]: ... assert isinstance ( arg , SupportsRealImagAsMethod ) ... return ( real ( arg ), imag ( arg )) >>> as_real_imag_my_thing ( sympy . Float ( 3.5 )) ( 3.5 , 0 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' sympy . core . numbers . Float '>, <class ' sympy . core . numbers . Zero '>) >>> # error: Value of type variable \"MyRealImagAsMethodT\" of \"as_real_imag_my_thing\" cannot be \"str\" >>> as_real_imag_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 @runtime_checkable class SupportsRealImagAsMethod ( _SupportsRealImagAsMethod , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the ``#!python as_real_imag`` method that returns a 2-tuple. ([``_SupportsRealImagAsMethod``][numerary.types._SupportsRealImagAsMethod] is the raw, non-caching version that defines the actual methods.) See also the [``real``][numerary.types.real] and [``imag``][numerary.types.imag] helper functions. ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsRealImagAsMethod, real, imag >>> MyRealImagAsMethodT = TypeVar(\"MyRealImagAsMethodT\", bound=SupportsRealImagAsMethod) >>> def as_real_imag_my_thing(arg: MyRealImagAsMethodT) -> Tuple[Any, Any]: ... assert isinstance(arg, SupportsRealImagAsMethod) ... return (real(arg), imag(arg)) >>> as_real_imag_my_thing(sympy.Float(3.5)) (3.5, 0) >>> tuple(type(i) for i in _) (<class 'sympy.core.numbers.Float'>, <class 'sympy.core.numbers.Zero'>) >>> # error: Value of type variable \"MyRealImagAsMethodT\" of \"as_real_imag_my_thing\" cannot be \"str\" >>> as_real_imag_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\"","title":"SupportsRealImagAsMethod"},{"location":"numerary.types/#numerary.types.SupportsTrunc","text":"Bases: _SupportsTrunc , Protocol A caching ABC defining the __trunc__ method . See also the __trunc__ helper function . ( _SupportsTrunc is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsTrunc , __trunc__ >>> MyTruncT = TypeVar ( \"MyTruncT\" , bound = SupportsTrunc ) >>> def trunc_my_thing ( arg : MyTruncT ) -> Tuple [ Any , Any ]: ... assert isinstance ( arg , SupportsTrunc ) ... return __trunc__ ( arg ) >>> trunc_my_thing ( 3 ) 3 >>> from decimal import Decimal >>> trunc_my_thing ( Decimal ( 2.5 )) 2 >>> import sympy >>> trunc_my_thing ( sympy . Float ( 3.5 )) 3 >>> type ( _ ) < class ' sympy . core . numbers . Integer '> >>> # error: Value of type variable \"MyTruncT\" of \"trunc_my_thing\" cannot be \"str\" >>> trunc_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 @runtime_checkable class SupportsTrunc ( _SupportsTrunc , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``__trunc__`` method](https://docs.python.org/3/reference/datamodel.html#object.__trunc__). See also the [``__trunc__`` helper function][numerary.types.__trunc__]. ([``_SupportsTrunc``][numerary.types._SupportsTrunc] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsTrunc, __trunc__ >>> MyTruncT = TypeVar(\"MyTruncT\", bound=SupportsTrunc) >>> def trunc_my_thing(arg: MyTruncT) -> Tuple[Any, Any]: ... assert isinstance(arg, SupportsTrunc) ... return __trunc__(arg) >>> trunc_my_thing(3) 3 >>> from decimal import Decimal >>> trunc_my_thing(Decimal(2.5)) 2 >>> import sympy >>> trunc_my_thing(sympy.Float(3.5)) 3 >>> type(_) <class 'sympy.core.numbers.Integer'> >>> # error: Value of type variable \"MyTruncT\" of \"trunc_my_thing\" cannot be \"str\" >>> trunc_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\"","title":"SupportsTrunc"},{"location":"numerary.types/#numerary.types.SupportsFloorCeil","text":"Bases: _SupportsFloorCeil , Protocol A caching ABC defining the __floor__ . and __ceil__ methods. ( _SupportsFloorCeil is the raw, non-caching version that defines the actual methods.) Note This is of limited value for Python versions prior to 3.9, since float . __floor__ and float . __ceil__ were not defined. If support for those environments is important, consider using SupportsFloat instead. See also the __floor__ and __ceil__ helper functions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsFloorCeil , __ceil__ , __floor__ >>> MyFloorCeilT = TypeVar ( \"MyFloorCeilT\" , bound = SupportsFloorCeil ) >>> def floor_ceil_my_thing ( arg : MyFloorCeilT ) -> Tuple [ int , int ]: ... assert isinstance ( arg , SupportsFloorCeil ) ... return __floor__ ( arg ), __ceil__ ( arg ) >>> floor_ceil_my_thing ( 3 ) ( 3 , 3 ) >>> from decimal import Decimal >>> floor_ceil_my_thing ( Decimal ( 2.5 )) ( 2 , 3 ) >>> import sympy >>> floor_ceil_my_thing ( sympy . Float ( 3.5 )) ( 3 , 4 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' sympy . core . numbers . Integer '>, <class ' sympy . core . numbers . Integer '>) >>> # error: Value of type variable \"MyFloorCeilT\" of \"floor_ceil_my_thing\" cannot be \"str\" >>> floor_ceil_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 @runtime_checkable class SupportsFloorCeil ( _SupportsFloorCeil , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``__floor__``](https://docs.python.org/3/reference/datamodel.html#object.__floor__). and [``__ceil__``](https://docs.python.org/3/reference/datamodel.html#object.__ceil__) methods. ([``_SupportsFloorCeil``][numerary.types._SupportsFloorCeil] is the raw, non-caching version that defines the actual methods.) !!! note This is of limited value for Python versions prior to 3.9, since ``#!python float.__floor__`` and ``#!python float.__ceil__`` were not defined. If support for those environments is important, consider using [``SupportsFloat``][numerary.types.SupportsFloat] instead. See also the [``__floor__``][numerary.types.__floor__] and [``__ceil__``][numerary.types.__ceil__] helper functions. ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsFloorCeil, __ceil__, __floor__ >>> MyFloorCeilT = TypeVar(\"MyFloorCeilT\", bound=SupportsFloorCeil) >>> def floor_ceil_my_thing(arg: MyFloorCeilT) -> Tuple[int, int]: ... assert isinstance(arg, SupportsFloorCeil) ... return __floor__(arg), __ceil__(arg) >>> floor_ceil_my_thing(3) (3, 3) >>> from decimal import Decimal >>> floor_ceil_my_thing(Decimal(2.5)) (2, 3) >>> import sympy >>> floor_ceil_my_thing(sympy.Float(3.5)) (3, 4) >>> tuple(type(i) for i in _) (<class 'sympy.core.numbers.Integer'>, <class 'sympy.core.numbers.Integer'>) >>> # error: Value of type variable \"MyFloorCeilT\" of \"floor_ceil_my_thing\" cannot be \"str\" >>> floor_ceil_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\"","title":"SupportsFloorCeil"},{"location":"numerary.types/#numerary.types.SupportsDivmod","text":"Bases: _SupportsDivmod [ _T_co ] , Protocol , Generic [ _T_co ] A caching ABC defining the __divmod__ and __rdivmod__ methods. Each returns a 2-tuple of covariants. ( _SupportsDivmod is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsDivmod >>> MyDivmodT = TypeVar ( \"MyDivmodT\" , bound = SupportsDivmod ) >>> def divmod_my_thing ( arg : MyDivmodT , other : Any ) -> Tuple [ MyDivmodT , MyDivmodT ]: ... assert isinstance ( arg , SupportsDivmod ) ... return divmod ( arg , other ) >>> divmod_my_thing ( 2 , 1 ) ( 2 , 0 ) >>> from decimal import Decimal >>> divmod_my_thing ( Decimal ( 2.5 ), Decimal ( 1.5 )) ( Decimal ( '1' ), Decimal ( '1.0' )) >>> import sympy >>> divmod_my_thing ( sympy . Float ( 3.5 ), sympy . Float ( 1.5 )) ( 2 , 0.5 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' sympy . core . numbers . Integer '>, <class ' sympy . core . numbers . Float '>) >>> # error: Value of type variable \"MyDivmodT\" of \"divmod_my_thing\" cannot be \"str\" >>> divmod_my_thing ( \"not-a-number\" , \"still-not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 @runtime_checkable class SupportsDivmod ( _SupportsDivmod [ _T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``__divmod__``](https://docs.python.org/3/reference/datamodel.html#object.__divmod__) and [``__rdivmod__``](https://docs.python.org/3/reference/datamodel.html#object.__rdivmod__) methods. Each returns a 2-tuple of covariants. ([``_SupportsDivmod``][numerary.types._SupportsDivmod] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsDivmod >>> MyDivmodT = TypeVar(\"MyDivmodT\", bound=SupportsDivmod) >>> def divmod_my_thing(arg: MyDivmodT, other: Any) -> Tuple[MyDivmodT, MyDivmodT]: ... assert isinstance(arg, SupportsDivmod) ... return divmod(arg, other) >>> divmod_my_thing(2, 1) (2, 0) >>> from decimal import Decimal >>> divmod_my_thing(Decimal(2.5), Decimal(1.5)) (Decimal('1'), Decimal('1.0')) >>> import sympy >>> divmod_my_thing(sympy.Float(3.5), sympy.Float(1.5)) (2, 0.5) >>> tuple(type(i) for i in _) (<class 'sympy.core.numbers.Integer'>, <class 'sympy.core.numbers.Float'>) >>> # error: Value of type variable \"MyDivmodT\" of \"divmod_my_thing\" cannot be \"str\" >>> divmod_my_thing(\"not-a-number\", \"still-not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\"","title":"SupportsDivmod"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominator","text":"Bases: _SupportsNumeratorDenominator , Protocol A caching ABC defining the numerator and denominator properties. ( _SupportsNumeratorDenominator is the raw, non-caching version that defines the actual properties.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsNumeratorDenominator , denominator , numerator >>> MyNumDenomT = TypeVar ( \"MyNumDenomT\" , bound = SupportsNumeratorDenominator ) >>> def num_denom_my_thing ( arg : MyNumDenomT ) -> Tuple [ int , int ]: ... assert isinstance ( arg , SupportsNumeratorDenominator ) ... return numerator ( arg ), denominator ( arg ) >>> num_denom_my_thing ( 3 ) ( 3 , 1 ) >>> from fractions import Fraction >>> num_denom_my_thing ( Fraction ( 2 , 3 )) ( 2 , 3 ) >>> import sympy >>> num_denom_my_thing ( sympy . Rational ( 3 , 4 )) ( 3 , 4 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' int '>, <class ' int '>) >>> # error: Value of type variable \"MyNumDenomT\" of \"num_denom_my_thing\" cannot be \"str\" >>> num_denom_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 @runtime_checkable class SupportsNumeratorDenominator ( _SupportsNumeratorDenominator , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``numerator``](https://docs.python.org/3/library/numbers.html#numbers.Rational.numerator) and [``denominator``](https://docs.python.org/3/library/numbers.html#numbers.Rational.denominator) properties. ([``_SupportsNumeratorDenominator``][numerary.types._SupportsNumeratorDenominator] is the raw, non-caching version that defines the actual properties.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsNumeratorDenominator, denominator, numerator >>> MyNumDenomT = TypeVar(\"MyNumDenomT\", bound=SupportsNumeratorDenominator) >>> def num_denom_my_thing(arg: MyNumDenomT) -> Tuple[int, int]: ... assert isinstance(arg, SupportsNumeratorDenominator) ... return numerator(arg), denominator(arg) >>> num_denom_my_thing(3) (3, 1) >>> from fractions import Fraction >>> num_denom_my_thing(Fraction(2, 3)) (2, 3) >>> import sympy >>> num_denom_my_thing(sympy.Rational(3, 4)) (3, 4) >>> tuple(type(i) for i in _) (<class 'int'>, <class 'int'>) >>> # error: Value of type variable \"MyNumDenomT\" of \"num_denom_my_thing\" cannot be \"str\" >>> num_denom_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\"","title":"SupportsNumeratorDenominator"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMethods","text":"Bases: _SupportsNumeratorDenominatorMethods , Protocol A caching ABC defining numerator and denominator methods. Each returns a SupportsInt . ( _SupportsNumeratorDenominatorMethods is the raw, non-caching version that defines the actual methods.) See also the numerator and denominator helper functions. Source code in numerary/types.py 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 @runtime_checkable class SupportsNumeratorDenominatorMethods ( _SupportsNumeratorDenominatorMethods , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining ``#!python numerator`` and ``#!python denominator`` methods. Each returns a [``SupportsInt``][numerary.types.SupportsInt]. ([``_SupportsNumeratorDenominatorMethods``][numerary.types._SupportsNumeratorDenominatorMethods] is the raw, non-caching version that defines the actual methods.) See also the [``numerator``][numerary.types.numerator] and [``denominator``][numerary.types.denominator] helper functions. \"\"\"","title":"SupportsNumeratorDenominatorMethods"},{"location":"numerary.types/#numerary.types.SupportsComplexOps","text":"Bases: _SupportsComplexOps [ _T_co ] , Protocol , Generic [ _T_co ] A caching ABC defining the Complex operator methods with covariant return values. ( _SupportsComplexOps is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsComplexOps >>> MyComplexOpsT = TypeVar ( \"MyComplexOpsT\" , bound = SupportsComplexOps ) >>> def complex_ops_my_thing ( arg : MyComplexOpsT ) -> MyComplexOpsT : ... assert isinstance ( arg , SupportsComplexOps ) ... return arg * - 2 + 5 >>> complex_ops_my_thing ( 3 ) - 1 >>> from decimal import Decimal >>> complex_ops_my_thing ( Decimal ( \"2.5\" )) Decimal ( '0.0' ) >>> import sympy >>> complex_ops_my_thing ( sympy . Float ( 3.5 )) - 2.0 >>> type ( _ ) < class ' sympy . core . numbers . Float '> >>> # error: Value of type variable \"MyComplexOpsT\" of \"complex_ops_my_thing\" cannot be \"str\" >>> complex_ops_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 @runtime_checkable class SupportsComplexOps ( _SupportsComplexOps [ _T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``Complex`` operator methods](https://docs.python.org/3/library/numbers.html#numbers.Complex) with covariant return values. ([``_SupportsComplexOps``][numerary.types._SupportsComplexOps] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsComplexOps >>> MyComplexOpsT = TypeVar(\"MyComplexOpsT\", bound=SupportsComplexOps) >>> def complex_ops_my_thing(arg: MyComplexOpsT) -> MyComplexOpsT: ... assert isinstance(arg, SupportsComplexOps) ... return arg * -2 + 5 >>> complex_ops_my_thing(3) -1 >>> from decimal import Decimal >>> complex_ops_my_thing(Decimal(\"2.5\")) Decimal('0.0') >>> import sympy >>> complex_ops_my_thing(sympy.Float(3.5)) -2.0 >>> type(_) <class 'sympy.core.numbers.Float'> >>> # error: Value of type variable \"MyComplexOpsT\" of \"complex_ops_my_thing\" cannot be \"str\" >>> complex_ops_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\"","title":"SupportsComplexOps"},{"location":"numerary.types/#numerary.types.SupportsComplexPow","text":"Bases: _SupportsComplexPow , Protocol A caching ABC defining the Complex (i.e., non-modulo) versions of the __pow__ and __rpow__ . ( _SupportsComplexPow is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsComplexPow >>> MyComplexPowT = TypeVar ( \"MyComplexPowT\" , bound = SupportsComplexPow ) >>> def complex_pow_my_thing ( arg : MyComplexPowT ) -> MyComplexPowT : ... assert isinstance ( arg , SupportsComplexPow ) ... return arg ** - 2 >>> complex_pow_my_thing ( 3 ) 0.1111111111111111 >>> from decimal import Decimal >>> complex_pow_my_thing ( Decimal ( \"2.5\" )) Decimal ( '0.16' ) >>> import sympy >>> complex_pow_my_thing ( sympy . Float ( 3.5 )) 0.0816326530612245 >>> type ( _ ) < class ' sympy . core . numbers . Float '> >>> # error: Value of type variable \"MyComplexPowT\" of \"complex_pow_my_thing\" cannot be \"str\" >>> complex_pow_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 @runtime_checkable class SupportsComplexPow ( _SupportsComplexPow , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the ``#!python Complex`` (i.e., non-modulo) versions of the [``__pow__``](https://docs.python.org/3/reference/datamodel.html#object.__pow__) and [``__rpow__``](https://docs.python.org/3/reference/datamodel.html#object.__rpow__). ([``_SupportsComplexPow``][numerary.types._SupportsComplexPow] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsComplexPow >>> MyComplexPowT = TypeVar(\"MyComplexPowT\", bound=SupportsComplexPow) >>> def complex_pow_my_thing(arg: MyComplexPowT) -> MyComplexPowT: ... assert isinstance(arg, SupportsComplexPow) ... return arg ** -2 >>> complex_pow_my_thing(3) 0.1111111111111111 >>> from decimal import Decimal >>> complex_pow_my_thing(Decimal(\"2.5\")) Decimal('0.16') >>> import sympy >>> complex_pow_my_thing(sympy.Float(3.5)) 0.0816326530612245 >>> type(_) <class 'sympy.core.numbers.Float'> >>> # error: Value of type variable \"MyComplexPowT\" of \"complex_pow_my_thing\" cannot be \"str\" >>> complex_pow_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\"","title":"SupportsComplexPow"},{"location":"numerary.types/#numerary.types.SupportsRealOps","text":"Bases: _SupportsRealOps [ _T_co ] , Protocol , Generic [ _T_co ] A caching ABC defining the Real operator methods with covariant return values. ( _SupportsRealOps is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsRealOps >>> MyRealOpsT = TypeVar ( \"MyRealOpsT\" , bound = SupportsRealOps ) >>> def real_ops_my_thing ( arg : MyRealOpsT ) -> Any : ... assert isinstance ( arg , SupportsRealOps ) ... return arg // - 2 >>> real_ops_my_thing ( 3 ) - 2 >>> from decimal import Decimal >>> real_ops_my_thing ( Decimal ( \"2.5\" )) Decimal ( '-1' ) >>> import sympy >>> real_ops_my_thing ( sympy . Float ( 3.5 )) - 2 >>> type ( _ ) < class ' sympy . core . numbers . Integer '> >>> # error: Value of type variable \"MyRealOpsT\" of \"real_ops_my_thing\" cannot be \"str\" >>> real_ops_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 @runtime_checkable class SupportsRealOps ( _SupportsRealOps [ _T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``Real`` operator methods](https://docs.python.org/3/library/numbers.html#numbers.Real) with covariant return values. ([``_SupportsRealOps``][numerary.types._SupportsRealOps] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsRealOps >>> MyRealOpsT = TypeVar(\"MyRealOpsT\", bound=SupportsRealOps) >>> def real_ops_my_thing(arg: MyRealOpsT) -> Any: ... assert isinstance(arg, SupportsRealOps) ... return arg // -2 >>> real_ops_my_thing(3) -2 >>> from decimal import Decimal >>> real_ops_my_thing(Decimal(\"2.5\")) Decimal('-1') >>> import sympy >>> real_ops_my_thing(sympy.Float(3.5)) -2 >>> type(_) <class 'sympy.core.numbers.Integer'> >>> # error: Value of type variable \"MyRealOpsT\" of \"real_ops_my_thing\" cannot be \"str\" >>> real_ops_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\"","title":"SupportsRealOps"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps","text":"Bases: _SupportsIntegralOps [ _T_co ] , Protocol , Generic [ _T_co ] A caching ABC defining the Integral operator methods with covariant return values. ( _SupportsIntegralOps is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsIntegralOps >>> MyIntegralOpsT = TypeVar ( \"MyIntegralOpsT\" , bound = SupportsIntegralOps ) >>> def integral_ops_my_thing ( arg : MyIntegralOpsT ) -> MyIntegralOpsT : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg << 1 >>> integral_ops_my_thing ( 3 ) 6 >>> import sympy >>> integral_ops_my_thing ( sympy . Integer ( 3 )) 6 >>> type ( _ ) < class ' sympy . core . numbers . Integer '> >>> # error: Value of type variable \"MyIntegralOpsT\" of \"integral_ops_my_thing\" cannot be \"str\" >>> integral_ops_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 @runtime_checkable class SupportsIntegralOps ( _SupportsIntegralOps [ _T_co ], Protocol , Generic [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``Integral`` operator methods](https://docs.python.org/3/library/numbers.html#numbers.Integral) with covariant return values. ([``_SupportsIntegralOps``][numerary.types._SupportsIntegralOps] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsIntegralOps >>> MyIntegralOpsT = TypeVar(\"MyIntegralOpsT\", bound=SupportsIntegralOps) >>> def integral_ops_my_thing(arg: MyIntegralOpsT) -> MyIntegralOpsT: ... assert isinstance(arg, SupportsIntegralOps) ... return arg << 1 >>> integral_ops_my_thing(3) 6 >>> import sympy >>> integral_ops_my_thing(sympy.Integer(3)) 6 >>> type(_) <class 'sympy.core.numbers.Integer'> >>> # error: Value of type variable \"MyIntegralOpsT\" of \"integral_ops_my_thing\" cannot be \"str\" >>> integral_ops_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\"","title":"SupportsIntegralOps"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow","text":"Bases: _SupportsIntegralPow , Protocol A caching ABC defining the Integral (i.e., modulo) versions of the __pow__ and __rpow__ methods. ( _SupportsIntegralPow is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from beartype.typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsIntegralPow >>> MyIntegralPowT = TypeVar ( \"MyIntegralPowT\" , bound = SupportsIntegralPow ) >>> def integral_pow_my_thing ( arg : MyIntegralPowT ) -> MyIntegralPowT : ... assert isinstance ( arg , SupportsIntegralPow ) ... return pow ( arg , 2 , 2 ) >>> integral_pow_my_thing ( 3 ) 1 >>> import sympy >>> integral_pow_my_thing ( sympy . Integer ( 3 )) 1 >>> type ( _ ) < class ' int '> >>> # error: Value of type variable \"MyIntegralPowT\" of \"integral_pow_my_thing\" cannot be \"str\" >>> integral_pow_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 @runtime_checkable class SupportsIntegralPow ( _SupportsIntegralPow , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the ``#!python Integral`` (i.e., modulo) versions of the [``__pow__``](https://docs.python.org/3/reference/datamodel.html#object.__pow__) and [``__rpow__``](https://docs.python.org/3/reference/datamodel.html#object.__rpow__) methods. ([``_SupportsIntegralPow``][numerary.types._SupportsIntegralPow] is the raw, non-caching version that defines the actual methods.) ``` python >>> from beartype.typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsIntegralPow >>> MyIntegralPowT = TypeVar(\"MyIntegralPowT\", bound=SupportsIntegralPow) >>> def integral_pow_my_thing(arg: MyIntegralPowT) -> MyIntegralPowT: ... assert isinstance(arg, SupportsIntegralPow) ... return pow(arg, 2, 2) >>> integral_pow_my_thing(3) 1 >>> import sympy >>> integral_pow_my_thing(sympy.Integer(3)) 1 >>> type(_) <class 'int'> >>> # error: Value of type variable \"MyIntegralPowT\" of \"integral_pow_my_thing\" cannot be \"str\" >>> integral_pow_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\"","title":"SupportsIntegralPow"},{"location":"numerary.types/#numerary.types.real","text":"Helper function that extracts the real part from operand including resolving non-compliant implementations that implement such extraction via a as_real_imag method rather than as properties. 1 2 3 4 >>> import sympy >>> from numerary.types import real >>> real ( sympy . Float ( 3.5 )) 3.5 See SupportsRealImag and SupportsRealImagAsMethod . Source code in numerary/types.py 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 @beartype def real ( operand : SupportsRealImagMixedU ): r \"\"\" Helper function that extracts the real part from *operand* including resolving non-compliant implementations that implement such extraction via a ``as_real_imag`` method rather than as properties. ``` python >>> import sympy >>> from numerary.types import real >>> real(sympy.Float(3.5)) 3.5 ``` See [SupportsRealImag][numerary.types.SupportsRealImag] and [SupportsRealImagAsMethod][numerary.types.SupportsRealImagAsMethod]. \"\"\" if callable ( getattr ( operand , \"as_real_imag\" , None )): real_part , _ = operand . as_real_imag () # type: ignore [union-attr] return real_part elif hasattr ( operand , \"real\" ): return operand . real # type: ignore [union-attr] else : raise TypeError ( f \" { operand !r} has no real or as_real_imag\" )","title":"real()"},{"location":"numerary.types/#numerary.types.imag","text":"Helper function that extracts the imaginary part from operand including resolving non-compliant implementations that implement such extraction via a as_real_imag method rather than as properties. 1 2 3 4 >>> import sympy >>> from numerary.types import real >>> imag ( sympy . Float ( 3.5 )) 0 See SupportsRealImag and SupportsRealImagAsMethod . Source code in numerary/types.py 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 @beartype def imag ( operand : SupportsRealImagMixedU ): r \"\"\" Helper function that extracts the imaginary part from *operand* including resolving non-compliant implementations that implement such extraction via a ``as_real_imag`` method rather than as properties. ``` python >>> import sympy >>> from numerary.types import real >>> imag(sympy.Float(3.5)) 0 ``` See [SupportsRealImag][numerary.types.SupportsRealImag] and [SupportsRealImagAsMethod][numerary.types.SupportsRealImagAsMethod]. \"\"\" if callable ( getattr ( operand , \"as_real_imag\" , None )): _ , imag_part = operand . as_real_imag () # type: ignore [union-attr] return imag_part elif hasattr ( operand , \"imag\" ): return operand . imag # type: ignore [union-attr] else : raise TypeError ( f \" { operand !r} has no real or as_real_imag\" )","title":"imag()"},{"location":"numerary.types/#numerary.types.__pow__","text":"Helper function that wraps pow to work with SupportsComplexPow , SupportsIntegralPow . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 >>> from numerary.types import SupportsComplexPow , SupportsIntegralPow , __pow__ >>> my_complex_pow : SupportsComplexPow = complex ( 2 ) >>> __pow__ ( my_complex_pow , 1 ) ( 2 + 0 j ) >>> __pow__ ( my_complex_pow , 1 , None ) ( 2 + 0 j ) >>> __pow__ ( my_complex_pow , 1 , 1 ) # type: ignore [operator] # properly caught by Mypy Traceback ( most recent call last ): ... ValueError : complex modulo >>> my_complex_pow = 1.2 >>> __pow__ ( my_complex_pow , 1 ) 1.2 >>> __pow__ ( my_complex_pow , 1 , None ) 1.2 >>> __pow__ ( my_complex_pow , 1 , 1 ) # ugh; *not* caught by Mypy because it treats floats as equivalent to ints? Traceback ( most recent call last ): ... TypeError : pow () 3 rd argument not allowed unless all arguments are integers >>> from fractions import Fraction >>> my_complex_pow = Fraction ( 1 , 2 ) >>> __pow__ ( my_complex_pow , 1 ) Fraction ( 1 , 2 ) >>> __pow__ ( my_complex_pow , 1 , None ) Fraction ( 1 , 2 ) >>> __pow__ ( my_complex_pow , 1 , 1 ) # type: ignore [operator] # properly caught by Mypy Traceback ( most recent call last ): ... TypeError : __pow__ () takes 2 positional arguments but 3 were given >>> from decimal import Decimal >>> my_integral_pow : SupportsIntegralPow = Decimal ( \"2\" ) >>> __pow__ ( my_integral_pow , 1 ) Decimal ( '2' ) >>> __pow__ ( my_integral_pow , 1 , None ) Decimal ( '2' ) >>> __pow__ ( my_integral_pow , 1 , 2 ) Decimal ( '0' ) >>> my_integral_pow = Decimal ( \"1.2\" ) # ruh-roh >>> __pow__ ( my_integral_pow , 1 ) Decimal ( '1.2' ) >>> __pow__ ( my_integral_pow , 1 , None ) Decimal ( '1.2' ) >>> __pow__ ( my_integral_pow , 1 , 2 ) # not catchable by Mypy, since it works *some* of the time Traceback ( most recent call last ): ... decimal . InvalidOperation : [ < class ' decimal . InvalidOperation '>] >>> my_integral_pow = 2 >>> __pow__ ( my_integral_pow , 1 ) 2 >>> __pow__ ( my_integral_pow , 1 , None ) 2 >>> __pow__ ( my_integral_pow , 1 , 2 ) 0 Source code in numerary/types.py 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 @beartype def __pow__ ( arg : Union [ SupportsComplexPow , SupportsIntegralPow ], exponent : Any , modulus : Optional [ Any ] = None , ) -> Any : r \"\"\" Helper function that wraps ``pow`` to work with [``SupportsComplexPow``][numerary.types.SupportsComplexPow], [``SupportsIntegralPow``][numerary.types.SupportsIntegralPow]. ``` python >>> from numerary.types import SupportsComplexPow, SupportsIntegralPow, __pow__ >>> my_complex_pow: SupportsComplexPow = complex(2) >>> __pow__(my_complex_pow, 1) (2+0j) >>> __pow__(my_complex_pow, 1, None) (2+0j) >>> __pow__(my_complex_pow, 1, 1) # type: ignore [operator] # properly caught by Mypy Traceback (most recent call last): ... ValueError: complex modulo >>> my_complex_pow = 1.2 >>> __pow__(my_complex_pow, 1) 1.2 >>> __pow__(my_complex_pow, 1, None) 1.2 >>> __pow__(my_complex_pow, 1, 1) # ugh; *not* caught by Mypy because it treats floats as equivalent to ints? Traceback (most recent call last): ... TypeError: pow() 3rd argument not allowed unless all arguments are integers >>> from fractions import Fraction >>> my_complex_pow = Fraction(1, 2) >>> __pow__(my_complex_pow, 1) Fraction(1, 2) >>> __pow__(my_complex_pow, 1, None) Fraction(1, 2) >>> __pow__(my_complex_pow, 1, 1) # type: ignore [operator] # properly caught by Mypy Traceback (most recent call last): ... TypeError: __pow__() takes 2 positional arguments but 3 were given >>> from decimal import Decimal >>> my_integral_pow: SupportsIntegralPow = Decimal(\"2\") >>> __pow__(my_integral_pow, 1) Decimal('2') >>> __pow__(my_integral_pow, 1, None) Decimal('2') >>> __pow__(my_integral_pow, 1, 2) Decimal('0') >>> my_integral_pow = Decimal(\"1.2\") # ruh-roh >>> __pow__(my_integral_pow, 1) Decimal('1.2') >>> __pow__(my_integral_pow, 1, None) Decimal('1.2') >>> __pow__(my_integral_pow, 1, 2) # not catchable by Mypy, since it works *some* of the time Traceback (most recent call last): ... decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>] >>> my_integral_pow = 2 >>> __pow__(my_integral_pow, 1) 2 >>> __pow__(my_integral_pow, 1, None) 2 >>> __pow__(my_integral_pow, 1, 2) 0 ``` \"\"\" return pow ( arg , exponent , modulus )","title":"__pow__()"},{"location":"numerary.types/#numerary.types.__trunc__","text":"Helper function that wraps math.trunc . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsTrunc , __trunc__ >>> my_trunc : SupportsTrunc >>> my_trunc = 1 >>> __trunc__ ( my_trunc ) 1 >>> from fractions import Fraction >>> my_trunc = Fraction ( 1 , 2 ) >>> __trunc__ ( my_trunc ) 0 >>> my_trunc_float : SupportsFloat = 1.2 >>> __trunc__ ( my_trunc_float ) 1 Source code in numerary/types.py 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 @beartype def __trunc__ ( operand : Union [ SupportsFloat , SupportsTrunc ]): r \"\"\" Helper function that wraps ``math.trunc``. ``` python >>> from numerary.types import SupportsFloat, SupportsTrunc, __trunc__ >>> my_trunc: SupportsTrunc >>> my_trunc = 1 >>> __trunc__(my_trunc) 1 >>> from fractions import Fraction >>> my_trunc = Fraction(1, 2) >>> __trunc__(my_trunc) 0 >>> my_trunc_float: SupportsFloat = 1.2 >>> __trunc__(my_trunc_float) 1 ``` \"\"\" return math . trunc ( operand ) # type: ignore [arg-type]","title":"__trunc__()"},{"location":"numerary.types/#numerary.types.__floor__","text":"Helper function that wraps math.floor . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsFloorCeil , __floor__ >>> my_floor : SupportsFloorCeil >>> my_floor = 1 >>> __floor__ ( my_floor ) 1 >>> from fractions import Fraction >>> my_floor = Fraction ( 1 , 2 ) >>> __floor__ ( my_floor ) 0 >>> my_floor_float : SupportsFloat = 1.2 >>> __floor__ ( my_floor_float ) 1 Source code in numerary/types.py 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 @beartype def __floor__ ( operand : Union [ SupportsFloat , SupportsFloorCeil ]): r \"\"\" Helper function that wraps ``math.floor``. ``` python >>> from numerary.types import SupportsFloat, SupportsFloorCeil, __floor__ >>> my_floor: SupportsFloorCeil >>> my_floor = 1 >>> __floor__(my_floor) 1 >>> from fractions import Fraction >>> my_floor = Fraction(1, 2) >>> __floor__(my_floor) 0 >>> my_floor_float: SupportsFloat = 1.2 >>> __floor__(my_floor_float) 1 ``` \"\"\" return math . floor ( operand ) # type: ignore [arg-type]","title":"__floor__()"},{"location":"numerary.types/#numerary.types.__ceil__","text":"Helper function that wraps math.ceil . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsFloorCeil , __ceil__ >>> my_ceil : SupportsFloorCeil >>> my_ceil = 1 >>> __ceil__ ( my_ceil ) 1 >>> from fractions import Fraction >>> my_ceil = Fraction ( 1 , 2 ) >>> __ceil__ ( my_ceil ) 1 >>> my_ceil_float : SupportsFloat = 1.2 >>> __ceil__ ( my_ceil_float ) 2 Source code in numerary/types.py 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 @beartype def __ceil__ ( operand : Union [ SupportsFloat , SupportsFloorCeil ]): r \"\"\" Helper function that wraps ``math.ceil``. ``` python >>> from numerary.types import SupportsFloat, SupportsFloorCeil, __ceil__ >>> my_ceil: SupportsFloorCeil >>> my_ceil = 1 >>> __ceil__(my_ceil) 1 >>> from fractions import Fraction >>> my_ceil = Fraction(1, 2) >>> __ceil__(my_ceil) 1 >>> my_ceil_float: SupportsFloat = 1.2 >>> __ceil__(my_ceil_float) 2 ``` \"\"\" return math . ceil ( operand ) # type: ignore [arg-type]","title":"__ceil__()"},{"location":"numerary.types/#numerary.types.numerator","text":"Helper function that extracts the numerator from operand including resolving non-compliant rational implementations that implement numerator as a method rather than a property. 1 2 3 4 >>> from fractions import Fraction >>> from numerary.types import numerator >>> numerator ( Fraction ( 22 , 7 )) 22 See SupportsNumeratorDenominator and SupportsNumeratorDenominatorMethods . Source code in numerary/types.py 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 @beartype def numerator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" Helper function that extracts the numerator from *operand* including resolving non-compliant rational implementations that implement ``numerator`` as a method rather than a property. ``` python >>> from fractions import Fraction >>> from numerary.types import numerator >>> numerator(Fraction(22, 7)) 22 ``` See [SupportsNumeratorDenominator][numerary.types.SupportsNumeratorDenominator] and [SupportsNumeratorDenominatorMethods][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" if hasattr ( operand , \"numerator\" ): if callable ( operand . numerator ): return operand . numerator () else : return operand . numerator else : raise TypeError ( f \" { operand !r} has no numerator\" )","title":"numerator()"},{"location":"numerary.types/#numerary.types.denominator","text":"Helper function that extracts the denominator from operand including resolving non-compliant rational implementations that implement denominator as a method rather than a property. 1 2 3 4 >>> from fractions import Fraction >>> from numerary.types import denominator >>> denominator ( Fraction ( 22 , 7 )) 7 See SupportsNumeratorDenominator and SupportsNumeratorDenominatorMethods . Source code in numerary/types.py 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 @beartype def denominator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" Helper function that extracts the denominator from *operand* including resolving non-compliant rational implementations that implement ``denominator`` as a method rather than a property. ``` python >>> from fractions import Fraction >>> from numerary.types import denominator >>> denominator(Fraction(22, 7)) 7 ``` See [SupportsNumeratorDenominator][numerary.types.SupportsNumeratorDenominator] and [SupportsNumeratorDenominatorMethods][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" if hasattr ( operand , \"denominator\" ): if callable ( operand . denominator ): return operand . denominator () else : return operand . denominator else : raise TypeError ( f \" { operand !r} has no denominator\" )","title":"denominator()"},{"location":"numerary.types/#numerary.types.RationalLikeMixedT","text":"","title":"RationalLikeMixedT"},{"location":"numerary.types/#numerary.types.RationalLikeMixedU","text":"","title":"RationalLikeMixedU"},{"location":"numerary.types/#numerary.types.SupportsRealImagMixedT","text":"","title":"SupportsRealImagMixedT"},{"location":"numerary.types/#numerary.types.SupportsRealImagMixedU","text":"","title":"SupportsRealImagMixedU"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMixedT","text":"","title":"SupportsNumeratorDenominatorMixedT"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMixedU","text":"","title":"SupportsNumeratorDenominatorMixedU"},{"location":"numerary.types/#numerary.types._SupportsConjugate","text":"Bases: _Protocol The non-caching version of SupportsConjugate . Source code in numerary/types.py 154 155 156 157 158 159 160 161 162 163 @runtime_checkable class _SupportsConjugate ( _Protocol ): r \"\"\" The non-caching version of [``SupportsConjugate``][numerary.types.SupportsConjugate]. \"\"\" @abstractmethod def conjugate ( self ) -> Any : pass","title":"_SupportsConjugate"},{"location":"numerary.types/#numerary.types._SupportsConjugate.conjugate","text":"Source code in numerary/types.py 161 162 163 @abstractmethod def conjugate ( self ) -> Any : pass","title":"conjugate()"},{"location":"numerary.types/#numerary.types._SupportsRealImag","text":"Bases: _Protocol The non-caching version of SupportsRealImag . Source code in numerary/types.py 216 217 218 219 220 221 222 223 224 225 226 227 228 @runtime_checkable class _SupportsRealImag ( _Protocol ): r \"\"\" The non-caching version of [``SupportsRealImag``][numerary.types.SupportsRealImag]. \"\"\" @property def real ( self ) -> Any : pass @property def imag ( self ) -> Any : pass","title":"_SupportsRealImag"},{"location":"numerary.types/#numerary.types._SupportsRealImag.imag","text":"Source code in numerary/types.py 226 227 228 @property def imag ( self ) -> Any : pass","title":"imag()"},{"location":"numerary.types/#numerary.types._SupportsRealImag.real","text":"Source code in numerary/types.py 222 223 224 @property def real ( self ) -> Any : pass","title":"real()"},{"location":"numerary.types/#numerary.types._SupportsRealImagAsMethod","text":"Bases: _Protocol The non-caching version of SupportsRealImagAsMethod . Source code in numerary/types.py 275 276 277 278 279 280 281 282 283 284 @runtime_checkable class _SupportsRealImagAsMethod ( _Protocol ): r \"\"\" The non-caching version of [``SupportsRealImagAsMethod``][numerary.types.SupportsRealImagAsMethod]. \"\"\" @abstractmethod def as_real_imag ( self ) -> Tuple [ Any , Any ]: pass","title":"_SupportsRealImagAsMethod"},{"location":"numerary.types/#numerary.types._SupportsRealImagAsMethod.as_real_imag","text":"Source code in numerary/types.py 282 283 284 @abstractmethod def as_real_imag ( self ) -> Tuple [ Any , Any ]: pass","title":"as_real_imag()"},{"location":"numerary.types/#numerary.types._SupportsTrunc","text":"Bases: _Protocol The non-caching version of SupportsTrunc . Source code in numerary/types.py 344 345 346 347 348 349 350 351 352 @runtime_checkable class _SupportsTrunc ( _Protocol ): r \"\"\" The non-caching version of [``SupportsTrunc``][numerary.types.SupportsTrunc]. \"\"\" @abstractmethod def __trunc__ ( self ) -> int : pass","title":"_SupportsTrunc"},{"location":"numerary.types/#numerary.types._SupportsTrunc.__trunc__","text":"Source code in numerary/types.py 350 351 352 @abstractmethod def __trunc__ ( self ) -> int : pass","title":"__trunc__()"},{"location":"numerary.types/#numerary.types._SupportsFloorCeil","text":"Bases: _Protocol The non-caching version of SupportsFloorCeil . Source code in numerary/types.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 @runtime_checkable class _SupportsFloorCeil ( _Protocol ): r \"\"\" The non-caching version of [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil]. \"\"\" @abstractmethod def __floor__ ( self ) -> int : pass @abstractmethod def __ceil__ ( self ) -> int : pass","title":"_SupportsFloorCeil"},{"location":"numerary.types/#numerary.types._SupportsFloorCeil.__ceil__","text":"Source code in numerary/types.py 416 417 418 @abstractmethod def __ceil__ ( self ) -> int : pass","title":"__ceil__()"},{"location":"numerary.types/#numerary.types._SupportsFloorCeil.__floor__","text":"Source code in numerary/types.py 412 413 414 @abstractmethod def __floor__ ( self ) -> int : pass","title":"__floor__()"},{"location":"numerary.types/#numerary.types._SupportsDivmod","text":"Bases: _Protocol , Generic [ _T_co ] The non-caching version of SupportsDivmod . Source code in numerary/types.py 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 @runtime_checkable class _SupportsDivmod ( _Protocol , Generic [ _T_co ], ): r \"\"\" The non-caching version of [``SupportsDivmod``][numerary.types.SupportsDivmod]. \"\"\" @abstractmethod def __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass @abstractmethod def __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass","title":"_SupportsDivmod"},{"location":"numerary.types/#numerary.types._SupportsDivmod.__divmod__","text":"Source code in numerary/types.py 497 498 499 @abstractmethod def __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass","title":"__divmod__()"},{"location":"numerary.types/#numerary.types._SupportsDivmod.__rdivmod__","text":"Source code in numerary/types.py 501 502 503 @abstractmethod def __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass","title":"__rdivmod__()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominator","text":"Bases: _Protocol The non-caching version of SupportsNumeratorDenominator . Source code in numerary/types.py 560 561 562 563 564 565 566 567 568 569 570 571 572 573 @runtime_checkable class _SupportsNumeratorDenominator ( _Protocol ): r \"\"\" The non-caching version of [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator]. \"\"\" @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass","title":"_SupportsNumeratorDenominator"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominator.denominator","text":"Source code in numerary/types.py 571 572 573 @property def denominator ( self ) -> int : pass","title":"denominator()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominator.numerator","text":"Source code in numerary/types.py 567 568 569 @property def numerator ( self ) -> int : pass","title":"numerator()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods","text":"Bases: _Protocol The non-caching version of SupportsNumeratorDenominatorMethods . Source code in numerary/types.py 627 628 629 630 631 632 633 634 635 636 637 638 639 640 @runtime_checkable class _SupportsNumeratorDenominatorMethods ( _Protocol ): r \"\"\" The non-caching version of [``SupportsNumeratorDenominatorMethods``][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" @abstractmethod def numerator ( self ) -> SupportsInt : pass @abstractmethod def denominator ( self ) -> SupportsInt : pass","title":"_SupportsNumeratorDenominatorMethods"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods.denominator","text":"Source code in numerary/types.py 638 639 640 @abstractmethod def denominator ( self ) -> SupportsInt : pass","title":"denominator()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods.numerator","text":"Source code in numerary/types.py 634 635 636 @abstractmethod def numerator ( self ) -> SupportsInt : pass","title":"numerator()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps","text":"Bases: _Protocol , Generic [ _T_co ] The non-caching version of SupportsComplexOps . Source code in numerary/types.py 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 @runtime_checkable class _SupportsComplexOps ( _Protocol , Generic [ _T_co ], ): r \"\"\" The non-caching version of [``SupportsComplexOps``][numerary.types.SupportsComplexOps]. \"\"\" @abstractmethod def __add__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __radd__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __sub__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rsub__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __mul__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rmul__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __truediv__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rtruediv__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __neg__ ( self ) -> _T_co : pass @abstractmethod def __pos__ ( self ) -> _T_co : pass","title":"_SupportsComplexOps"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__add__","text":"Source code in numerary/types.py 689 690 691 @abstractmethod def __add__ ( self , other : Any ) -> _T_co : pass","title":"__add__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__mul__","text":"Source code in numerary/types.py 705 706 707 @abstractmethod def __mul__ ( self , other : Any ) -> _T_co : pass","title":"__mul__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__neg__","text":"Source code in numerary/types.py 721 722 723 @abstractmethod def __neg__ ( self ) -> _T_co : pass","title":"__neg__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__pos__","text":"Source code in numerary/types.py 725 726 727 @abstractmethod def __pos__ ( self ) -> _T_co : pass","title":"__pos__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__radd__","text":"Source code in numerary/types.py 693 694 695 @abstractmethod def __radd__ ( self , other : Any ) -> _T_co : pass","title":"__radd__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__rmul__","text":"Source code in numerary/types.py 709 710 711 @abstractmethod def __rmul__ ( self , other : Any ) -> _T_co : pass","title":"__rmul__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__rsub__","text":"Source code in numerary/types.py 701 702 703 @abstractmethod def __rsub__ ( self , other : Any ) -> _T_co : pass","title":"__rsub__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__rtruediv__","text":"Source code in numerary/types.py 717 718 719 @abstractmethod def __rtruediv__ ( self , other : Any ) -> _T_co : pass","title":"__rtruediv__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__sub__","text":"Source code in numerary/types.py 697 698 699 @abstractmethod def __sub__ ( self , other : Any ) -> _T_co : pass","title":"__sub__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__truediv__","text":"Source code in numerary/types.py 713 714 715 @abstractmethod def __truediv__ ( self , other : Any ) -> _T_co : pass","title":"__truediv__()"},{"location":"numerary.types/#numerary.types._SupportsComplexPow","text":"Bases: _Protocol The non-caching version of SupportsComplexPow . Source code in numerary/types.py 780 781 782 783 784 785 786 787 788 789 790 791 792 793 @runtime_checkable class _SupportsComplexPow ( _Protocol ): r \"\"\" The non-caching version of [``SupportsComplexPow``][numerary.types.SupportsComplexPow]. \"\"\" @abstractmethod def __pow__ ( self , exponent : Any ) -> Any : pass @abstractmethod def __rpow__ ( self , exponent : Any ) -> Any : pass","title":"_SupportsComplexPow"},{"location":"numerary.types/#numerary.types._SupportsComplexPow.__pow__","text":"Source code in numerary/types.py 787 788 789 @abstractmethod def __pow__ ( self , exponent : Any ) -> Any : pass","title":"__pow__()"},{"location":"numerary.types/#numerary.types._SupportsComplexPow.__rpow__","text":"Source code in numerary/types.py 791 792 793 @abstractmethod def __rpow__ ( self , exponent : Any ) -> Any : pass","title":"__rpow__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps","text":"Bases: _Protocol , Generic [ _T_co ] The non-caching version of SupportsRealOps . Source code in numerary/types.py 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 @runtime_checkable class _SupportsRealOps ( _Protocol , Generic [ _T_co ], ): r \"\"\" The non-caching version of [``SupportsRealOps``][numerary.types.SupportsRealOps]. \"\"\" @abstractmethod def __lt__ ( self , other : Any ) -> bool : pass @abstractmethod def __le__ ( self , other : Any ) -> bool : pass @abstractmethod def __ge__ ( self , other : Any ) -> bool : pass @abstractmethod def __gt__ ( self , other : Any ) -> bool : pass @abstractmethod def __floordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass @abstractmethod def __rfloordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass @abstractmethod def __mod__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rmod__ ( self , other : Any ) -> _T_co : pass","title":"_SupportsRealOps"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__floordiv__","text":"Source code in numerary/types.py 870 871 872 @abstractmethod def __floordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass","title":"__floordiv__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__ge__","text":"Source code in numerary/types.py 862 863 864 @abstractmethod def __ge__ ( self , other : Any ) -> bool : pass","title":"__ge__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__gt__","text":"Source code in numerary/types.py 866 867 868 @abstractmethod def __gt__ ( self , other : Any ) -> bool : pass","title":"__gt__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__le__","text":"Source code in numerary/types.py 858 859 860 @abstractmethod def __le__ ( self , other : Any ) -> bool : pass","title":"__le__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__lt__","text":"Source code in numerary/types.py 854 855 856 @abstractmethod def __lt__ ( self , other : Any ) -> bool : pass","title":"__lt__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__mod__","text":"Source code in numerary/types.py 878 879 880 @abstractmethod def __mod__ ( self , other : Any ) -> _T_co : pass","title":"__mod__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__rfloordiv__","text":"Source code in numerary/types.py 874 875 876 @abstractmethod def __rfloordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass","title":"__rfloordiv__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__rmod__","text":"Source code in numerary/types.py 882 883 884 @abstractmethod def __rmod__ ( self , other : Any ) -> _T_co : pass","title":"__rmod__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps","text":"Bases: _Protocol , Generic [ _T_co ] The non-caching version of SupportsIntegralOps . Source code in numerary/types.py 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 @runtime_checkable class _SupportsIntegralOps ( _Protocol , Generic [ _T_co ], ): r \"\"\" The non-caching version of [``SupportsIntegralOps``][numerary.types.SupportsIntegralOps]. \"\"\" @abstractmethod def __lshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rlshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rrshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __and__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rand__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __xor__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rxor__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __or__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __ror__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __invert__ ( self ) -> _T_co : pass","title":"_SupportsIntegralOps"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__and__","text":"Source code in numerary/types.py 965 966 967 @abstractmethod def __and__ ( self , other : Any ) -> _T_co : pass","title":"__and__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__invert__","text":"Source code in numerary/types.py 989 990 991 @abstractmethod def __invert__ ( self ) -> _T_co : pass","title":"__invert__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__lshift__","text":"Source code in numerary/types.py 949 950 951 @abstractmethod def __lshift__ ( self , other : Any ) -> _T_co : pass","title":"__lshift__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__or__","text":"Source code in numerary/types.py 981 982 983 @abstractmethod def __or__ ( self , other : Any ) -> _T_co : pass","title":"__or__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rand__","text":"Source code in numerary/types.py 969 970 971 @abstractmethod def __rand__ ( self , other : Any ) -> _T_co : pass","title":"__rand__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rlshift__","text":"Source code in numerary/types.py 953 954 955 @abstractmethod def __rlshift__ ( self , other : Any ) -> _T_co : pass","title":"__rlshift__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__ror__","text":"Source code in numerary/types.py 985 986 987 @abstractmethod def __ror__ ( self , other : Any ) -> _T_co : pass","title":"__ror__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rrshift__","text":"Source code in numerary/types.py 961 962 963 @abstractmethod def __rrshift__ ( self , other : Any ) -> _T_co : pass","title":"__rrshift__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rshift__","text":"Source code in numerary/types.py 957 958 959 @abstractmethod def __rshift__ ( self , other : Any ) -> _T_co : pass","title":"__rshift__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rxor__","text":"Source code in numerary/types.py 977 978 979 @abstractmethod def __rxor__ ( self , other : Any ) -> _T_co : pass","title":"__rxor__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__xor__","text":"Source code in numerary/types.py 973 974 975 @abstractmethod def __xor__ ( self , other : Any ) -> _T_co : pass","title":"__xor__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow","text":"Bases: _Protocol The non-caching version of SupportsIntegralPow . Source code in numerary/types.py 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 @runtime_checkable class _SupportsIntegralPow ( _Protocol ): r \"\"\" The non-caching version of [``SupportsIntegralPow``][numerary.types.SupportsIntegralPow]. \"\"\" @abstractmethod def __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass @abstractmethod def __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass","title":"_SupportsIntegralPow"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow.__pow__","text":"Source code in numerary/types.py 1047 1048 1049 @abstractmethod def __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass","title":"__pow__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow.__rpow__","text":"Source code in numerary/types.py 1051 1052 1053 @abstractmethod def __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass I acknowledge that the subject of who is awesomer, beartype or the man who made it, is hotly contested . \u21a9","title":"__rpow__()"},{"location":"whytho/","text":"This story may feel familiar. If it does, you are in good company. Your pain is my pain. May it motivate us to grow and adapt. The calculation function\u2014An allegory We have a simple vision. We want to define an API that works with reals (not just float s), performs a calculation, and returns integers (not just int s). 1 2 3 4 5 >>> def deep_thought ( arg ): ... from time import sleep ... sleep ( 7_500_000 * 365.24219265 * 24 * 60 * 60 ) # doctest: +SKIP ... assert arg != 0 and arg ** 0 == 1 ... return 42 Native primitives We want to tell the world how to call it and what to expect in return, so we annotate it according to the standard advice to just use native types: 1 2 3 >>> def deep_thought_typed ( arg : float ) -> int : ... assert arg != 0 and arg ** 0 == 1 ... return 42 So simple! We\u2019re done, right? Not quite. We find that the runtime works well, but there are Mypy errors. 1 2 3 4 5 >>> deep_thought_typed ( 1.0 ) # this is fine ... 42 >>> from fractions import Fraction >>> deep_thought_typed ( Fraction ( 1 , 2 )) # type: ignore [arg-type] # ... but this fails 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_typed\" has incompatible type \"Fraction\"; expected \"float\" Numeric tower With a little research, we learn about the numeric tower [cue angelic singing] . Surely, it has the answer! Both float and Fraction are Real s. Let\u2019s test that to make sure. 1 2 3 4 5 6 7 >>> from numbers import Integral , Real >>> isinstance ( 42 , Integral ) True >>> isinstance ( 1.0 , Real ) True >>> isinstance ( Fraction ( 1 , 2 ), Real ) True Huzzah! What could be simpler? It appears a small tweak is all that is required! 1 2 3 >>> def deep_thought_towered ( arg : Real ) -> Integral : ... assert arg != 0 and arg ** 0 == 1 ... return 42 # type: ignore [return-value] # now this fails Without the # type: ignore , we get: 1 \u2026: error: Incompatible return value type (got \"int\", expected \"Integral\") Hold the phone. isinstance(42, Integral) was True , was it not? This is starting to get confusing. Erm \u2026 we mean native primitives or the numeric tower? 1 2 3 4 5 6 7 >>> from typing import Union >>> IntegralT = Union [ int , Integral ] >>> RealT = Union [ float , Real ] >>> def deep_thought_crumbling ( arg : RealT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 Well, that was odd , but such warts are a small price to pay. All is right in the world again! 1 2 3 4 5 6 7 >>> deep_thought_crumbling ( 1.0 ) 42 >>> deep_thought_crumbling ( Fraction ( 1 , 2 )) 42 >>> from decimal import Decimal >>> deep_thought_crumbling ( Decimal ( \"0.123\" )) # type: ignore [arg-type] # fail 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_crumbling\" has incompatible type \"Decimal\"; expected \"Union[float, Real]\" Oh, come on ! Native primitives, the numeric tower, or other things that define all the methods, but didn\u2019t (or couldn\u2019t) register in the numeric tower for some reason \ud83e\udd2c me. Do we just tack this onto the list? 1 2 3 4 5 6 7 >>> RealAndDecimalT = Union [ float , Real , Decimal ] >>> def deep_thought_toppled ( arg : RealAndDecimalT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 >>> deep_thought_toppled ( Decimal ( \"0.123\" )) 42 If we have to engage in these kinds of gymnastics just to reach escape velocity from the standard library, how the heck are we supposed to survive contact with numeric implementations we haven\u2019t even heard of yet?! We can\u2019t enumerate them all ! For many years, the numeric tower was declared a \u201cdead end\u201d by maintainers. Unsurprisingly, many longstanding library authors didn\u2019t see much benefit to conforming to its API. Adoption has grown, but we can\u2019t rely on it. What should we rely on, then? Surely the exalted few who have steered us away from one thing are prepared to steer us toward something else, no? Sadly, the apparent attitude of many seems to be, \u201cSomething, something, protocols? Meh. I don\u2019t know. We\u2019ll figure it out later.\u201d Protocols! Can we fix this with protocols? The standard library picked the low hanging fruit provides some simple precedents . Can we imitate those? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> from typing import Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsNumeratorDenominator ( Protocol ): ... @property ... def numerator ( self ) -> int : ... pass ... @property ... def denominator ( self ) -> int : ... pass >>> def require_rational ( arg : SupportsNumeratorDenominator ) -> None : ... assert isinstance ( arg , SupportsNumeratorDenominator ) >>> require_rational ( 1 ) # yup >>> require_rational ( Fraction ( 1 , 2 )) # nice >>> require_rational ( 1.0 ) # type: ignore [arg-type] # floats don't have numerator/denominator properties Traceback ( most recent call last ): ... AssertionError Without the # type: ignore , we get: 1 2 3 \u2026: error: Argument 1 to \"require_rational\" has incompatible type \"float\"; expected \"SupportsNumeratorDenominator\" \u2026: note: \"float\" is missing following \"SupportsNumeratorDenominator\" protocol members: \u2026: note: denominator, numerator Oh. My. Godetia. Could this be it? Have we stumbled into the promised land? Puh \u2026 ROH \u2026 tih \u2026 caaahhhlllz \u2026 ! Let\u2019s see how they perform. First, let\u2019s get a baseline. 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), Rational ) 238 ns \u00b1 3.91 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), Rational ) 233 ns \u00b1 2.49 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), Rational ) 249 ns \u00b1 1.67 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) Source: perf_rational_baseline.ipy 1 2 3 4 5 6 7 8 9 10 11 12 from fractions import Fraction from numbers import Rational one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) t = Rational for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) Now let\u2019s compare that with our two-property protocol. 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), SupportsNumeratorDenominator ) 10.2 \u00b5s \u00b1 136 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), SupportsNumeratorDenominator ) 10.4 \u00b5s \u00b1 177 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), SupportsNumeratorDenominator ) 10.5 \u00b5s \u00b1 171 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) Source: perf_rational_protocol.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from fractions import Fraction from numbers import Rational from typing import Any , Protocol , runtime_checkable one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) @runtime_checkable class SupportsNumeratorDenominator ( Protocol ): __slots__ : Any = () @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass t = SupportsNumeratorDenominator for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) That\u2019s forty times slower. \ud83d\ude36 And that\u2019s just with a two-property protocol. How much worse would it be if we had enumerated all the dunder methods? \ud83d\ude30 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), SupportsLotsOfNumberStuff ) 111 \u00b5s \u00b1 1.2 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 10 , 000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), SupportsLotsOfNumberStuff ) 117 \u00b5s \u00b1 2.69 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 10 , 000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), SupportsLotsOfNumberStuff ) 108 \u00b5s \u00b1 1.75 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 10 , 000 loops each ) Source: perf_rational_big_protocol.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 from fractions import Fraction from numbers import Rational from numerary.types import ( # \"raw\" (non-caching) versions _SupportsComplexOps , _SupportsConjugate , _SupportsFloorCeil , _SupportsDivmod , _SupportsRealImag , _SupportsRealOps , _SupportsTrunc , ) from typing import ( Any , Protocol , SupportsAbs , SupportsFloat , SupportsComplex , SupportsRound , runtime_checkable , ) one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) @runtime_checkable class SupportsLotsOfNumberStuff ( _SupportsRealOps , _SupportsComplexOps , _SupportsDivmod , _SupportsTrunc , _SupportsFloorCeil , _SupportsConjugate , _SupportsRealImag , SupportsAbs , SupportsFloat , SupportsComplex , SupportsRound , Protocol , ): __slots__ : Any = () @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass t = SupportsLotsOfNumberStuff for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) Over. Four. Hundred. Times. Slower. And that\u2019s not even all the methods! You know what? Never mind that. Where there\u2019s a will, there\u2019s a way. Note to self: Self, solve the performance problems with protocols later. But we\u2019re definitely onto something! Lies! Upon lies! Upon lies! All the way down! Let\u2019s do another one. Real numbers have comparisons that complex ones don\u2019t. That seems as good a place as any to tackle next. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore [misc] >>> from abc import abstractmethod >>> from typing import Any >>> @runtime_checkable ... class SupportsRealComparisons ( Protocol ): ... @abstractmethod ... def __lt__ ( self , other : Any ) -> bool : ... pass ... @abstractmethod ... def __le__ ( self , other : Any ) -> bool : ... pass ... @abstractmethod ... def __ge__ ( self , other : Any ) -> bool : ... pass ... @abstractmethod ... def __gt__ ( self , other : Any ) -> bool : ... pass >>> def require_real ( arg : SupportsRealComparisons ) -> None : ... assert isinstance ( arg , SupportsRealComparisons ) >>> require_real ( 1 ) >>> require_real ( Fraction ( 1 , 2 )) >>> require_real ( 1.0 ) >>> require_real ( complex ( 0 )) # type: ignore [arg-type] # should go ka-boom! Where was the ka-boom? There was supposed to be an earth-shattering ka-boom! Mypy spotted the error. Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"require_real\" has incompatible type \"complex\"; expected \"SupportsRealComparisons\" So what gives? Why does our protocol think a complex has comparisons at runtime? It\u2019s a complex number and complex numbers don\u2019t have those. The standard library says so ! 1 2 3 4 5 6 7 >>> from numbers import Complex >>> isinstance ( complex ( 0 ), Complex ) True >>> hasattr ( Complex , \"__le__\" ) True >>> complex ( 0 ) . __le__ # type: ignore [operator] <... method ... complex ...> What the shit? Do they work? 1 2 3 4 >>> complex ( 0 ) <= complex ( 0 ) # type: ignore [operator] Traceback ( most recent call last ): ... TypeError : '<=' not supported between instances of 'complex' and 'complex' Wait. Complex numbers implement comparisons in complete contradiction to the documentation just to return NotImplemented ?! \ud83e\udd2c off ! How does Mypy know? Because the type definitions for complex and Complex are lies that conveniently omit mention of those methods. Quote \u201cWhen it becomes serious, you have to lie.\u201d \u2014Jean-Claude Juncker Do you see?! Do you see now why we can\u2019t have nice things?! I mean, I get casting as a rare case, but who builds sophisticated deception tooling into the very fabric a type definition mechanism to claim that non-compliant native primitives comply? How can you trust anything anymore?! Shouldn\u2019t that be a pretty strong hint that maybe you should step back and rethink your approach? Astute readers may note beartype could help restore Truth for us. 1 2 3 4 5 6 7 8 9 10 from beartype import beartype from beartype.vale import Is from typing import Annotated SupportsRealComparisonsNotComplexLies = Annotated [ SupportsRealComparisons , Is [ lambda arg : not isinstance ( arg , complex )] ] @beartype def require_real ( arg : SupportsRealComparisonsNotComplexLies ) -> None : assert isinstance ( arg , SupportsRealComparisonsNotComplexLies ) That\u2019s because Bear is hip to the scene. Bear is down . Bear knows what\u2019s what. If you have a typing problem, if no one else can help, and if you can find them 1 , maybe you can hire the Bear-Team. I digress. What do we do?! Okay. Can we still work with any of this shit and have type-checking? Let\u2019s try. Because somebody \ud83e\udd2cing has to. That should be easy I just gave you the link . Twice . \u21a9","title":"Why would you do this?"},{"location":"whytho/#the-calculation-functionan-allegory","text":"We have a simple vision. We want to define an API that works with reals (not just float s), performs a calculation, and returns integers (not just int s). 1 2 3 4 5 >>> def deep_thought ( arg ): ... from time import sleep ... sleep ( 7_500_000 * 365.24219265 * 24 * 60 * 60 ) # doctest: +SKIP ... assert arg != 0 and arg ** 0 == 1 ... return 42","title":"The calculation function\u2014An allegory"},{"location":"whytho/#native-primitives","text":"We want to tell the world how to call it and what to expect in return, so we annotate it according to the standard advice to just use native types: 1 2 3 >>> def deep_thought_typed ( arg : float ) -> int : ... assert arg != 0 and arg ** 0 == 1 ... return 42 So simple! We\u2019re done, right? Not quite. We find that the runtime works well, but there are Mypy errors. 1 2 3 4 5 >>> deep_thought_typed ( 1.0 ) # this is fine ... 42 >>> from fractions import Fraction >>> deep_thought_typed ( Fraction ( 1 , 2 )) # type: ignore [arg-type] # ... but this fails 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_typed\" has incompatible type \"Fraction\"; expected \"float\"","title":"Native primitives"},{"location":"whytho/#numeric-tower","text":"With a little research, we learn about the numeric tower [cue angelic singing] . Surely, it has the answer! Both float and Fraction are Real s. Let\u2019s test that to make sure. 1 2 3 4 5 6 7 >>> from numbers import Integral , Real >>> isinstance ( 42 , Integral ) True >>> isinstance ( 1.0 , Real ) True >>> isinstance ( Fraction ( 1 , 2 ), Real ) True Huzzah! What could be simpler? It appears a small tweak is all that is required! 1 2 3 >>> def deep_thought_towered ( arg : Real ) -> Integral : ... assert arg != 0 and arg ** 0 == 1 ... return 42 # type: ignore [return-value] # now this fails Without the # type: ignore , we get: 1 \u2026: error: Incompatible return value type (got \"int\", expected \"Integral\") Hold the phone. isinstance(42, Integral) was True , was it not? This is starting to get confusing.","title":"Numeric tower"},{"location":"whytho/#erm-we-mean-native-primitives-or-the-numeric-tower","text":"1 2 3 4 5 6 7 >>> from typing import Union >>> IntegralT = Union [ int , Integral ] >>> RealT = Union [ float , Real ] >>> def deep_thought_crumbling ( arg : RealT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 Well, that was odd , but such warts are a small price to pay. All is right in the world again! 1 2 3 4 5 6 7 >>> deep_thought_crumbling ( 1.0 ) 42 >>> deep_thought_crumbling ( Fraction ( 1 , 2 )) 42 >>> from decimal import Decimal >>> deep_thought_crumbling ( Decimal ( \"0.123\" )) # type: ignore [arg-type] # fail 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_crumbling\" has incompatible type \"Decimal\"; expected \"Union[float, Real]\" Oh, come on !","title":"Erm \u2026 we mean native primitives or the numeric tower?"},{"location":"whytho/#native-primitives-the-numeric-tower-or-other-things-that-define-all-the-methods-but-didnt-or-couldnt-register-in-the-numeric-tower-for-some-reason","text":"\ud83e\udd2c me. Do we just tack this onto the list? 1 2 3 4 5 6 7 >>> RealAndDecimalT = Union [ float , Real , Decimal ] >>> def deep_thought_toppled ( arg : RealAndDecimalT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 >>> deep_thought_toppled ( Decimal ( \"0.123\" )) 42 If we have to engage in these kinds of gymnastics just to reach escape velocity from the standard library, how the heck are we supposed to survive contact with numeric implementations we haven\u2019t even heard of yet?! We can\u2019t enumerate them all ! For many years, the numeric tower was declared a \u201cdead end\u201d by maintainers. Unsurprisingly, many longstanding library authors didn\u2019t see much benefit to conforming to its API. Adoption has grown, but we can\u2019t rely on it. What should we rely on, then? Surely the exalted few who have steered us away from one thing are prepared to steer us toward something else, no? Sadly, the apparent attitude of many seems to be, \u201cSomething, something, protocols? Meh. I don\u2019t know. We\u2019ll figure it out later.\u201d","title":"Native primitives, the numeric tower, or other things that define all the methods, but didn\u2019t (or couldn\u2019t) register in the numeric tower for some reason"},{"location":"whytho/#protocols","text":"Can we fix this with protocols? The standard library picked the low hanging fruit provides some simple precedents . Can we imitate those? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> from typing import Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsNumeratorDenominator ( Protocol ): ... @property ... def numerator ( self ) -> int : ... pass ... @property ... def denominator ( self ) -> int : ... pass >>> def require_rational ( arg : SupportsNumeratorDenominator ) -> None : ... assert isinstance ( arg , SupportsNumeratorDenominator ) >>> require_rational ( 1 ) # yup >>> require_rational ( Fraction ( 1 , 2 )) # nice >>> require_rational ( 1.0 ) # type: ignore [arg-type] # floats don't have numerator/denominator properties Traceback ( most recent call last ): ... AssertionError Without the # type: ignore , we get: 1 2 3 \u2026: error: Argument 1 to \"require_rational\" has incompatible type \"float\"; expected \"SupportsNumeratorDenominator\" \u2026: note: \"float\" is missing following \"SupportsNumeratorDenominator\" protocol members: \u2026: note: denominator, numerator Oh. My. Godetia. Could this be it? Have we stumbled into the promised land?","title":"Protocols!"},{"location":"whytho/#puh-roh-tih-caaahhhlllz","text":"Let\u2019s see how they perform. First, let\u2019s get a baseline. 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), Rational ) 238 ns \u00b1 3.91 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), Rational ) 233 ns \u00b1 2.49 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), Rational ) 249 ns \u00b1 1.67 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1 , 000 , 000 loops each ) Source: perf_rational_baseline.ipy 1 2 3 4 5 6 7 8 9 10 11 12 from fractions import Fraction from numbers import Rational one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) t = Rational for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) Now let\u2019s compare that with our two-property protocol. 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), SupportsNumeratorDenominator ) 10.2 \u00b5s \u00b1 136 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), SupportsNumeratorDenominator ) 10.4 \u00b5s \u00b1 177 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), SupportsNumeratorDenominator ) 10.5 \u00b5s \u00b1 171 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100 , 000 loops each ) Source: perf_rational_protocol.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from fractions import Fraction from numbers import Rational from typing import Any , Protocol , runtime_checkable one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) @runtime_checkable class SupportsNumeratorDenominator ( Protocol ): __slots__ : Any = () @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass t = SupportsNumeratorDenominator for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) That\u2019s forty times slower. \ud83d\ude36 And that\u2019s just with a two-property protocol. How much worse would it be if we had enumerated all the dunder methods? \ud83d\ude30 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), SupportsLotsOfNumberStuff ) 111 \u00b5s \u00b1 1.2 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 10 , 000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), SupportsLotsOfNumberStuff ) 117 \u00b5s \u00b1 2.69 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 10 , 000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), SupportsLotsOfNumberStuff ) 108 \u00b5s \u00b1 1.75 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 10 , 000 loops each ) Source: perf_rational_big_protocol.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 from fractions import Fraction from numbers import Rational from numerary.types import ( # \"raw\" (non-caching) versions _SupportsComplexOps , _SupportsConjugate , _SupportsFloorCeil , _SupportsDivmod , _SupportsRealImag , _SupportsRealOps , _SupportsTrunc , ) from typing import ( Any , Protocol , SupportsAbs , SupportsFloat , SupportsComplex , SupportsRound , runtime_checkable , ) one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) @runtime_checkable class SupportsLotsOfNumberStuff ( _SupportsRealOps , _SupportsComplexOps , _SupportsDivmod , _SupportsTrunc , _SupportsFloorCeil , _SupportsConjugate , _SupportsRealImag , SupportsAbs , SupportsFloat , SupportsComplex , SupportsRound , Protocol , ): __slots__ : Any = () @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass t = SupportsLotsOfNumberStuff for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) Over. Four. Hundred. Times. Slower. And that\u2019s not even all the methods! You know what? Never mind that. Where there\u2019s a will, there\u2019s a way. Note to self: Self, solve the performance problems with protocols later. But we\u2019re definitely onto something!","title":"Puh \u2026 ROH \u2026 tih \u2026 caaahhhlllz \u2026 !"},{"location":"whytho/#lies-upon-lies-upon-lies-all-the-way-down","text":"Let\u2019s do another one. Real numbers have comparisons that complex ones don\u2019t. That seems as good a place as any to tackle next. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore [misc] >>> from abc import abstractmethod >>> from typing import Any >>> @runtime_checkable ... class SupportsRealComparisons ( Protocol ): ... @abstractmethod ... def __lt__ ( self , other : Any ) -> bool : ... pass ... @abstractmethod ... def __le__ ( self , other : Any ) -> bool : ... pass ... @abstractmethod ... def __ge__ ( self , other : Any ) -> bool : ... pass ... @abstractmethod ... def __gt__ ( self , other : Any ) -> bool : ... pass >>> def require_real ( arg : SupportsRealComparisons ) -> None : ... assert isinstance ( arg , SupportsRealComparisons ) >>> require_real ( 1 ) >>> require_real ( Fraction ( 1 , 2 )) >>> require_real ( 1.0 ) >>> require_real ( complex ( 0 )) # type: ignore [arg-type] # should go ka-boom! Where was the ka-boom? There was supposed to be an earth-shattering ka-boom! Mypy spotted the error. Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"require_real\" has incompatible type \"complex\"; expected \"SupportsRealComparisons\" So what gives? Why does our protocol think a complex has comparisons at runtime? It\u2019s a complex number and complex numbers don\u2019t have those. The standard library says so ! 1 2 3 4 5 6 7 >>> from numbers import Complex >>> isinstance ( complex ( 0 ), Complex ) True >>> hasattr ( Complex , \"__le__\" ) True >>> complex ( 0 ) . __le__ # type: ignore [operator] <... method ... complex ...> What the shit? Do they work? 1 2 3 4 >>> complex ( 0 ) <= complex ( 0 ) # type: ignore [operator] Traceback ( most recent call last ): ... TypeError : '<=' not supported between instances of 'complex' and 'complex' Wait. Complex numbers implement comparisons in complete contradiction to the documentation just to return NotImplemented ?! \ud83e\udd2c off ! How does Mypy know? Because the type definitions for complex and Complex are lies that conveniently omit mention of those methods. Quote \u201cWhen it becomes serious, you have to lie.\u201d \u2014Jean-Claude Juncker Do you see?! Do you see now why we can\u2019t have nice things?! I mean, I get casting as a rare case, but who builds sophisticated deception tooling into the very fabric a type definition mechanism to claim that non-compliant native primitives comply? How can you trust anything anymore?! Shouldn\u2019t that be a pretty strong hint that maybe you should step back and rethink your approach? Astute readers may note beartype could help restore Truth for us. 1 2 3 4 5 6 7 8 9 10 from beartype import beartype from beartype.vale import Is from typing import Annotated SupportsRealComparisonsNotComplexLies = Annotated [ SupportsRealComparisons , Is [ lambda arg : not isinstance ( arg , complex )] ] @beartype def require_real ( arg : SupportsRealComparisonsNotComplexLies ) -> None : assert isinstance ( arg , SupportsRealComparisonsNotComplexLies ) That\u2019s because Bear is hip to the scene. Bear is down . Bear knows what\u2019s what. If you have a typing problem, if no one else can help, and if you can find them 1 , maybe you can hire the Bear-Team. I digress.","title":"Lies! Upon lies! Upon lies! All the way down!"},{"location":"whytho/#what-do-we-do","text":"Okay. Can we still work with any of this shit and have type-checking? Let\u2019s try. Because somebody \ud83e\udd2cing has to. That should be easy I just gave you the link . Twice . \u21a9","title":"What do we do?!"}]}