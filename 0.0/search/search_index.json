{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Copyright and other protections apply. Please see the accompanying LICENSE file for rights and restrictions governing use of this software. All rights not expressly waived or licensed are reserved. If that file is missing or appears to be modified from its original, then please contact the author before viewing or using this software in any capacity. Are you defining a numeric interface that should work with more than just int s and float s? Are you annotating that interface for documentation and type checking? Were you excited by PEP 3141 \u2019s glitz and gloss promising a clean, straightforward number type definition mechanism, only to learn the hard way\u2014after many hours of searching, tweaking, hacking, and testing ever more convoluted code, again and again\u2014that you could\u2019t actually make it work with Python\u2019s type checking system? Do you now wonder whether numbers were something new to computing in general because nothing else would explain such a gaping hole in a programming language so popular with the STEM crowd that has been around since the early 1990s? Does the number 3186 haunt you in your dreams? Do you find yourself shouting to no one in particular, \u201cThere has to be a better way?\u201d Well I\u2019m here to tell you there ain\u2019t. But until there is, there\u2019s \u2026 numerary - now with Protocol Power\u2122 That\u2019s right! For a hopefully limited time, you too can benefit from someone else\u2019s deranged work-arounds for the enormous chasms in Python that lie between the esoteric fields of computation that are \u201ctyping\u201d and \u201cnumbers\u201d instead of having to develop your own out of sheer desperation from first principles ! numerary is a pure-Python codified rant for signaling that your interface is usable with non-native numeric primitives 1 without breaking type checking. If you\u2019re thinking that you shouldn\u2019t need a \ud83e\udd2cing library for that, you\u2019re right . numerary should enjoy no audience. It should not exist. Yet here we are. Its author gauges its success by how quickly it can be deleted as superfluous. (I\u2019m looking at you, maintainers.) numerary is licensed under the MIT License . See the accompanying LICENSE file for details. It should be considered experimental for now, but should settle down quickly. See the release notes for a summary of version-to-version changes. Source code is available on GitHub . If you find it lacking in any way, please don\u2019t hesitate to bring it to my attention . Customers dyce - a pure-Python library for modeling arbitrarily complex dice mechanics and mother birthing code base of numerary ! The next one could be you ! \ud83d\udc4b Do you have a project that suffers problems made slightly less annoying by numerary ? Let me know , and I\u2019ll promote it here! And don\u2019t forget to do your part in perpetuating gratuitous badge-ification! 1 2 3 4 <!-- Markdown --> As of version 0.4.1, ``dyce`` is [ ![numerary-encumbered ]( https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg )][numerary-encumbered]! [ numerary-encumbered ]: https://posita.github.io/numerary/ \"numerary-encumbered!\" 1 2 3 4 5 6 7 8 9 .. reStructuredText - see https://docutils.sourceforge.io/docs/ref/rst/directives.html#image As of version 0.4.1, ``dyce`` is |numerary-encumbered|! .. |numerary-encumbered| image :: https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg :align: top :target: https://posita.github.io/numerary/ :alt: numerary-encumbered 1 2 3 4 5 <!-- HTML --> As of version 0.4.1, < code > dyce </ code > is < a href = \"https://posita.github.io/numerary/\" >< img src = \"https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg\" alt = \"numerary-encumbered\" style = \"vertical-align: middle;\" ></ a > ! The calculation function, an allegory We have a simple vision. We want to define an API that works with reals (not just float s), performs a calculation, and returns integers (not just int s). 1 2 3 4 5 >>> from time import sleep >>> def deep_thought ( arg ): ... sleep ( 7_500_000 * 365.24219265 * 24 * 60 * 60 ) # doctest: +SKIP ... assert arg != 0 and arg ** 0 == 1 ... return 42 We want to tell the world how to call it and what to expect in return, so we annotate it: 1 2 3 >>> def deep_thought_typed ( arg : float ) -> int : ... assert arg != 0 and arg ** 0 == 1 ... return 42 So simple! We\u2019re done, right? Not quite. We find that the runtime works well, but we\u2019re getting type checking errors. 1 2 3 4 5 >>> deep_thought_typed ( 1.0 ) # this is fine ... 42 >>> from fractions import Fraction >>> deep_thought_typed ( Fraction ( 1 , 2 )) # type: ignore # ... but this fails 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_typed\" has incompatible type \"Fraction\"; expected \"float\" With a little research, we learn about the numeric tower [cue angelic singing] . Surely, it has the answer! Both float and Fraction are Real s. Let\u2019s test that to make sure. 1 2 3 4 5 6 7 >>> from numbers import Integral , Real >>> isinstance ( 42 , Integral ) True >>> isinstance ( 1.0 , Real ) True >>> isinstance ( Fraction ( 1 , 2 ), Real ) True Huzzah! What could be simpler? It appears a small tweak is all that is required! 1 2 3 >>> def deep_thought_towered ( arg : Real ) -> Integral : ... assert arg != 0 and arg ** 0 == 1 ... return 42 # type: ignore # now this fails Without the # type: ignore , we get: 1 \u2026: error: Incompatible return value type (got \"int\", expected \"Integral\") Hold the phone. isinstance(42, Integral) was True , was it not? This is starting to get confusing. 1 2 3 4 5 6 >>> from typing import Union >>> IntegralT = Union [ int , Integral ] >>> RealT = Union [ float , Real ] >>> def deep_thought_crumbling ( arg : RealT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 Well, that was odd , but such warts are a small price to pay. All is right in the world again! 1 2 3 4 5 6 7 >>> deep_thought_crumbling ( 1.0 ) 42 >>> deep_thought_crumbling ( Fraction ( 1 , 2 )) 42 >>> from decimal import Decimal >>> deep_thought_crumbling ( Decimal ( \"0.123\" )) # type: ignore # fails 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_crumbling\" has incompatible type \"Decimal\"; expected \"Union[float, Real]\" Oh, come on ! 1 2 3 4 5 6 >>> RealAndDecimalT = Union [ float , Real , Decimal ] >>> def deep_thought_toppled ( arg : RealAndDecimalT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 >>> deep_thought_toppled ( Decimal ( \"0.123\" )) 42 \ud83e\udd2c me. If we have to engage in these kinds of gymnastics just to reach escape velocity from the standard library, how the heck are we supposed to survive contact with numeric implementations we haven\u2019t even heard of yet?! We can\u2019t enumerate them all ! For many years, the numeric tower was declared a \u201cdead end\u201d by maintainers. Unsurprisingly, many longstanding library authors didn\u2019t see much benefit to conforming to its API. Adoption has grown, but we can\u2019t rely on it. What should we rely on, then? Surely the exalted few who have steered us away from one thing are prepared to steer us toward something else, no? Sadly, the apparent attitude of many seems to be, \u201cSomething, something, protocols? Meh. I don\u2019t know. We\u2019ll figure it out later.\u201d Can we fix this with protocols? The standard library provides some simple precedents . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore >>> from typing import Iterable , Union >>> @runtime_checkable ... class SupportsNumeratorDenominator ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @property ... def numerator ( self ) -> int : pass ... @property ... def denominator ( self ) -> int : pass >>> def require_rational ( arg : SupportsNumeratorDenominator ) -> None : ... assert isinstance ( arg , SupportsNumeratorDenominator ) >>> require_rational ( 1 ) >>> require_rational ( Fraction ( 1 , 2 )) >>> require_rational ( 1.0 ) # type: ignore Traceback ( most recent call last ): ... AssertionError Without the # type: ignore , we get: 1 2 3 \u2026: error: Argument 1 to \"require_rational\" has incompatible type \"float\"; expected \"SupportsNumeratorDenominator\" \u2026: note: \"float\" is missing following \"SupportsNumeratorDenominator\" protocol members: \u2026: note: denominator, numerator Oh. My. Godetia. Could this be it? Have we stumbled into the promised land? Let\u2019s see how they perform. First, let\u2019s get a baseline. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 In [ 11 ]: from fractions import Fraction ; from numbers import Rational In [ 12 ]: val = 1 In [ 13 ]: % timeit - r10 isinstance ( val , Rational ) 326 ns \u00b1 1.26 ns per loop ( mean \u00b1 std . dev . of 10 runs , 1000000 loops each ) In [ 14 ]: val = Fraction ( 1 , 2 ) In [ 15 ]: % timeit - r10 isinstance ( val , Rational ) 329 ns \u00b1 1.87 ns per loop ( mean \u00b1 std . dev . of 10 runs , 1000000 loops each ) In [ 16 ]: val = 1.0 In [ 17 ]: % timeit - r10 isinstance ( val , Rational ) 351 ns \u00b1 1.29 ns per loop ( mean \u00b1 std . dev . of 10 runs , 1000000 loops each ) Now let\u2019s compare that with our two-property protocol. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 In [ 20 ]: from numerary import SupportsNumeratorDenominator In [ 21 ]: val = 1 In [ 22 ]: % timeit - r10 isinstance ( val , SupportsNumeratorDenominator ) 12.2 \u00b5s \u00b1 203 ns per loop ( mean \u00b1 std . dev . of 10 runs , 100000 loops each ) In [ 23 ]: val = Fraction ( 1 , 2 ) In [ 24 ]: % timeit - r10 isinstance ( val , SupportsNumeratorDenominator ) 12.3 \u00b5s \u00b1 62 ns per loop ( mean \u00b1 std . dev . of 10 runs , 100000 loops each ) In [ 25 ]: val = 1.0 In [ 26 ]: % timeit - r10 isinstance ( val , SupportsNumeratorDenominator ) 12.4 \u00b5s \u00b1 97.8 ns per loop ( mean \u00b1 std . dev . of 10 runs , 100000 loops each ) That\u2019s forty times slower. \ud83d\ude36 And that\u2019s just with a two-property protocol. How much worse would it be if we had enumerated all the dunder methods? \ud83d\ude30 You know what? Never mind that. Where there\u2019s a will, there\u2019s a way. Note to self, \u201cSolve the performance problems with protocols later, but we\u2019re definitely onto something!\u201d Let\u2019s do another one. Real numbers have comparisons that complex ones don\u2019t. That seems as good a place as any to tackle next. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore >>> from abc import abstractmethod >>> from typing import Any , Iterable , Union >>> @runtime_checkable ... class SupportsRealComparisons ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @abstractmethod ... def __lt__ ( self , other : Any ) -> bool : pass ... @abstractmethod ... def __le__ ( self , other : Any ) -> bool : pass ... @abstractmethod ... def __ge__ ( self , other : Any ) -> bool : pass ... @abstractmethod ... def __gt__ ( self , other : Any ) -> bool : pass >>> def require_real ( arg : SupportsRealComparisons ) -> None : ... assert isinstance ( arg , SupportsRealComparisons ) >>> require_real ( 1 ) >>> require_real ( Fraction ( 1 , 2 )) >>> require_real ( 1.0 ) >>> require_real ( complex ( 0 )) # type: ignore # should go ka-boom! Where was the ka-boom? There was supposed to be an earth-shattering ka-boom! Type checking spotted the error. Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"require_real\" has incompatible type \"complex\"; expected \"SupportsRealComparisons\" So what gives? Why does our protocol think a complex has comparisons at runtime? It\u2019s a complex number and complex numbers don\u2019t have those. The standard library says so ! 1 2 3 4 5 6 7 >>> from numbers import Complex >>> isinstance ( complex ( 0 ), Complex ) True >>> hasattr ( Complex , \"__le__\" ) True >>> complex ( 0 ) . __le__ # type: ignore <... method ... complex ...> What the shit? Do they work? 1 2 3 4 >>> complex ( 0 ) <= complex ( 0 ) # type: ignore Traceback ( most recent call last ): ... TypeError : '<=' not supported between instances of 'complex' and 'complex' Wait. Complex numbers implement comparisons in complete contradiction to the documentation just to return NotImplemented ?! \ud83e\udd2c off ! How does Mypy know? Because the type definitions for complex and Complex are lies that conveniently omit mention of those methods. Quote \u201cWhen it becomes serious, you have to lie.\u201d \u2014Jean-Claude Juncker Do you see?! Do you see now why we can\u2019t have nice things?! I mean, I get casting as a rare case, but who builds sophisticated deception tooling into the very fabric a type definition mechanism to claim that non-compliant native primitives comply? How can you trust anything anymore?! Shouldn\u2019t that be a pretty strong hint that maybe you should step back and rethink your approach? Astute readers may note beartype could help restore Truth for us. 1 2 3 4 5 6 7 8 9 from beartype import beartype from beartype.vale import Is from typing import Annotated SupportsRealComparisonsNotComplexLies = Annotated [ SupportsRealComparisons , Is [ lambda arg : not isinstance ( arg , complex )] ] @beartype def require_real ( arg : SupportsRealComparisonsNotComplexLies ) -> None : assert isinstance ( arg , SupportsRealComparisonsNotComplexLies ) That\u2019s because Bear is hip to the scene. Bear is down . Bear knows what\u2019s what. If you have a typing problem, if no one else can help, and if you can find them 2 , maybe you can hire the Bear-Team. I digress. Okay. Can we still work with any of this shit and have type checking? Dunno. Let\u2019s try. Because somebody \ud83e\udd2cing has to. A taste numerary strives to define composable, efficient protocols that one can use to construct numeric requirements. It expands on the Supports pattern used in the standard library. For example, numerary.types.SupportsIntegralOps is a @typing.runtime_checkable protocol that approximates the unary and binary operators introduced by numbers.Integral . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 >>> from numerary.types import SupportsIntegralOps >>> def shift_right_one ( arg : SupportsIntegralOps ) -> SupportsIntegralOps : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg >> 1 >>> shift_right_one ( 2 ) 1 >>> from sympy import sympify >>> two = sympify ( \"2\" ) ; type ( two ) < class ' sympy . core . numbers . Integer '> >>> res = shift_right_one ( two ) ; res 1 >>> type ( res ) < class ' sympy . core . numbers . One '> >>> shift_right_one ( Fraction ( 1 , 2 )) # type: ignore # properly caught by Mypy Traceback ( most recent call last ): ... AssertionError Note Until 1.9, sympy.core.numbers.Integer lacked the requisite bitwise operators . numerary catches that! The above properly results in both a type checking error as well as a runtime failure for SymPy versions prior to 1.9. By default, protocols frustrate runtime type checking performance . numerary applies two distinct, layered optimization strategies: Cached __instancecheck__ results for numerary -defined protocols; and Short-circuit type enumerations. Cached __instancecheck__ results It caches, so it\u2019s faster. Bang. Done. (NSFW warning. Although, in retrospect, that warning probably should have been presented more prominently and earlier in this diatribe.) TODO(@posita): Describe how this works. Short-circuit type enumerations If the interface is to be used most often with native types ( int s, float s, bool s) or those registered with the numeric tower, there is an optimization to be had at runtime by short-circuiting protocol type checking. These come in two flavors. \u2026SCU objects which are Union s for compliant types. \u2026SCT tuples, which are identical to the corresponding Union arguments. These are useful for runtime checks (e.g., as the second argument to isinstance ). For example, for the aforementioned SupportsIntegralOps , numerary defines two additional interfaces (some details and safeguards omitted). 1 2 SupportsIntegralOpsSCU = Union [ int , bool , Integral , SupportsIntegralOps ] SupportsIntegralOpsSCT = ( int , bool , Integral , SupportsIntegralOps ) 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> from numerary.types import SupportsIntegralOpsSCU # for type annotations >>> from numerary.types import SupportsIntegralOpsSCT # for runtime checking >>> def shift_left_one ( arg : SupportsIntegralOpsSCU ) -> SupportsIntegralOpsSCU : ... assert isinstance ( arg , SupportsIntegralOpsSCT ) ... return arg << 1 >>> shift_left_one ( 1 ) 2 >>> shift_left_one ( sympify ( \"1\" )) 2 >>> shift_left_one ( Fraction ( 1 , 2 )) # type: ignore Traceback ( most recent call last ): ... AssertionError Why two? Because you can\u2019t do this: 1 isinstance ( 1 , Union [ int , Integral ]) # syntax error And because Mypy is confused by this 3 : 1 2 def my_func ( arg : ( int , Integral )): # Mypy \"syntax\" error pass Info As @leycec correctly points out , PEP 604 promises a syntax that would help avoid needing one thing for isinstance checks and an entirely separate thing for annotations. While some of its machinery is available to Python versions prior to 3.10 via from __future__ import annotations , sadly, type aliases and isinstance checks are not (a known limitation ). numerary leans heavily on both. So we need one of: A fully functional back-port of PEP 604; Version irrelevance through Python 3.9; or A meaningful and comprehensive fix to python/mypy#3186 that such that we can gleefully delete numerary (or at least declare it obsolete) and move on with our lives. Place your bets on which happens first. Does the Union provide any benefit? Yes. Because beartype . beartype is awesome . Its author is even awesomer . 4 More generally, runtime checkers that inspect and enforce annotations face problems similar to isinstance . Defining a Union provides an annotation analog for short-circuiting. Limitations There are some downsides, though. (Aren\u2019t there always?) Short-circuiting is too trusting Short-circuiting trusts numeric tower registrations. But sometimes, out there in the real world, implementations lie . Consider: 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsRealImag , SupportsRealImagSCT >>> hasattr ( Integral , \"real\" ) and hasattr ( Integral , \"imag\" ) True >>> one = sympify ( \"1\" ) >>> isinstance ( one , Integral ) True >>> hasattr ( one , \"real\" ) or hasattr ( one , \"imag\" ) # somebody's tellin' stories False >>> isinstance ( one , SupportsRealImag ) # detects the lie False >>> isinstance ( one , SupportsRealImagSCT ) # trusts the registration True Protocols lose fidelity at runtime At runtime, protocols match names , not signatures . More specifically, SupportsNumeratorDenominatorProperties \u2019s numerator and denominator properties will match sage.rings.integer.Integer \u2019s similarly named functions . In other words, isinstance(sage_integer, SupportsNumeratorDenominatorProperties) will return True . Further, if the short-circuiting approach is used, because sage.rings.integer.Integer registers itself with the numeric tower, this may 5 not be caught by Mypy. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 >>> class SageLikeRational : ... def __init__ ( self , numerator : int , denominator : int = 1 ): ... self . _numerator = numerator ... self . _denominator = denominator ... def numerator ( self ) -> int : ... return self . _numerator ... def denominator ( self ) -> int : ... return self . _denominator >>> from numerary.types import SupportsNumeratorDenominatorProperties >>> frac : SupportsNumeratorDenominatorProperties = Fraction ( 29 , 3 ) # no typing error >>> sage_rational1 : SupportsNumeratorDenominatorProperties = SageLikeRational ( 29 , 3 ) # type: ignore # Mypy catches this >>> isinstance ( sage_rational1 , SupportsNumeratorDenominatorProperties ) # isinstance does not True >>> sage_rational1 . numerator <... method ... numerator ...> >>> frac . numerator 29 To combat this particular situation, numerary provides the SupportsNumeratorDenominatorMethods protocol and the numerator and denominator helper functions. 1 2 3 4 5 6 7 8 9 10 >>> from numerary.types import numerator >>> numerator ( sage_rational1 ) 29 >>> numerator ( frac ) 29 >>> from numerary.types import SupportsNumeratorDenominatorMethods , numerator >>> sage_rational2 : SupportsNumeratorDenominatorMethods = SageLikeRational ( 3 , 29 ) # no type error >>> numerator ( sage_rational2 ) 3 numerary also defines: 1 2 3 4 5 6 7 8 SupportsNumeratorDenominatorMixedU = Union [ SupportsNumeratorDenominatorProperties , SupportsNumeratorDenominatorMethods , ] SupportsNumeratorDenominatorMixedT = ( SupportsNumeratorDenominatorProperties , SupportsNumeratorDenominatorMethods , ) 1 2 3 4 5 6 7 8 >>> from numerary.types import SupportsNumeratorDenominatorMixedU , numerator >>> chimera_rational : SupportsNumeratorDenominatorMixedU >>> chimera_rational = Fraction ( 29 , 3 ) # no type error >>> numerator ( chimera_rational ) 29 >>> chimera_rational = SageLikeRational ( 3 , 29 ) # still no type error >>> numerator ( chimera_rational ) 3 The SupportsNumeratorDenominator* primitives provide the basis for the analogous numerary.types.RationalLike* primitives , which should provide sufficient (if idiosyncratic) coverage for dealing with (seemingly mis-appropriately named) rationals. Shut up and take my money! If all you deal with are integrals and reals, and what you want is arithmetic operator compatibility, but don\u2019t do a ton of runtime checking, this should probably get you most of where you likely want to go: 1 2 3 4 >>> from numerary import IntegralLike , RealLike >>> def deeper_thot ( arg : RealLike ) -> IntegralLike : ... assert arg != 0 and arg ** 0 == 1 ... return arg // arg + 42 If your performance requirements demand them, consider the short-circuiting versions. 1 2 3 4 5 >>> from numerary import ( ... IntegralLikeSCT , IntegralLikeSCU , ... RealLikeSCT , RealLikeSCU , ... ) >>> # ... More examples coming soon. I promise ! No, really. Not a PEP promise. A real one. \u270c\ufe0f\ud83d\ude0a License numerary is licensed under the MIT License . See the included LICENSE file for details. Source code is available on GitHub . Installation Installation can be performed via PyPI . 1 2 % pip install numerary ... Alternately, you can download the source and install manually. 1 2 3 4 5 % git clone https://github.com/posita/numerary.git ... % cd numerary % python -m pip install . # -or- python -c 'from setuptools import setup ; setup()' install . ... Requirements numerary requires a relatively modern version of Python: CPython (3.7+) PyPy (CPython 3.7+ compatible) It has the following runtime dependencies: typing-extensions (with Python <3.9) numerary will opportunistically use the following, if available at runtime: beartype for yummy runtime type-checking goodness (0.8+) If you use beartype for type checking your code that interacts with numerary , but don\u2019t want numerary to use it internally (e.g., for some strange reason), set the NUMERARY_BEARTYPE environment variable to a falsy 6 value before numerary is loaded. See the hacking quick-start for additional development and testing dependencies. You know, super weird, off-the-wall shit, like members of the numeric tower , or standard library primitives that remain non -members for some \ud83e\udd2ced up reason , or legitimate non-members because they predate PEP 3141 and conforming would amount to breaking changes , or\u2014I don\u2019t know\u2014oodles of libraries and applications that have been around for literally decades that bring huge value to vast scientific and mathematic audiences, but whose number primitives break type checking if one abides by the ubiquitous bum steer, \u201cI don\u2019t have any experience trying to do what you\u2019re doing, but just use float , bro.\u201d Because, hey, \ud83e\udd2c numbers! Am I right? \u21a9 That should be easy I just gave you the link . Twice . \u21a9 Even though the syntax is legal and beartype gladly does the right thing by treating the tuple literal as a Union . Not sure if this is a bug or a feature, but my vote is for feature. \u21a9 The subject of who is awesomer, beartype or the man who made it, is hotly contested . \u21a9 I say may because I don\u2019t really know how Sage\u2019s number registrations work. \u21a9 I.E., one of: 0 , off , f , false , and no . \u21a9","title":"Introduction"},{"location":"#numerary-now-with-protocol-powertm","text":"That\u2019s right! For a hopefully limited time, you too can benefit from someone else\u2019s deranged work-arounds for the enormous chasms in Python that lie between the esoteric fields of computation that are \u201ctyping\u201d and \u201cnumbers\u201d instead of having to develop your own out of sheer desperation from first principles ! numerary is a pure-Python codified rant for signaling that your interface is usable with non-native numeric primitives 1 without breaking type checking. If you\u2019re thinking that you shouldn\u2019t need a \ud83e\udd2cing library for that, you\u2019re right . numerary should enjoy no audience. It should not exist. Yet here we are. Its author gauges its success by how quickly it can be deleted as superfluous. (I\u2019m looking at you, maintainers.) numerary is licensed under the MIT License . See the accompanying LICENSE file for details. It should be considered experimental for now, but should settle down quickly. See the release notes for a summary of version-to-version changes. Source code is available on GitHub . If you find it lacking in any way, please don\u2019t hesitate to bring it to my attention .","title":"numerary - now with Protocol Power\u2122"},{"location":"#customers","text":"dyce - a pure-Python library for modeling arbitrarily complex dice mechanics and mother birthing code base of numerary ! The next one could be you ! \ud83d\udc4b Do you have a project that suffers problems made slightly less annoying by numerary ? Let me know , and I\u2019ll promote it here! And don\u2019t forget to do your part in perpetuating gratuitous badge-ification! 1 2 3 4 <!-- Markdown --> As of version 0.4.1, ``dyce`` is [ ![numerary-encumbered ]( https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg )][numerary-encumbered]! [ numerary-encumbered ]: https://posita.github.io/numerary/ \"numerary-encumbered!\" 1 2 3 4 5 6 7 8 9 .. reStructuredText - see https://docutils.sourceforge.io/docs/ref/rst/directives.html#image As of version 0.4.1, ``dyce`` is |numerary-encumbered|! .. |numerary-encumbered| image :: https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg :align: top :target: https://posita.github.io/numerary/ :alt: numerary-encumbered 1 2 3 4 5 <!-- HTML --> As of version 0.4.1, < code > dyce </ code > is < a href = \"https://posita.github.io/numerary/\" >< img src = \"https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg\" alt = \"numerary-encumbered\" style = \"vertical-align: middle;\" ></ a > !","title":"Customers"},{"location":"#the-calculation-function-an-allegory","text":"We have a simple vision. We want to define an API that works with reals (not just float s), performs a calculation, and returns integers (not just int s). 1 2 3 4 5 >>> from time import sleep >>> def deep_thought ( arg ): ... sleep ( 7_500_000 * 365.24219265 * 24 * 60 * 60 ) # doctest: +SKIP ... assert arg != 0 and arg ** 0 == 1 ... return 42 We want to tell the world how to call it and what to expect in return, so we annotate it: 1 2 3 >>> def deep_thought_typed ( arg : float ) -> int : ... assert arg != 0 and arg ** 0 == 1 ... return 42 So simple! We\u2019re done, right? Not quite. We find that the runtime works well, but we\u2019re getting type checking errors. 1 2 3 4 5 >>> deep_thought_typed ( 1.0 ) # this is fine ... 42 >>> from fractions import Fraction >>> deep_thought_typed ( Fraction ( 1 , 2 )) # type: ignore # ... but this fails 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_typed\" has incompatible type \"Fraction\"; expected \"float\" With a little research, we learn about the numeric tower [cue angelic singing] . Surely, it has the answer! Both float and Fraction are Real s. Let\u2019s test that to make sure. 1 2 3 4 5 6 7 >>> from numbers import Integral , Real >>> isinstance ( 42 , Integral ) True >>> isinstance ( 1.0 , Real ) True >>> isinstance ( Fraction ( 1 , 2 ), Real ) True Huzzah! What could be simpler? It appears a small tweak is all that is required! 1 2 3 >>> def deep_thought_towered ( arg : Real ) -> Integral : ... assert arg != 0 and arg ** 0 == 1 ... return 42 # type: ignore # now this fails Without the # type: ignore , we get: 1 \u2026: error: Incompatible return value type (got \"int\", expected \"Integral\") Hold the phone. isinstance(42, Integral) was True , was it not? This is starting to get confusing. 1 2 3 4 5 6 >>> from typing import Union >>> IntegralT = Union [ int , Integral ] >>> RealT = Union [ float , Real ] >>> def deep_thought_crumbling ( arg : RealT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 Well, that was odd , but such warts are a small price to pay. All is right in the world again! 1 2 3 4 5 6 7 >>> deep_thought_crumbling ( 1.0 ) 42 >>> deep_thought_crumbling ( Fraction ( 1 , 2 )) 42 >>> from decimal import Decimal >>> deep_thought_crumbling ( Decimal ( \"0.123\" )) # type: ignore # fails 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_crumbling\" has incompatible type \"Decimal\"; expected \"Union[float, Real]\" Oh, come on ! 1 2 3 4 5 6 >>> RealAndDecimalT = Union [ float , Real , Decimal ] >>> def deep_thought_toppled ( arg : RealAndDecimalT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 >>> deep_thought_toppled ( Decimal ( \"0.123\" )) 42 \ud83e\udd2c me. If we have to engage in these kinds of gymnastics just to reach escape velocity from the standard library, how the heck are we supposed to survive contact with numeric implementations we haven\u2019t even heard of yet?! We can\u2019t enumerate them all ! For many years, the numeric tower was declared a \u201cdead end\u201d by maintainers. Unsurprisingly, many longstanding library authors didn\u2019t see much benefit to conforming to its API. Adoption has grown, but we can\u2019t rely on it. What should we rely on, then? Surely the exalted few who have steered us away from one thing are prepared to steer us toward something else, no? Sadly, the apparent attitude of many seems to be, \u201cSomething, something, protocols? Meh. I don\u2019t know. We\u2019ll figure it out later.\u201d Can we fix this with protocols? The standard library provides some simple precedents . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore >>> from typing import Iterable , Union >>> @runtime_checkable ... class SupportsNumeratorDenominator ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @property ... def numerator ( self ) -> int : pass ... @property ... def denominator ( self ) -> int : pass >>> def require_rational ( arg : SupportsNumeratorDenominator ) -> None : ... assert isinstance ( arg , SupportsNumeratorDenominator ) >>> require_rational ( 1 ) >>> require_rational ( Fraction ( 1 , 2 )) >>> require_rational ( 1.0 ) # type: ignore Traceback ( most recent call last ): ... AssertionError Without the # type: ignore , we get: 1 2 3 \u2026: error: Argument 1 to \"require_rational\" has incompatible type \"float\"; expected \"SupportsNumeratorDenominator\" \u2026: note: \"float\" is missing following \"SupportsNumeratorDenominator\" protocol members: \u2026: note: denominator, numerator Oh. My. Godetia. Could this be it? Have we stumbled into the promised land? Let\u2019s see how they perform. First, let\u2019s get a baseline. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 In [ 11 ]: from fractions import Fraction ; from numbers import Rational In [ 12 ]: val = 1 In [ 13 ]: % timeit - r10 isinstance ( val , Rational ) 326 ns \u00b1 1.26 ns per loop ( mean \u00b1 std . dev . of 10 runs , 1000000 loops each ) In [ 14 ]: val = Fraction ( 1 , 2 ) In [ 15 ]: % timeit - r10 isinstance ( val , Rational ) 329 ns \u00b1 1.87 ns per loop ( mean \u00b1 std . dev . of 10 runs , 1000000 loops each ) In [ 16 ]: val = 1.0 In [ 17 ]: % timeit - r10 isinstance ( val , Rational ) 351 ns \u00b1 1.29 ns per loop ( mean \u00b1 std . dev . of 10 runs , 1000000 loops each ) Now let\u2019s compare that with our two-property protocol. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 In [ 20 ]: from numerary import SupportsNumeratorDenominator In [ 21 ]: val = 1 In [ 22 ]: % timeit - r10 isinstance ( val , SupportsNumeratorDenominator ) 12.2 \u00b5s \u00b1 203 ns per loop ( mean \u00b1 std . dev . of 10 runs , 100000 loops each ) In [ 23 ]: val = Fraction ( 1 , 2 ) In [ 24 ]: % timeit - r10 isinstance ( val , SupportsNumeratorDenominator ) 12.3 \u00b5s \u00b1 62 ns per loop ( mean \u00b1 std . dev . of 10 runs , 100000 loops each ) In [ 25 ]: val = 1.0 In [ 26 ]: % timeit - r10 isinstance ( val , SupportsNumeratorDenominator ) 12.4 \u00b5s \u00b1 97.8 ns per loop ( mean \u00b1 std . dev . of 10 runs , 100000 loops each ) That\u2019s forty times slower. \ud83d\ude36 And that\u2019s just with a two-property protocol. How much worse would it be if we had enumerated all the dunder methods? \ud83d\ude30 You know what? Never mind that. Where there\u2019s a will, there\u2019s a way. Note to self, \u201cSolve the performance problems with protocols later, but we\u2019re definitely onto something!\u201d Let\u2019s do another one. Real numbers have comparisons that complex ones don\u2019t. That seems as good a place as any to tackle next. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore >>> from abc import abstractmethod >>> from typing import Any , Iterable , Union >>> @runtime_checkable ... class SupportsRealComparisons ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @abstractmethod ... def __lt__ ( self , other : Any ) -> bool : pass ... @abstractmethod ... def __le__ ( self , other : Any ) -> bool : pass ... @abstractmethod ... def __ge__ ( self , other : Any ) -> bool : pass ... @abstractmethod ... def __gt__ ( self , other : Any ) -> bool : pass >>> def require_real ( arg : SupportsRealComparisons ) -> None : ... assert isinstance ( arg , SupportsRealComparisons ) >>> require_real ( 1 ) >>> require_real ( Fraction ( 1 , 2 )) >>> require_real ( 1.0 ) >>> require_real ( complex ( 0 )) # type: ignore # should go ka-boom! Where was the ka-boom? There was supposed to be an earth-shattering ka-boom! Type checking spotted the error. Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"require_real\" has incompatible type \"complex\"; expected \"SupportsRealComparisons\" So what gives? Why does our protocol think a complex has comparisons at runtime? It\u2019s a complex number and complex numbers don\u2019t have those. The standard library says so ! 1 2 3 4 5 6 7 >>> from numbers import Complex >>> isinstance ( complex ( 0 ), Complex ) True >>> hasattr ( Complex , \"__le__\" ) True >>> complex ( 0 ) . __le__ # type: ignore <... method ... complex ...> What the shit? Do they work? 1 2 3 4 >>> complex ( 0 ) <= complex ( 0 ) # type: ignore Traceback ( most recent call last ): ... TypeError : '<=' not supported between instances of 'complex' and 'complex' Wait. Complex numbers implement comparisons in complete contradiction to the documentation just to return NotImplemented ?! \ud83e\udd2c off ! How does Mypy know? Because the type definitions for complex and Complex are lies that conveniently omit mention of those methods. Quote \u201cWhen it becomes serious, you have to lie.\u201d \u2014Jean-Claude Juncker Do you see?! Do you see now why we can\u2019t have nice things?! I mean, I get casting as a rare case, but who builds sophisticated deception tooling into the very fabric a type definition mechanism to claim that non-compliant native primitives comply? How can you trust anything anymore?! Shouldn\u2019t that be a pretty strong hint that maybe you should step back and rethink your approach? Astute readers may note beartype could help restore Truth for us. 1 2 3 4 5 6 7 8 9 from beartype import beartype from beartype.vale import Is from typing import Annotated SupportsRealComparisonsNotComplexLies = Annotated [ SupportsRealComparisons , Is [ lambda arg : not isinstance ( arg , complex )] ] @beartype def require_real ( arg : SupportsRealComparisonsNotComplexLies ) -> None : assert isinstance ( arg , SupportsRealComparisonsNotComplexLies ) That\u2019s because Bear is hip to the scene. Bear is down . Bear knows what\u2019s what. If you have a typing problem, if no one else can help, and if you can find them 2 , maybe you can hire the Bear-Team. I digress. Okay. Can we still work with any of this shit and have type checking? Dunno. Let\u2019s try. Because somebody \ud83e\udd2cing has to.","title":"The calculation function, an allegory"},{"location":"#a-taste","text":"numerary strives to define composable, efficient protocols that one can use to construct numeric requirements. It expands on the Supports pattern used in the standard library. For example, numerary.types.SupportsIntegralOps is a @typing.runtime_checkable protocol that approximates the unary and binary operators introduced by numbers.Integral . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 >>> from numerary.types import SupportsIntegralOps >>> def shift_right_one ( arg : SupportsIntegralOps ) -> SupportsIntegralOps : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg >> 1 >>> shift_right_one ( 2 ) 1 >>> from sympy import sympify >>> two = sympify ( \"2\" ) ; type ( two ) < class ' sympy . core . numbers . Integer '> >>> res = shift_right_one ( two ) ; res 1 >>> type ( res ) < class ' sympy . core . numbers . One '> >>> shift_right_one ( Fraction ( 1 , 2 )) # type: ignore # properly caught by Mypy Traceback ( most recent call last ): ... AssertionError Note Until 1.9, sympy.core.numbers.Integer lacked the requisite bitwise operators . numerary catches that! The above properly results in both a type checking error as well as a runtime failure for SymPy versions prior to 1.9. By default, protocols frustrate runtime type checking performance . numerary applies two distinct, layered optimization strategies: Cached __instancecheck__ results for numerary -defined protocols; and Short-circuit type enumerations.","title":"A taste"},{"location":"#cached-__instancecheck__-results","text":"It caches, so it\u2019s faster. Bang. Done. (NSFW warning. Although, in retrospect, that warning probably should have been presented more prominently and earlier in this diatribe.) TODO(@posita): Describe how this works.","title":"Cached __instancecheck__ results"},{"location":"#short-circuit-type-enumerations","text":"If the interface is to be used most often with native types ( int s, float s, bool s) or those registered with the numeric tower, there is an optimization to be had at runtime by short-circuiting protocol type checking. These come in two flavors. \u2026SCU objects which are Union s for compliant types. \u2026SCT tuples, which are identical to the corresponding Union arguments. These are useful for runtime checks (e.g., as the second argument to isinstance ). For example, for the aforementioned SupportsIntegralOps , numerary defines two additional interfaces (some details and safeguards omitted). 1 2 SupportsIntegralOpsSCU = Union [ int , bool , Integral , SupportsIntegralOps ] SupportsIntegralOpsSCT = ( int , bool , Integral , SupportsIntegralOps ) 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> from numerary.types import SupportsIntegralOpsSCU # for type annotations >>> from numerary.types import SupportsIntegralOpsSCT # for runtime checking >>> def shift_left_one ( arg : SupportsIntegralOpsSCU ) -> SupportsIntegralOpsSCU : ... assert isinstance ( arg , SupportsIntegralOpsSCT ) ... return arg << 1 >>> shift_left_one ( 1 ) 2 >>> shift_left_one ( sympify ( \"1\" )) 2 >>> shift_left_one ( Fraction ( 1 , 2 )) # type: ignore Traceback ( most recent call last ): ... AssertionError Why two? Because you can\u2019t do this: 1 isinstance ( 1 , Union [ int , Integral ]) # syntax error And because Mypy is confused by this 3 : 1 2 def my_func ( arg : ( int , Integral )): # Mypy \"syntax\" error pass Info As @leycec correctly points out , PEP 604 promises a syntax that would help avoid needing one thing for isinstance checks and an entirely separate thing for annotations. While some of its machinery is available to Python versions prior to 3.10 via from __future__ import annotations , sadly, type aliases and isinstance checks are not (a known limitation ). numerary leans heavily on both. So we need one of: A fully functional back-port of PEP 604; Version irrelevance through Python 3.9; or A meaningful and comprehensive fix to python/mypy#3186 that such that we can gleefully delete numerary (or at least declare it obsolete) and move on with our lives. Place your bets on which happens first. Does the Union provide any benefit? Yes. Because beartype . beartype is awesome . Its author is even awesomer . 4 More generally, runtime checkers that inspect and enforce annotations face problems similar to isinstance . Defining a Union provides an annotation analog for short-circuiting.","title":"Short-circuit type enumerations"},{"location":"#limitations","text":"There are some downsides, though. (Aren\u2019t there always?)","title":"Limitations"},{"location":"#short-circuiting-is-too-trusting","text":"Short-circuiting trusts numeric tower registrations. But sometimes, out there in the real world, implementations lie . Consider: 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsRealImag , SupportsRealImagSCT >>> hasattr ( Integral , \"real\" ) and hasattr ( Integral , \"imag\" ) True >>> one = sympify ( \"1\" ) >>> isinstance ( one , Integral ) True >>> hasattr ( one , \"real\" ) or hasattr ( one , \"imag\" ) # somebody's tellin' stories False >>> isinstance ( one , SupportsRealImag ) # detects the lie False >>> isinstance ( one , SupportsRealImagSCT ) # trusts the registration True","title":"Short-circuiting is too trusting"},{"location":"#protocols-lose-fidelity-at-runtime","text":"At runtime, protocols match names , not signatures . More specifically, SupportsNumeratorDenominatorProperties \u2019s numerator and denominator properties will match sage.rings.integer.Integer \u2019s similarly named functions . In other words, isinstance(sage_integer, SupportsNumeratorDenominatorProperties) will return True . Further, if the short-circuiting approach is used, because sage.rings.integer.Integer registers itself with the numeric tower, this may 5 not be caught by Mypy. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 >>> class SageLikeRational : ... def __init__ ( self , numerator : int , denominator : int = 1 ): ... self . _numerator = numerator ... self . _denominator = denominator ... def numerator ( self ) -> int : ... return self . _numerator ... def denominator ( self ) -> int : ... return self . _denominator >>> from numerary.types import SupportsNumeratorDenominatorProperties >>> frac : SupportsNumeratorDenominatorProperties = Fraction ( 29 , 3 ) # no typing error >>> sage_rational1 : SupportsNumeratorDenominatorProperties = SageLikeRational ( 29 , 3 ) # type: ignore # Mypy catches this >>> isinstance ( sage_rational1 , SupportsNumeratorDenominatorProperties ) # isinstance does not True >>> sage_rational1 . numerator <... method ... numerator ...> >>> frac . numerator 29 To combat this particular situation, numerary provides the SupportsNumeratorDenominatorMethods protocol and the numerator and denominator helper functions. 1 2 3 4 5 6 7 8 9 10 >>> from numerary.types import numerator >>> numerator ( sage_rational1 ) 29 >>> numerator ( frac ) 29 >>> from numerary.types import SupportsNumeratorDenominatorMethods , numerator >>> sage_rational2 : SupportsNumeratorDenominatorMethods = SageLikeRational ( 3 , 29 ) # no type error >>> numerator ( sage_rational2 ) 3 numerary also defines: 1 2 3 4 5 6 7 8 SupportsNumeratorDenominatorMixedU = Union [ SupportsNumeratorDenominatorProperties , SupportsNumeratorDenominatorMethods , ] SupportsNumeratorDenominatorMixedT = ( SupportsNumeratorDenominatorProperties , SupportsNumeratorDenominatorMethods , ) 1 2 3 4 5 6 7 8 >>> from numerary.types import SupportsNumeratorDenominatorMixedU , numerator >>> chimera_rational : SupportsNumeratorDenominatorMixedU >>> chimera_rational = Fraction ( 29 , 3 ) # no type error >>> numerator ( chimera_rational ) 29 >>> chimera_rational = SageLikeRational ( 3 , 29 ) # still no type error >>> numerator ( chimera_rational ) 3 The SupportsNumeratorDenominator* primitives provide the basis for the analogous numerary.types.RationalLike* primitives , which should provide sufficient (if idiosyncratic) coverage for dealing with (seemingly mis-appropriately named) rationals.","title":"Protocols lose fidelity at runtime"},{"location":"#shut-up-and-take-my-money","text":"If all you deal with are integrals and reals, and what you want is arithmetic operator compatibility, but don\u2019t do a ton of runtime checking, this should probably get you most of where you likely want to go: 1 2 3 4 >>> from numerary import IntegralLike , RealLike >>> def deeper_thot ( arg : RealLike ) -> IntegralLike : ... assert arg != 0 and arg ** 0 == 1 ... return arg // arg + 42 If your performance requirements demand them, consider the short-circuiting versions. 1 2 3 4 5 >>> from numerary import ( ... IntegralLikeSCT , IntegralLikeSCU , ... RealLikeSCT , RealLikeSCU , ... ) >>> # ... More examples coming soon. I promise ! No, really. Not a PEP promise. A real one. \u270c\ufe0f\ud83d\ude0a","title":"Shut up and take my money!"},{"location":"#license","text":"numerary is licensed under the MIT License . See the included LICENSE file for details. Source code is available on GitHub .","title":"License"},{"location":"#installation","text":"Installation can be performed via PyPI . 1 2 % pip install numerary ... Alternately, you can download the source and install manually. 1 2 3 4 5 % git clone https://github.com/posita/numerary.git ... % cd numerary % python -m pip install . # -or- python -c 'from setuptools import setup ; setup()' install . ...","title":"Installation"},{"location":"#requirements","text":"numerary requires a relatively modern version of Python: CPython (3.7+) PyPy (CPython 3.7+ compatible) It has the following runtime dependencies: typing-extensions (with Python <3.9) numerary will opportunistically use the following, if available at runtime: beartype for yummy runtime type-checking goodness (0.8+) If you use beartype for type checking your code that interacts with numerary , but don\u2019t want numerary to use it internally (e.g., for some strange reason), set the NUMERARY_BEARTYPE environment variable to a falsy 6 value before numerary is loaded. See the hacking quick-start for additional development and testing dependencies. You know, super weird, off-the-wall shit, like members of the numeric tower , or standard library primitives that remain non -members for some \ud83e\udd2ced up reason , or legitimate non-members because they predate PEP 3141 and conforming would amount to breaking changes , or\u2014I don\u2019t know\u2014oodles of libraries and applications that have been around for literally decades that bring huge value to vast scientific and mathematic audiences, but whose number primitives break type checking if one abides by the ubiquitous bum steer, \u201cI don\u2019t have any experience trying to do what you\u2019re doing, but just use float , bro.\u201d Because, hey, \ud83e\udd2c numbers! Am I right? \u21a9 That should be easy I just gave you the link . Twice . \u21a9 Even though the syntax is legal and beartype gladly does the right thing by treating the tuple literal as a Union . Not sure if this is a bug or a feature, but my vote is for feature. \u21a9 The subject of who is awesomer, beartype or the man who made it, is hotly contested . \u21a9 I say may because I don\u2019t really know how Sage\u2019s number registrations work. \u21a9 I.E., one of: 0 , off , f , false , and no . \u21a9","title":"Requirements"},{"location":"contrib/","text":"Contributing to numerary There are many ways you can contribute. You have only but to try. Filing issues You can file new issues as you find them. Please try to avoid duplicating issues. \u201cWriting Effective Bug Reports\u201d by Elisabeth Hendrickson (PDF) may be helpful. Hacking quick-start An easy way to bootstrap an isolated development environment is: 1 2 3 4 5 6 7 8 9 10 % git clone --recurse-submodules https://github.com/posita/numerary.git \u2026 % cd numerary % /path/to/python -m venv .venv \u2026 % . .venv/bin/activate % pip install --upgrade --editable '.[dev]' \u2026 % python -m pre_commit install \u2026 Substitute your preferred virtual environment process for venv . The [dev] variant includes additional dependencies necessary for development and testing. See the [options.extras_require] section in setup.cfg . Unit tests are run with pytest via Tox . 1 2 3 4 % cd \u2026/path/to/numerary % . .venv/bin/activate % tox [ TOX_ARGS... [ -- PYTEST_ARGS... ]] \u2026 Submission guidelines If you are willing and able, consider submitting a pull request with a fix. See the docs if you\u2019re not already familiar with pull requests. numerary releases from master (although not always immediately), so a lot of these workflows are helpful. There are only a few additional guidelines: If it is not already present, please add your name (and optionally your email, GitHub username, website address, or other contact information) to the LICENSE file. 1 2 3 ... * [ Matt Bogosian ]( mailto:matt@bogosian.net?Subject=numerary ); GitHub \u2013 [ **@posita** ](https://github.com/posita) ... Use Black to format your changes. Do your best to follow the source conventions as you observe them. If it\u2019s important to you, Existing comments are wrapped at 88 characters per line to match Black\u2019s default. (Don\u2019t spend too much effort on strict conformance, though. I can clean things up later if they really bother me.) Provide tests where feasible and appropriate. At the very least, existing tests should not fail. (There are exceptions, but if there is any doubt, they probably do not apply.) Unit tests live in tests . If you want feedback on a work-in-progress, consider \u201cmentioning\u201d me ( @posita ), and describe specifically how I can help. Consider prefixing your pull request\u2019s title with something like, \u201c NEED FEEDBACK \u2013 \u201d. If your pull request is still in progress, but you are not blocked on anything, consider using the draft feature . Once you are ready for a merge, resolve any conflicts, squash your commits, and provide a useful commit message. ( This and this may be helpful.) If your pull request started out as a draft, promote it by requesting a review. Consider prefixing the pull request\u2019s title to something like, \u201c READY FOR MERGE \u2013 \u201d. I will try to get to it as soon as I can.","title":"Contributing"},{"location":"contrib/#contributing-to-numerary","text":"There are many ways you can contribute. You have only but to try.","title":"Contributing to numerary"},{"location":"contrib/#filing-issues","text":"You can file new issues as you find them. Please try to avoid duplicating issues. \u201cWriting Effective Bug Reports\u201d by Elisabeth Hendrickson (PDF) may be helpful.","title":"Filing issues"},{"location":"contrib/#hacking-quick-start","text":"An easy way to bootstrap an isolated development environment is: 1 2 3 4 5 6 7 8 9 10 % git clone --recurse-submodules https://github.com/posita/numerary.git \u2026 % cd numerary % /path/to/python -m venv .venv \u2026 % . .venv/bin/activate % pip install --upgrade --editable '.[dev]' \u2026 % python -m pre_commit install \u2026 Substitute your preferred virtual environment process for venv . The [dev] variant includes additional dependencies necessary for development and testing. See the [options.extras_require] section in setup.cfg . Unit tests are run with pytest via Tox . 1 2 3 4 % cd \u2026/path/to/numerary % . .venv/bin/activate % tox [ TOX_ARGS... [ -- PYTEST_ARGS... ]] \u2026","title":"Hacking quick-start"},{"location":"contrib/#submission-guidelines","text":"If you are willing and able, consider submitting a pull request with a fix. See the docs if you\u2019re not already familiar with pull requests. numerary releases from master (although not always immediately), so a lot of these workflows are helpful. There are only a few additional guidelines: If it is not already present, please add your name (and optionally your email, GitHub username, website address, or other contact information) to the LICENSE file. 1 2 3 ... * [ Matt Bogosian ]( mailto:matt@bogosian.net?Subject=numerary ); GitHub \u2013 [ **@posita** ](https://github.com/posita) ... Use Black to format your changes. Do your best to follow the source conventions as you observe them. If it\u2019s important to you, Existing comments are wrapped at 88 characters per line to match Black\u2019s default. (Don\u2019t spend too much effort on strict conformance, though. I can clean things up later if they really bother me.) Provide tests where feasible and appropriate. At the very least, existing tests should not fail. (There are exceptions, but if there is any doubt, they probably do not apply.) Unit tests live in tests . If you want feedback on a work-in-progress, consider \u201cmentioning\u201d me ( @posita ), and describe specifically how I can help. Consider prefixing your pull request\u2019s title with something like, \u201c NEED FEEDBACK \u2013 \u201d. If your pull request is still in progress, but you are not blocked on anything, consider using the draft feature . Once you are ready for a merge, resolve any conflicts, squash your commits, and provide a useful commit message. ( This and this may be helpful.) If your pull request started out as a draft, promote it by requesting a review. Consider prefixing the pull request\u2019s title to something like, \u201c READY FOR MERGE \u2013 \u201d. I will try to get to it as soon as I can.","title":"Submission guidelines"},{"location":"license/","text":"License and credits The MIT License (MIT) Copyright \u00a9 2015-2021 Matt Bogosian ( @posita ). Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Contributors The following individuals or entities have contributed to this software: Matt Bogosian ; GitHub \u2013 @posita By adding your name to this list, you grant a nonexclusive, perpetual license to your contributions to this software under the same terms as its license, above. Further, you warrant that your contributions to this software are exclusively your own creations and no one else has any superior right or claim to them. Finally, you agree to indemnify and hold harmless this software\u2019s owner against any colorable claim of infringement by a third party for this software\u2019s owner\u2019s otherwise lawful use of your contribution, whether or not such use was contemplated by you at the time you made it.","title":"License"},{"location":"license/#license-and-credits","text":"","title":"License and credits"},{"location":"license/#the-mit-license-mit","text":"Copyright \u00a9 2015-2021 Matt Bogosian ( @posita ). Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License (MIT)"},{"location":"license/#contributors","text":"The following individuals or entities have contributed to this software: Matt Bogosian ; GitHub \u2013 @posita By adding your name to this list, you grant a nonexclusive, perpetual license to your contributions to this software under the same terms as its license, above. Further, you warrant that your contributions to this software are exclusively your own creations and no one else has any superior right or claim to them. Finally, you agree to indemnify and hold harmless this software\u2019s owner against any colorable claim of infringement by a third party for this software\u2019s owner\u2019s otherwise lawful use of your contribution, whether or not such use was contemplated by you at the time you made it.","title":"Contributors"},{"location":"notes/","text":"numerary release notes 0.0.5 Updates license to the MIT License . Gets rid of self redundancy in __isinstance__ checks. 0.0.4 numerary finally leaves the dyce nest to become its own library! It didn\u2019t quite leave before because its maintainer is a bonehead who doesn\u2019t understand setuptools\u2019 multitude of oh-so-simple packaging mechanisms. No, it stuck around most weekends to do laundry while eating all of dyce \u2019s food. Now it has officially left the nest.","title":"Release notes"},{"location":"notes/#numerary-release-notes","text":"","title":"numerary release notes"},{"location":"notes/#005","text":"Updates license to the MIT License . Gets rid of self redundancy in __isinstance__ checks.","title":"0.0.5"},{"location":"notes/#004","text":"numerary finally leaves the dyce nest to become its own library! It didn\u2019t quite leave before because its maintainer is a bonehead who doesn\u2019t understand setuptools\u2019 multitude of oh-so-simple packaging mechanisms. No, it stuck around most weekends to do laundry while eating all of dyce \u2019s food. Now it has officially left the nest.","title":"0.0.4"},{"location":"numerary/","text":"numerary package reference Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. These are composition protocols that should suit common use cases. RealLike ( SupportsAbs , SupportsFloat , SupportsRealOps , SupportsComplexOps , SupportsComplexPow , Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __hash__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __hash__ ( self ) -> int : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True IntegralLike ( SupportsAbs , SupportsFloat , SupportsIndex , SupportsInt , SupportsIntegralOps , SupportsIntegralPow , SupportsRealOps , SupportsComplexOps , Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __hash__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __hash__ ( self ) -> int : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"<tt>numerary</tt>"},{"location":"numerary/#numerary-package-reference","text":"Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. These are composition protocols that should suit common use cases.","title":"numerary package reference"},{"location":"numerary/#numerary.types.RealLike","text":"TODO(posita): Document this!","title":"RealLike"},{"location":"numerary/#numerary.types.RealLike.__slots__","text":"","title":"__slots__"},{"location":"numerary/#numerary.types.RealLike.__hash__","text":"Source code in numerary/types.py @abstractmethod def __hash__ ( self ) -> int : pass","title":"__hash__()"},{"location":"numerary/#numerary.types.RealLike.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary/#numerary.types.RealLike.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary/#numerary.types.IntegralLike","text":"TODO(posita): Document this!","title":"IntegralLike"},{"location":"numerary/#numerary.types.IntegralLike.__slots__","text":"","title":"__slots__"},{"location":"numerary/#numerary.types.IntegralLike.__hash__","text":"Source code in numerary/types.py @abstractmethod def __hash__ ( self ) -> int : pass","title":"__hash__()"},{"location":"numerary/#numerary.types.IntegralLike.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary/#numerary.types.IntegralLike.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/","text":"numerary . types package reference Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. These are additional protocols that can be composed as desired. CachingProtocolMeta ( _ProtocolMeta ) Stand-in for Protocol \u2019s base class that caches results of __instancecheck__ , (which is otherwise really \ud83e\udd2cing expensive ). (When this was introduced, it resulted in about a 5\u00d7 performance increase for dyce \u2019s unit tests, which was the only benchmark I had at the time.) The downside is that this will yield unpredictable results for objects whose methods don\u2019t stem from any type (e.g., are assembled at runtime). I don\u2019t know of any real-world case where that would be true. We\u2019ll jump off that bridge when we come to it. __instancecheck__ ( cls , inst : Any ) -> bool special Source code in numerary/types.py def __instancecheck__ ( cls , inst : Any ) -> bool : inst_t = type ( inst ) if inst_t not in cls . _abc_inst_check_cache : cls . _abc_inst_check_cache [ inst_t ] = super () . __instancecheck__ ( inst ) return cls . _abc_inst_check_cache [ inst_t ] __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any ) -> _TT special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in numerary/types.py def __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any , ) -> _TT : # See <https://github.com/python/mypy/issues/9282> cls = super () . __new__ ( mcls , name , bases , namespace , ** kw ) # type: ignore # Prefixing this class member with \"_abc_\" is necessary to prevent it from being # considered part of the Protocol. (See # <https://github.com/python/cpython/blob/main/Lib/typing.py>.) cache : Dict [ Tuple [ type ], bool ] = {} cls . _abc_inst_check_cache = cache return cls RationalLikeMethods ( SupportsAbs , SupportsFloat , SupportsNumeratorDenominatorMethods , SupportsRealOps , SupportsComplexOps , SupportsComplexPow , Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __hash__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __hash__ ( self ) -> int : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True RationalLikeProperties ( SupportsAbs , SupportsFloat , SupportsNumeratorDenominatorProperties , SupportsRealOps , SupportsComplexOps , SupportsComplexPow , Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __hash__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __hash__ ( self ) -> int : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsAbs ( SupportsAbs , Protocol ) An ABC with one abstract method abs that is covariant in its return type. __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsCeil ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __ceil__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __ceil__ ( self ) -> int : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsComplex ( SupportsComplex , Protocol ) An ABC with one abstract method complex . __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsComplexOps ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __add__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __add__ ( self , other : Any ) -> _T_co : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __mul__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __mul__ ( self , other : Any ) -> _T_co : pass __neg__ ( self ) -> _T_co special Source code in numerary/types.py @abstractmethod def __neg__ ( self ) -> _T_co : pass __pos__ ( self ) -> _T_co special Source code in numerary/types.py @abstractmethod def __pos__ ( self ) -> _T_co : pass __radd__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __radd__ ( self , other : Any ) -> _T_co : pass __rmul__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rmul__ ( self , other : Any ) -> _T_co : pass __rsub__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rsub__ ( self , other : Any ) -> _T_co : pass __rtruediv__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rtruediv__ ( self , other : Any ) -> _T_co : pass __sub__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __sub__ ( self , other : Any ) -> _T_co : pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True __truediv__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __truediv__ ( self , other : Any ) -> _T_co : pass SupportsComplexPow ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __pow__ ( self , exponent : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any ) -> _T_co : pass __rpow__ ( self , exponent : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any ) -> _T_co : pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsConjugate ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True conjugate ( self ) -> Any Source code in numerary/types.py @abstractmethod def conjugate ( self ) -> Any : pass SupportsDivmod ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ] special Source code in numerary/types.py @abstractmethod def __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ] special Source code in numerary/types.py @abstractmethod def __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsFloat ( SupportsFloat , Protocol ) An ABC with one abstract method float . __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsFloor ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __floor__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __floor__ ( self ) -> int : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsIndex ( SupportsIndex , Protocol ) An ABC with one abstract method index . __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsInt ( SupportsInt , Protocol ) An ABC with one abstract method int . __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsIntegralOps ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __and__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __and__ ( self , other : Any ) -> _T_co : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __invert__ ( self ) -> _T_co special Source code in numerary/types.py @abstractmethod def __invert__ ( self ) -> _T_co : pass __lshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __lshift__ ( self , other : Any ) -> _T_co : pass __or__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __or__ ( self , other : Any ) -> _T_co : pass __rand__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rand__ ( self , other : Any ) -> _T_co : pass __rlshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rlshift__ ( self , other : Any ) -> _T_co : pass __ror__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __ror__ ( self , other : Any ) -> _T_co : pass __rrshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rrshift__ ( self , other : Any ) -> _T_co : pass __rshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rshift__ ( self , other : Any ) -> _T_co : pass __rxor__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rxor__ ( self , other : Any ) -> _T_co : pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True __xor__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __xor__ ( self , other : Any ) -> _T_co : pass SupportsIntegralPow ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co special Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co : pass __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co : pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsNumeratorDenominatorMethods ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True denominator ( self ) -> SupportsInt Source code in numerary/types.py @abstractmethod def denominator ( self ) -> SupportsInt : pass numerator ( self ) -> SupportsInt Source code in numerary/types.py @abstractmethod def numerator ( self ) -> SupportsInt : pass SupportsNumeratorDenominatorProperties ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special denominator : int property readonly numerator : int property readonly __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsRealImag ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special imag : Any property readonly real : Any property readonly __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsRealOps ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __floordiv__ ( self , other : Any ) -> Any special Source code in numerary/types.py @abstractmethod def __floordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass __ge__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __ge__ ( self , other : Any ) -> bool : pass __gt__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __gt__ ( self , other : Any ) -> bool : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __le__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __le__ ( self , other : Any ) -> bool : pass __lt__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __lt__ ( self , other : Any ) -> bool : pass __mod__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __mod__ ( self , other : Any ) -> _T_co : pass __rfloordiv__ ( self , other : Any ) -> Any special Source code in numerary/types.py @abstractmethod def __rfloordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass __rmod__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rmod__ ( self , other : Any ) -> _T_co : pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsRound ( SupportsRound , Protocol ) An ABC with one abstract method round that is covariant in its return type. __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsTrunc ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True __trunc__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __trunc__ ( self ) -> int : pass ceil ( operand : SupportsCeil ) TODO(posita): Document this! Source code in numerary/types.py @beartype def ceil ( operand : SupportsCeil ): r \"\"\" TODO(posita): Document this! \"\"\" assert isinstance ( operand , SupportsFloat ) return math . ceil ( operand ) denominator ( operand : SupportsNumeratorDenominatorMixedU ) TODO(posita): Document this! Source code in numerary/types.py @beartype def denominator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" TODO(posita): Document this! \"\"\" if hasattr ( operand , \"denominator\" ): if callable ( operand . denominator ): return operand . denominator () else : return operand . denominator else : raise TypeError ( f \" { operand !r} has no denominator\" ) floor ( operand : SupportsFloor ) TODO(posita): Document this! Source code in numerary/types.py @beartype def floor ( operand : SupportsFloor ): r \"\"\" TODO(posita): Document this! \"\"\" assert isinstance ( operand , SupportsFloat ) return math . floor ( operand ) numerator ( operand : SupportsNumeratorDenominatorMixedU ) TODO(posita): Document this! Source code in numerary/types.py @beartype def numerator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" TODO(posita): Document this! \"\"\" if hasattr ( operand , \"numerator\" ): if callable ( operand . numerator ): return operand . numerator () else : return operand . numerator else : raise TypeError ( f \" { operand !r} has no numerator\" ) trunc ( operand : SupportsTrunc ) TODO(posita): Document this! Source code in numerary/types.py @beartype def trunc ( operand : SupportsTrunc ): r \"\"\" TODO(posita): Document this! \"\"\" assert isinstance ( operand , SupportsFloat ) return math . trunc ( operand )","title":"<tt>numerary.types</tt>"},{"location":"numerary.types/#numerarytypes-package-reference","text":"Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. These are additional protocols that can be composed as desired.","title":"numerary.types package reference"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta","text":"Stand-in for Protocol \u2019s base class that caches results of __instancecheck__ , (which is otherwise really \ud83e\udd2cing expensive ). (When this was introduced, it resulted in about a 5\u00d7 performance increase for dyce \u2019s unit tests, which was the only benchmark I had at the time.) The downside is that this will yield unpredictable results for objects whose methods don\u2019t stem from any type (e.g., are assembled at runtime). I don\u2019t know of any real-world case where that would be true. We\u2019ll jump off that bridge when we come to it.","title":"CachingProtocolMeta"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta.__instancecheck__","text":"Source code in numerary/types.py def __instancecheck__ ( cls , inst : Any ) -> bool : inst_t = type ( inst ) if inst_t not in cls . _abc_inst_check_cache : cls . _abc_inst_check_cache [ inst_t ] = super () . __instancecheck__ ( inst ) return cls . _abc_inst_check_cache [ inst_t ]","title":"__instancecheck__()"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in numerary/types.py def __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any , ) -> _TT : # See <https://github.com/python/mypy/issues/9282> cls = super () . __new__ ( mcls , name , bases , namespace , ** kw ) # type: ignore # Prefixing this class member with \"_abc_\" is necessary to prevent it from being # considered part of the Protocol. (See # <https://github.com/python/cpython/blob/main/Lib/typing.py>.) cache : Dict [ Tuple [ type ], bool ] = {} cls . _abc_inst_check_cache = cache return cls","title":"__new__()"},{"location":"numerary.types/#numerary.types.RationalLikeMethods","text":"TODO(posita): Document this!","title":"RationalLikeMethods"},{"location":"numerary.types/#numerary.types.RationalLikeMethods.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.RationalLikeMethods.__hash__","text":"Source code in numerary/types.py @abstractmethod def __hash__ ( self ) -> int : pass","title":"__hash__()"},{"location":"numerary.types/#numerary.types.RationalLikeMethods.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.RationalLikeMethods.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.RationalLikeProperties","text":"TODO(posita): Document this!","title":"RationalLikeProperties"},{"location":"numerary.types/#numerary.types.RationalLikeProperties.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.RationalLikeProperties.__hash__","text":"Source code in numerary/types.py @abstractmethod def __hash__ ( self ) -> int : pass","title":"__hash__()"},{"location":"numerary.types/#numerary.types.RationalLikeProperties.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.RationalLikeProperties.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsAbs","text":"An ABC with one abstract method abs that is covariant in its return type.","title":"SupportsAbs"},{"location":"numerary.types/#numerary.types.SupportsAbs.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsAbs.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsAbs.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsCeil","text":"TODO(posita): Document this!","title":"SupportsCeil"},{"location":"numerary.types/#numerary.types.SupportsCeil.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsCeil.__ceil__","text":"Source code in numerary/types.py @abstractmethod def __ceil__ ( self ) -> int : pass","title":"__ceil__()"},{"location":"numerary.types/#numerary.types.SupportsCeil.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsCeil.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsComplex","text":"An ABC with one abstract method complex .","title":"SupportsComplex"},{"location":"numerary.types/#numerary.types.SupportsComplex.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsComplex.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsComplex.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps","text":"TODO(posita): Document this!","title":"SupportsComplexOps"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__add__","text":"Source code in numerary/types.py @abstractmethod def __add__ ( self , other : Any ) -> _T_co : pass","title":"__add__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__mul__","text":"Source code in numerary/types.py @abstractmethod def __mul__ ( self , other : Any ) -> _T_co : pass","title":"__mul__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__neg__","text":"Source code in numerary/types.py @abstractmethod def __neg__ ( self ) -> _T_co : pass","title":"__neg__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__pos__","text":"Source code in numerary/types.py @abstractmethod def __pos__ ( self ) -> _T_co : pass","title":"__pos__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__radd__","text":"Source code in numerary/types.py @abstractmethod def __radd__ ( self , other : Any ) -> _T_co : pass","title":"__radd__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__rmul__","text":"Source code in numerary/types.py @abstractmethod def __rmul__ ( self , other : Any ) -> _T_co : pass","title":"__rmul__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__rsub__","text":"Source code in numerary/types.py @abstractmethod def __rsub__ ( self , other : Any ) -> _T_co : pass","title":"__rsub__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__rtruediv__","text":"Source code in numerary/types.py @abstractmethod def __rtruediv__ ( self , other : Any ) -> _T_co : pass","title":"__rtruediv__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__sub__","text":"Source code in numerary/types.py @abstractmethod def __sub__ ( self , other : Any ) -> _T_co : pass","title":"__sub__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__truediv__","text":"Source code in numerary/types.py @abstractmethod def __truediv__ ( self , other : Any ) -> _T_co : pass","title":"__truediv__()"},{"location":"numerary.types/#numerary.types.SupportsComplexPow","text":"TODO(posita): Document this!","title":"SupportsComplexPow"},{"location":"numerary.types/#numerary.types.SupportsComplexPow.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsComplexPow.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsComplexPow.__pow__","text":"Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any ) -> _T_co : pass","title":"__pow__()"},{"location":"numerary.types/#numerary.types.SupportsComplexPow.__rpow__","text":"Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any ) -> _T_co : pass","title":"__rpow__()"},{"location":"numerary.types/#numerary.types.SupportsComplexPow.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsConjugate","text":"TODO(posita): Document this!","title":"SupportsConjugate"},{"location":"numerary.types/#numerary.types.SupportsConjugate.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsConjugate.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsConjugate.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsConjugate.conjugate","text":"Source code in numerary/types.py @abstractmethod def conjugate ( self ) -> Any : pass","title":"conjugate()"},{"location":"numerary.types/#numerary.types.SupportsDivmod","text":"TODO(posita): Document this!","title":"SupportsDivmod"},{"location":"numerary.types/#numerary.types.SupportsDivmod.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsDivmod.__divmod__","text":"Source code in numerary/types.py @abstractmethod def __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass","title":"__divmod__()"},{"location":"numerary.types/#numerary.types.SupportsDivmod.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsDivmod.__rdivmod__","text":"Source code in numerary/types.py @abstractmethod def __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass","title":"__rdivmod__()"},{"location":"numerary.types/#numerary.types.SupportsDivmod.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsFloat","text":"An ABC with one abstract method float .","title":"SupportsFloat"},{"location":"numerary.types/#numerary.types.SupportsFloat.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsFloat.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsFloat.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsFloor","text":"TODO(posita): Document this!","title":"SupportsFloor"},{"location":"numerary.types/#numerary.types.SupportsFloor.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsFloor.__floor__","text":"Source code in numerary/types.py @abstractmethod def __floor__ ( self ) -> int : pass","title":"__floor__()"},{"location":"numerary.types/#numerary.types.SupportsFloor.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsFloor.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsIndex","text":"An ABC with one abstract method index .","title":"SupportsIndex"},{"location":"numerary.types/#numerary.types.SupportsIndex.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsIndex.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsIndex.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsInt","text":"An ABC with one abstract method int .","title":"SupportsInt"},{"location":"numerary.types/#numerary.types.SupportsInt.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsInt.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsInt.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps","text":"TODO(posita): Document this!","title":"SupportsIntegralOps"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__and__","text":"Source code in numerary/types.py @abstractmethod def __and__ ( self , other : Any ) -> _T_co : pass","title":"__and__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__invert__","text":"Source code in numerary/types.py @abstractmethod def __invert__ ( self ) -> _T_co : pass","title":"__invert__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__lshift__","text":"Source code in numerary/types.py @abstractmethod def __lshift__ ( self , other : Any ) -> _T_co : pass","title":"__lshift__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__or__","text":"Source code in numerary/types.py @abstractmethod def __or__ ( self , other : Any ) -> _T_co : pass","title":"__or__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__rand__","text":"Source code in numerary/types.py @abstractmethod def __rand__ ( self , other : Any ) -> _T_co : pass","title":"__rand__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__rlshift__","text":"Source code in numerary/types.py @abstractmethod def __rlshift__ ( self , other : Any ) -> _T_co : pass","title":"__rlshift__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__ror__","text":"Source code in numerary/types.py @abstractmethod def __ror__ ( self , other : Any ) -> _T_co : pass","title":"__ror__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__rrshift__","text":"Source code in numerary/types.py @abstractmethod def __rrshift__ ( self , other : Any ) -> _T_co : pass","title":"__rrshift__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__rshift__","text":"Source code in numerary/types.py @abstractmethod def __rshift__ ( self , other : Any ) -> _T_co : pass","title":"__rshift__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__rxor__","text":"Source code in numerary/types.py @abstractmethod def __rxor__ ( self , other : Any ) -> _T_co : pass","title":"__rxor__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__xor__","text":"Source code in numerary/types.py @abstractmethod def __xor__ ( self , other : Any ) -> _T_co : pass","title":"__xor__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow","text":"TODO(posita): Document this!","title":"SupportsIntegralPow"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow.__pow__","text":"Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co : pass","title":"__pow__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow.__rpow__","text":"Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co : pass","title":"__rpow__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMethods","text":"TODO(posita): Document this!","title":"SupportsNumeratorDenominatorMethods"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMethods.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMethods.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMethods.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMethods.denominator","text":"Source code in numerary/types.py @abstractmethod def denominator ( self ) -> SupportsInt : pass","title":"denominator()"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMethods.numerator","text":"Source code in numerary/types.py @abstractmethod def numerator ( self ) -> SupportsInt : pass","title":"numerator()"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorProperties","text":"TODO(posita): Document this!","title":"SupportsNumeratorDenominatorProperties"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorProperties.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorProperties.denominator","text":"","title":"denominator"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorProperties.numerator","text":"","title":"numerator"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorProperties.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorProperties.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsRealImag","text":"TODO(posita): Document this!","title":"SupportsRealImag"},{"location":"numerary.types/#numerary.types.SupportsRealImag.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsRealImag.imag","text":"","title":"imag"},{"location":"numerary.types/#numerary.types.SupportsRealImag.real","text":"","title":"real"},{"location":"numerary.types/#numerary.types.SupportsRealImag.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsRealImag.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps","text":"TODO(posita): Document this!","title":"SupportsRealOps"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__floordiv__","text":"Source code in numerary/types.py @abstractmethod def __floordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass","title":"__floordiv__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__ge__","text":"Source code in numerary/types.py @abstractmethod def __ge__ ( self , other : Any ) -> bool : pass","title":"__ge__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__gt__","text":"Source code in numerary/types.py @abstractmethod def __gt__ ( self , other : Any ) -> bool : pass","title":"__gt__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__le__","text":"Source code in numerary/types.py @abstractmethod def __le__ ( self , other : Any ) -> bool : pass","title":"__le__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__lt__","text":"Source code in numerary/types.py @abstractmethod def __lt__ ( self , other : Any ) -> bool : pass","title":"__lt__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__mod__","text":"Source code in numerary/types.py @abstractmethod def __mod__ ( self , other : Any ) -> _T_co : pass","title":"__mod__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__rfloordiv__","text":"Source code in numerary/types.py @abstractmethod def __rfloordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass","title":"__rfloordiv__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__rmod__","text":"Source code in numerary/types.py @abstractmethod def __rmod__ ( self , other : Any ) -> _T_co : pass","title":"__rmod__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsRound","text":"An ABC with one abstract method round that is covariant in its return type.","title":"SupportsRound"},{"location":"numerary.types/#numerary.types.SupportsRound.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsRound.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsRound.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsTrunc","text":"TODO(posita): Document this!","title":"SupportsTrunc"},{"location":"numerary.types/#numerary.types.SupportsTrunc.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsTrunc.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsTrunc.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsTrunc.__trunc__","text":"Source code in numerary/types.py @abstractmethod def __trunc__ ( self ) -> int : pass","title":"__trunc__()"},{"location":"numerary.types/#numerary.types.ceil","text":"TODO(posita): Document this! Source code in numerary/types.py @beartype def ceil ( operand : SupportsCeil ): r \"\"\" TODO(posita): Document this! \"\"\" assert isinstance ( operand , SupportsFloat ) return math . ceil ( operand )","title":"ceil()"},{"location":"numerary.types/#numerary.types.denominator","text":"TODO(posita): Document this! Source code in numerary/types.py @beartype def denominator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" TODO(posita): Document this! \"\"\" if hasattr ( operand , \"denominator\" ): if callable ( operand . denominator ): return operand . denominator () else : return operand . denominator else : raise TypeError ( f \" { operand !r} has no denominator\" )","title":"denominator()"},{"location":"numerary.types/#numerary.types.floor","text":"TODO(posita): Document this! Source code in numerary/types.py @beartype def floor ( operand : SupportsFloor ): r \"\"\" TODO(posita): Document this! \"\"\" assert isinstance ( operand , SupportsFloat ) return math . floor ( operand )","title":"floor()"},{"location":"numerary.types/#numerary.types.numerator","text":"TODO(posita): Document this! Source code in numerary/types.py @beartype def numerator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" TODO(posita): Document this! \"\"\" if hasattr ( operand , \"numerator\" ): if callable ( operand . numerator ): return operand . numerator () else : return operand . numerator else : raise TypeError ( f \" { operand !r} has no numerator\" )","title":"numerator()"},{"location":"numerary.types/#numerary.types.trunc","text":"TODO(posita): Document this! Source code in numerary/types.py @beartype def trunc ( operand : SupportsTrunc ): r \"\"\" TODO(posita): Document this! \"\"\" assert isinstance ( operand , SupportsFloat ) return math . trunc ( operand )","title":"trunc()"}]}