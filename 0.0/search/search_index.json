{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Copyright and other protections apply. Please see the accompanying LICENSE file for rights and restrictions governing use of this software. All rights not expressly waived or licensed are reserved. If that file is missing or appears to be modified from its original, then please contact the author before viewing or using this software in any capacity. Are you defining a numeric interface that should work with more than just int s and float s? Are you annotating that interface for documentation and type checking? Were you excited by PEP 3141 \u2019s glitz and gloss promising a clean, straightforward number type definition mechanism, only to learn the hard way\u2014after many hours of searching, tweaking, hacking, and testing ever more convoluted code, again and again\u2014that you could\u2019t actually make it work with Python\u2019s type checking system? Do you now wonder whether numbers were something new to computing in general because nothing else would explain such a gaping hole in a programming language so popular with the STEM crowd that has been around since the early 1990s? Does the number 3186 haunt you in your dreams? Do you find yourself shouting to no one in particular, \u201cThere has to be a better way?\u201d Well I\u2019m here to tell you there ain\u2019t. But until there is, there\u2019s \u2026 numerary - Now with Protocol Power\u2122 That\u2019s right! For a hopefully limited time, you too can benefit from someone else\u2019s deranged work-arounds for the enormous chasms in Python that lie between the esoteric fields of computation that are \u201ctyping\u201d and \u201cnumbers\u201d instead of having to develop your own out of sheer desperation from first principles ! numerary is a pure-Python codified rant for signaling that your interface is usable with non-native numeric primitives 1 without breaking type checking. If you\u2019re thinking that you shouldn\u2019t need a \ud83e\udd2cing library for that, you\u2019re right . numerary should enjoy no audience. It should not exist. Yet here we are. Its author gauges its success by how quickly it can be deleted as superfluous. (I\u2019m looking at you, maintainers.) numerary is licensed under the GLWTS License (NSFW version only ) and comes with absolutely zero warranty for any purpose whatsoever. See the accompanying LICENSE file for details. It should be considered experimental for now, but should settle down quickly. See the release notes for a summary of version-to-version changes. Source code is available on GitHub . If you find it lacking in any way, please don\u2019t hesitate to bring it to my attention . Customers dyce - a pure-Python library for modeling arbitrarily complex dice mechanics and mother birthing code base \ud83d\ude44 of numerary ! The next one could be you ! \ud83d\udc4b Do you have a project that suffers problems made slightly less annoying by numerary ? Let me know , and I\u2019ll promote it here! And don\u2019t forget to do your part in perpetuating gratuitous badge-ification! 1 2 3 4 <!-- Markdown --> As of version 0.4.1, ``dyce`` is [ ![numerary-encumbered ]( https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg )][numerary-encumbered]! [ numerary-encumbered ]: https://posita.github.io/numerary/ \"numerary-encumbered!\" 1 2 3 4 5 6 7 8 9 .. reStructuredText - see https://docutils.sourceforge.io/docs/ref/rst/directives.html#image As of version 0.4.1, ``dyce`` is |numerary-encumbered|! .. |numerary-encumbered| image :: https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg :align: top :target: https://posita.github.io/numerary/ :alt: numerary-encumbered 1 2 3 4 5 <!-- HTML --> As of version 0.4.1, < code > dyce </ code > is < a href = \"https://posita.github.io/numerary/\" >< img src = \"https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg\" alt = \"numerary-encumbered\" style = \"vertical-align: middle;\" ></ a > ! The calculation function, an allegory We have a simple vision. We want to define an API that works with reals (not just float s), performs a calculation, and returns integers (not just int s). 1 2 3 4 5 >>> from time import sleep >>> def deep_thought ( arg ): ... sleep ( 7_500_000 * 365.24219265 * 24 * 60 * 60 ) # doctest: +SKIP ... assert arg != 0 and arg ** 0 == 1 ... return 42 We want to tell the world how to call it and what to expect in return, so we annotate it: 1 2 3 >>> def deep_thought_typed ( arg : float ) -> int : ... assert arg != 0 and arg ** 0 == 1 ... return 42 So simple! We\u2019re done, right? Not quite. We find that the runtime works well, but we\u2019re getting type checking errors. 1 2 3 4 5 >>> deep_thought_typed ( 1.0 ) # this is fine ... 42 >>> from fractions import Fraction >>> deep_thought_typed ( Fraction ( 1 , 2 )) # type: ignore # ... but this fails 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_typed\" has incompatible type \"Fraction\"; expected \"float\" With a little research, we learn about the numeric tower [cue angelic singing] . Surely, it has the answer! Both float and Fraction are Real s. Let\u2019s test that to make sure. 1 2 3 4 5 6 7 >>> from numbers import Integral , Real >>> isinstance ( 42 , Integral ) True >>> isinstance ( 1.0 , Real ) True >>> isinstance ( Fraction ( 1 , 2 ), Real ) True Huzzah! What could be simpler! A small tweak is all that is required. 1 2 3 >>> def deep_thought_towered ( arg : Real ) -> Integral : ... assert arg != 0 and arg ** 0 == 1 ... return 42 # type: ignore # now this fails Without the # type: ignore , we get: 1 \u2026: error: Incompatible return value type (got \"int\", expected \"Integral\") Hold the phone. isinstance(42, Integral) was True , was it not? This is starting to get confusing. 1 2 3 4 5 6 >>> from typing import Union >>> IntegralT = Union [ int , Integral ] >>> RealT = Union [ float , Real ] >>> def deep_thought_crumbling ( arg : RealT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 Well, that was odd , but such warts are a small price to pay. All is right in the world again! 1 2 3 4 5 6 7 >>> deep_thought_crumbling ( 1.0 ) 42 >>> deep_thought_crumbling ( Fraction ( 1 , 2 )) 42 >>> from decimal import Decimal >>> deep_thought_crumbling ( Decimal ( \"0.123\" )) # type: ignore # fails 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_crumbling\" has incompatible type \"Decimal\"; expected \"Union[float, Real]\" Oh, come on ! 1 2 3 4 5 6 >>> RealAndDecimalT = Union [ float , Real , Decimal ] >>> def deep_thought_toppled ( arg : RealAndDecimalT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 >>> deep_thought_toppled ( Decimal ( \"0.123\" )) 42 \ud83e\udd2c me. If we have to engage in these kinds of gymnastics just to reach escape velocity from the standard library, how the heck are we supposed to survive contact with numeric implementations we haven\u2019t even heard of yet?! We can\u2019t enumerate them all ! For many years, the numeric tower was declared a \u201cdead end\u201d by maintainers. Unsurprisingly, many longstanding library authors didn\u2019t see much benefit to conforming to its API. Adoption has grown, but we can\u2019t rely on it. What should we rely on, then? Surely the exalted few who have steered us away from one thing are prepared to steer us toward something else, no? Sadly, the apparent attitude of many seems to be, \u201cSomething, something, protocols? Meh. I don\u2019t know. We\u2019ll figure it out later.\u201d Can we fix this with protocols? The standard library provides some simple precedents . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore >>> from typing import Iterable , Union >>> @runtime_checkable ... class SupportsNumeratorDenominator ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @property ... def numerator ( self ) -> int : ... ... @property ... def denominator ( self ) -> int : ... >>> def require_rational ( arg : SupportsNumeratorDenominator ) -> None : ... assert isinstance ( arg , SupportsNumeratorDenominator ) >>> require_rational ( 1 ) >>> require_rational ( Fraction ( 1 , 2 )) >>> require_rational ( 1.0 ) # type: ignore Traceback ( most recent call last ): ... AssertionError Without the # type: ignore , we get: 1 2 3 \u2026: error: Argument 1 to \"require_rational\" has incompatible type \"float\"; expected \"SupportsNumeratorDenominator\" \u2026: note: \"float\" is missing following \"SupportsNumeratorDenominator\" protocol members: \u2026: note: denominator, numerator Oh. My. Godetia. Could this be it? Have we stumbled into the promised land? Let\u2019s see how they perform. First, let\u2019s get a baseline. 1 2 3 4 5 6 7 8 9 10 11 12 In [ 13 ]: % timeit - r10 isinstance ( val , Rational ) 326 ns \u00b1 1.26 ns per loop ( mean \u00b1 std . dev . of 10 runs , 1000000 loops each ) In [ 14 ]: val = Fraction ( 1 , 2 ) In [ 15 ]: % timeit - r10 isinstance ( val , Rational ) 329 ns \u00b1 1.87 ns per loop ( mean \u00b1 std . dev . of 10 runs , 1000000 loops each ) In [ 16 ]: val = 1.0 In [ 17 ]: % timeit - r10 isinstance ( val , Rational ) 351 ns \u00b1 1.29 ns per loop ( mean \u00b1 std . dev . of 10 runs , 1000000 loops each ) Now let\u2019s compare that with our two-property protocol. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 In [ 21 ]: val = 1 In [ 22 ]: % timeit - r10 isinstance ( val , SupportsNumeratorDenominator ) 12.2 \u00b5s \u00b1 203 ns per loop ( mean \u00b1 std . dev . of 10 runs , 100000 loops each ) In [ 23 ]: val = Fraction ( 1 , 2 ) In [ 24 ]: % timeit - r10 isinstance ( val , SupportsNumeratorDenominator ) 12.3 \u00b5s \u00b1 62 ns per loop ( mean \u00b1 std . dev . of 10 runs , 100000 loops each ) In [ 25 ]: val = 1.0 In [ 26 ]: % timeit - r10 isinstance ( val , SupportsNumeratorDenominator ) 12.4 \u00b5s \u00b1 97.8 ns per loop ( mean \u00b1 std . dev . of 10 runs , 100000 loops each ) That\u2019s forty times slower. \ud83d\ude36 And that\u2019s just with a two-property protocol. How much worse would it be if we had enumerated all the dunder methods? \ud83d\ude30 You know what? Never mind that. Where there\u2019s a will, there\u2019s a way. Note to self, \u201cSolve the performance problems with protocols later, but we\u2019re definitely onto something!\u201d Let\u2019s do another one. Real numbers have comparisons that complex ones don\u2019t. That seems as good a place as any to tackle next. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore >>> from abc import abstractmethod >>> from typing import Any , Iterable , Union >>> @runtime_checkable ... class SupportsRealComparisons ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @abstractmethod ... def __lt__ ( self , other : Any ) -> bool : ... ... @abstractmethod ... def __le__ ( self , other : Any ) -> bool : ... ... @abstractmethod ... def __ge__ ( self , other : Any ) -> bool : ... ... @abstractmethod ... def __gt__ ( self , other : Any ) -> bool : ... >>> def require_real ( arg : SupportsRealComparisons ) -> None : ... assert isinstance ( arg , SupportsRealComparisons ) >>> require_real ( 1 ) >>> require_real ( Fraction ( 1 , 2 )) >>> require_real ( 1.0 ) >>> require_real ( complex ( 0 )) # type: ignore # should go ka-boom! Where was the ka-boom? There was supposed to be an earth-shattering ka-boom! Type checking spotted the error. Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"require_real\" has incompatible type \"complex\"; expected \"SupportsRealComparisons\" So what gives? Why does our protocol think a complex has comparisons at runtime? It\u2019s a complex number and complex numbers don\u2019t have those. The standard library says so ! 1 2 3 4 5 6 7 >>> from numbers import Complex >>> isinstance ( complex ( 0 ), Complex ) True >>> hasattr ( Complex , \"__le__\" ) True >>> complex ( 0 ) . __le__ # type: ignore <... method ... complex ...> What the shit? Do they work? 1 2 3 4 >>> complex ( 0 ) <= complex ( 0 ) # type: ignore Traceback ( most recent call last ): ... TypeError : '<=' not supported between instances of 'complex' and 'complex' Wait. Complex numbers implement comparisons in complete contradiction to the documentation just to return NotImplemented ?! \ud83e\udd2c off ! How does Mypy know? Because the type definitions for complex and Complex are lies that conveniently omit mention of those methods. Quote \u201cWhen it becomes serious, you have to lie.\u201d \u2014Jean-Claude Juncker Do you see?! Do you see now why we can\u2019t have nice things?! I mean, I get casting as a rare case, but who builds sophisticated deception tooling into the very fabric a type definition mechanism to claim that non-compliant native primitives comply? How can you trust anything anymore?! Shouldn\u2019t that be a pretty strong hint that maybe you should step back and rethink your approach? Astute readers may note beartype could help restore truth for us. 1 2 3 4 5 6 7 8 9 from beartype import beartype from beartype.vale import Is from typing import Annotated SupportsRealComparisonsNotComplexLies = Annotated [ SupportsRealComparisons , Is [ lambda arg : not isinstance ( arg , complex )] ] @beartype def require_real ( arg : SupportsRealComparisons ) -> None : assert isinstance ( arg , SupportsRealComparisons ) That\u2019s because Bear is hip to the scene. Bear is down . Bear knows what\u2019s what. If you have a typing problem, if no one else can help, and if you can find them (which should be easy; I just gave you the link ; twice), maybe you can hire the Bear-Team. I digress. Okay. Can we still work with any of this shit and have type checking? Dunno. Let\u2019s try. Because somebody \ud83e\udd2cing has to. A taste numerary strives to define composable, efficient protocols that one can use to construct numeric requirements. It expands on the Supports pattern used in the standard library. For example, numerary.types.SupportsIntegralOps is a @typing.runtime_checkable protocol that approximates the binary operators introduced by numbers.Integral . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 >>> from numerary.types import SupportsIntegralOps >>> def shift_right_one ( arg : SupportsIntegralOps ) -> SupportsIntegralOps : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg >> 1 >>> shift_right_one ( 2 ) 1 >>> from sympy import sympify >>> two = sympify ( \"2\" ) ; type ( two ) < class ' sympy . core . numbers . Integer '> >>> res = shift_right_one ( two ) ; res 1 >>> type ( res ) < class ' sympy . core . numbers . One '> >>> shift_right_one ( Fraction ( 1 , 2 )) # type: ignore # properly caught by Mypy Traceback ( most recent call last ): ... AssertionError Note that the above would still (properly) result in a type checking error as well as a runtime failure for SymPy versions prior to 1.9, because, until 1.9, sympy.core.numbers.Integer lacked the requisite bitwise operators . By default, protocols frustrate runtime type checking performance . numerary applies two layered optimization strategies: cached __instancecheck__ results for numerary -defined protocols and short-circuit type enumerations. Cached __instancecheck__ results It caches, so it\u2019s faster. Bang. Done. (NSFW warning. Although, in retrospect, that warning probably should have been presented more prominently and earlier in this diatribe.) TODO(@posita): Describe how this works. Short-circuit type enumerations If the interface is to be used most often with native types ( int s, float s, bool s) or those registered with the numeric tower, there is an optimization to be had at runtime by short-circuiting protocol type checking. These come in two flavors. \u2026T objects which are Union s for defining types. \u2026Ts tuples, which are identical to the corresponding Union arguments and useful for runtime isinstance checking. Following our SupportsIntegralOps example from above, numerary defines two additional interfaces (some details and safeguards omitted). 1 2 SupportsIntegralOpsT = Union [ int , bool , Integral , SupportsIntegralOps ] SupportsIntegralOpsTs = ( int , bool , Integral , SupportsIntegralOps ) 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> from numerary.types import SupportsIntegralOpsT # for type annotations >>> def shift_left_one ( arg : SupportsIntegralOpsT ) -> SupportsIntegralOpsT : ... from numerary.types import SupportsIntegralOpsTs # for runtime checking ... assert isinstance ( arg , SupportsIntegralOpsTs ) ... return arg << 1 >>> shift_left_one ( 1 ) 2 >>> shift_left_one ( sympify ( \"1\" )) 2 >>> shift_left_one ( \"1\" ) # type: ignore Traceback ( most recent call last ): ... AssertionError Why two? Because you can\u2019t do this: 1 isinstance ( 1 , Union [ int , Integral ]) # syntax error And because Mypy is confused by this 2 : 1 2 def my_func ( arg : ( int , Integral )): # Mypy \"syntax\" error pass So Python needs one thing for isinstance checks, and Mypy needs an entirely separate thing for annotations. Yay. \ud83d\ude12 Does the Union provide any benefit? Yes. Because beartype . beartype is awesome . Its author is even awesomer . More generally, runtime checkers that inspect and enforce annotations face problems similar to isinstance . Defining a Union provides an annotation-based short-circuit opportunity to those checkers. There\u2019s a downside, though. (Isn\u2019t there always?) Short-circuiting trusts implementations when they register themselves in the numeric tower. But sometimes, out there in the real world, they lie . Consider: 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsRealImag , SupportsRealImagTs >>> hasattr ( Integral , \"real\" ) and hasattr ( Integral , \"imag\" ) True >>> one = sympify ( \"1\" ) >>> isinstance ( one , Integral ) True >>> hasattr ( one , \"real\" ) or hasattr ( one , \"imag\" ) # somebody's tellin' stories False >>> isinstance ( one , SupportsRealImag ) # detects the lie False >>> isinstance ( one , SupportsRealImagTs ) # trusts the registration True Shut up and take my money! All that being said, if all you deal with are integrals and reals and what you want is arithmetic operator compatibility, this should probably get you most of where you likely want to go: 1 2 3 4 >>> from numerary import IntegralLike , RealLike >>> def deeper_thought ( arg : RealLike ) -> IntegralLike : ... assert arg != 0 and arg ** 0 == 1 ... return arg // arg + 42 \u2026 or, if you prefer the short-circuiting versions \u2026 1 >>> from numerary import IntegralLikeT , IntegralLikeTs , RealLikeT , RealLikeTs Much more coming soon. I promise ! No, really. Not a PEP promise. A real one. \u270c\ufe0f\ud83d\ude0a License numerary is licensed under the GLWTS License (NSFW version only ). See the included LICENSE file for details. Source code is available on GitHub . Installation Installation can be performed via PyPI . 1 2 % pip install numerary ... Alternately, you can download the source and install manually. 1 2 3 4 5 % git clone https://github.com/posita/numerary.git ... % cd numerary % python -m pip install . # -or- python -c 'from setuptools import setup ; setup()' install . ... Requirements numerary requires a relatively modern version of Python: CPython (3.7+) PyPy (CPython 3.7+ compatible) It has the following runtime dependencies: typing-extensions (with Python <3.9) numerary will opportunistically use the following, if available at runtime: beartype for yummy runtime type-checking goodness (0.8+) If you use beartype for type checking your code that interacts with numerary , but don\u2019t want numerary to use it internally (e.g., for performance reasons), set the NUMERARY_BEARTYPE environment variable to a falsy 3 value before numerary is loaded. See the hacking quick-start for additional development and testing dependencies. You know, super weird, off-the-wall shit, like members of the numeric tower , or standard library primitives that remain non -members for some \ud83e\udd2ced up reason , or legitimate non-members because they predate PEP 3141 and conforming would amount to breaking changes , or\u2014I don\u2019t know\u2014oodles of libraries and applications that have been around for literally decades that bring huge value to vast scientific and mathematic audiences, but whose number primitives break type checking if one abides by the ubiquitous bum steer, \u201cI don\u2019t have any experience trying to do what you\u2019re doing, but just use float , bro.\u201d Because, hey, \ud83e\udd2c numbers! Am I right? \u21a9 Even though the syntax is legal and beartype gladly does the right thing by treating the tuple literal as a Union . Not sure if this is a bug or a feature, but my vote is for feature. \u21a9 I.E., one of: 0 , off , f , false , and no . \u21a9","title":"Introduction"},{"location":"#numerary-now-with-protocol-powertm","text":"That\u2019s right! For a hopefully limited time, you too can benefit from someone else\u2019s deranged work-arounds for the enormous chasms in Python that lie between the esoteric fields of computation that are \u201ctyping\u201d and \u201cnumbers\u201d instead of having to develop your own out of sheer desperation from first principles ! numerary is a pure-Python codified rant for signaling that your interface is usable with non-native numeric primitives 1 without breaking type checking. If you\u2019re thinking that you shouldn\u2019t need a \ud83e\udd2cing library for that, you\u2019re right . numerary should enjoy no audience. It should not exist. Yet here we are. Its author gauges its success by how quickly it can be deleted as superfluous. (I\u2019m looking at you, maintainers.) numerary is licensed under the GLWTS License (NSFW version only ) and comes with absolutely zero warranty for any purpose whatsoever. See the accompanying LICENSE file for details. It should be considered experimental for now, but should settle down quickly. See the release notes for a summary of version-to-version changes. Source code is available on GitHub . If you find it lacking in any way, please don\u2019t hesitate to bring it to my attention .","title":"numerary - Now with Protocol Power\u2122"},{"location":"#customers","text":"dyce - a pure-Python library for modeling arbitrarily complex dice mechanics and mother birthing code base \ud83d\ude44 of numerary ! The next one could be you ! \ud83d\udc4b Do you have a project that suffers problems made slightly less annoying by numerary ? Let me know , and I\u2019ll promote it here! And don\u2019t forget to do your part in perpetuating gratuitous badge-ification! 1 2 3 4 <!-- Markdown --> As of version 0.4.1, ``dyce`` is [ ![numerary-encumbered ]( https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg )][numerary-encumbered]! [ numerary-encumbered ]: https://posita.github.io/numerary/ \"numerary-encumbered!\" 1 2 3 4 5 6 7 8 9 .. reStructuredText - see https://docutils.sourceforge.io/docs/ref/rst/directives.html#image As of version 0.4.1, ``dyce`` is |numerary-encumbered|! .. |numerary-encumbered| image :: https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg :align: top :target: https://posita.github.io/numerary/ :alt: numerary-encumbered 1 2 3 4 5 <!-- HTML --> As of version 0.4.1, < code > dyce </ code > is < a href = \"https://posita.github.io/numerary/\" >< img src = \"https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg\" alt = \"numerary-encumbered\" style = \"vertical-align: middle;\" ></ a > !","title":"Customers"},{"location":"#the-calculation-function-an-allegory","text":"We have a simple vision. We want to define an API that works with reals (not just float s), performs a calculation, and returns integers (not just int s). 1 2 3 4 5 >>> from time import sleep >>> def deep_thought ( arg ): ... sleep ( 7_500_000 * 365.24219265 * 24 * 60 * 60 ) # doctest: +SKIP ... assert arg != 0 and arg ** 0 == 1 ... return 42 We want to tell the world how to call it and what to expect in return, so we annotate it: 1 2 3 >>> def deep_thought_typed ( arg : float ) -> int : ... assert arg != 0 and arg ** 0 == 1 ... return 42 So simple! We\u2019re done, right? Not quite. We find that the runtime works well, but we\u2019re getting type checking errors. 1 2 3 4 5 >>> deep_thought_typed ( 1.0 ) # this is fine ... 42 >>> from fractions import Fraction >>> deep_thought_typed ( Fraction ( 1 , 2 )) # type: ignore # ... but this fails 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_typed\" has incompatible type \"Fraction\"; expected \"float\" With a little research, we learn about the numeric tower [cue angelic singing] . Surely, it has the answer! Both float and Fraction are Real s. Let\u2019s test that to make sure. 1 2 3 4 5 6 7 >>> from numbers import Integral , Real >>> isinstance ( 42 , Integral ) True >>> isinstance ( 1.0 , Real ) True >>> isinstance ( Fraction ( 1 , 2 ), Real ) True Huzzah! What could be simpler! A small tweak is all that is required. 1 2 3 >>> def deep_thought_towered ( arg : Real ) -> Integral : ... assert arg != 0 and arg ** 0 == 1 ... return 42 # type: ignore # now this fails Without the # type: ignore , we get: 1 \u2026: error: Incompatible return value type (got \"int\", expected \"Integral\") Hold the phone. isinstance(42, Integral) was True , was it not? This is starting to get confusing. 1 2 3 4 5 6 >>> from typing import Union >>> IntegralT = Union [ int , Integral ] >>> RealT = Union [ float , Real ] >>> def deep_thought_crumbling ( arg : RealT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 Well, that was odd , but such warts are a small price to pay. All is right in the world again! 1 2 3 4 5 6 7 >>> deep_thought_crumbling ( 1.0 ) 42 >>> deep_thought_crumbling ( Fraction ( 1 , 2 )) 42 >>> from decimal import Decimal >>> deep_thought_crumbling ( Decimal ( \"0.123\" )) # type: ignore # fails 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_crumbling\" has incompatible type \"Decimal\"; expected \"Union[float, Real]\" Oh, come on ! 1 2 3 4 5 6 >>> RealAndDecimalT = Union [ float , Real , Decimal ] >>> def deep_thought_toppled ( arg : RealAndDecimalT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 >>> deep_thought_toppled ( Decimal ( \"0.123\" )) 42 \ud83e\udd2c me. If we have to engage in these kinds of gymnastics just to reach escape velocity from the standard library, how the heck are we supposed to survive contact with numeric implementations we haven\u2019t even heard of yet?! We can\u2019t enumerate them all ! For many years, the numeric tower was declared a \u201cdead end\u201d by maintainers. Unsurprisingly, many longstanding library authors didn\u2019t see much benefit to conforming to its API. Adoption has grown, but we can\u2019t rely on it. What should we rely on, then? Surely the exalted few who have steered us away from one thing are prepared to steer us toward something else, no? Sadly, the apparent attitude of many seems to be, \u201cSomething, something, protocols? Meh. I don\u2019t know. We\u2019ll figure it out later.\u201d Can we fix this with protocols? The standard library provides some simple precedents . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore >>> from typing import Iterable , Union >>> @runtime_checkable ... class SupportsNumeratorDenominator ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @property ... def numerator ( self ) -> int : ... ... @property ... def denominator ( self ) -> int : ... >>> def require_rational ( arg : SupportsNumeratorDenominator ) -> None : ... assert isinstance ( arg , SupportsNumeratorDenominator ) >>> require_rational ( 1 ) >>> require_rational ( Fraction ( 1 , 2 )) >>> require_rational ( 1.0 ) # type: ignore Traceback ( most recent call last ): ... AssertionError Without the # type: ignore , we get: 1 2 3 \u2026: error: Argument 1 to \"require_rational\" has incompatible type \"float\"; expected \"SupportsNumeratorDenominator\" \u2026: note: \"float\" is missing following \"SupportsNumeratorDenominator\" protocol members: \u2026: note: denominator, numerator Oh. My. Godetia. Could this be it? Have we stumbled into the promised land? Let\u2019s see how they perform. First, let\u2019s get a baseline. 1 2 3 4 5 6 7 8 9 10 11 12 In [ 13 ]: % timeit - r10 isinstance ( val , Rational ) 326 ns \u00b1 1.26 ns per loop ( mean \u00b1 std . dev . of 10 runs , 1000000 loops each ) In [ 14 ]: val = Fraction ( 1 , 2 ) In [ 15 ]: % timeit - r10 isinstance ( val , Rational ) 329 ns \u00b1 1.87 ns per loop ( mean \u00b1 std . dev . of 10 runs , 1000000 loops each ) In [ 16 ]: val = 1.0 In [ 17 ]: % timeit - r10 isinstance ( val , Rational ) 351 ns \u00b1 1.29 ns per loop ( mean \u00b1 std . dev . of 10 runs , 1000000 loops each ) Now let\u2019s compare that with our two-property protocol. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 In [ 21 ]: val = 1 In [ 22 ]: % timeit - r10 isinstance ( val , SupportsNumeratorDenominator ) 12.2 \u00b5s \u00b1 203 ns per loop ( mean \u00b1 std . dev . of 10 runs , 100000 loops each ) In [ 23 ]: val = Fraction ( 1 , 2 ) In [ 24 ]: % timeit - r10 isinstance ( val , SupportsNumeratorDenominator ) 12.3 \u00b5s \u00b1 62 ns per loop ( mean \u00b1 std . dev . of 10 runs , 100000 loops each ) In [ 25 ]: val = 1.0 In [ 26 ]: % timeit - r10 isinstance ( val , SupportsNumeratorDenominator ) 12.4 \u00b5s \u00b1 97.8 ns per loop ( mean \u00b1 std . dev . of 10 runs , 100000 loops each ) That\u2019s forty times slower. \ud83d\ude36 And that\u2019s just with a two-property protocol. How much worse would it be if we had enumerated all the dunder methods? \ud83d\ude30 You know what? Never mind that. Where there\u2019s a will, there\u2019s a way. Note to self, \u201cSolve the performance problems with protocols later, but we\u2019re definitely onto something!\u201d Let\u2019s do another one. Real numbers have comparisons that complex ones don\u2019t. That seems as good a place as any to tackle next. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore >>> from abc import abstractmethod >>> from typing import Any , Iterable , Union >>> @runtime_checkable ... class SupportsRealComparisons ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @abstractmethod ... def __lt__ ( self , other : Any ) -> bool : ... ... @abstractmethod ... def __le__ ( self , other : Any ) -> bool : ... ... @abstractmethod ... def __ge__ ( self , other : Any ) -> bool : ... ... @abstractmethod ... def __gt__ ( self , other : Any ) -> bool : ... >>> def require_real ( arg : SupportsRealComparisons ) -> None : ... assert isinstance ( arg , SupportsRealComparisons ) >>> require_real ( 1 ) >>> require_real ( Fraction ( 1 , 2 )) >>> require_real ( 1.0 ) >>> require_real ( complex ( 0 )) # type: ignore # should go ka-boom! Where was the ka-boom? There was supposed to be an earth-shattering ka-boom! Type checking spotted the error. Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"require_real\" has incompatible type \"complex\"; expected \"SupportsRealComparisons\" So what gives? Why does our protocol think a complex has comparisons at runtime? It\u2019s a complex number and complex numbers don\u2019t have those. The standard library says so ! 1 2 3 4 5 6 7 >>> from numbers import Complex >>> isinstance ( complex ( 0 ), Complex ) True >>> hasattr ( Complex , \"__le__\" ) True >>> complex ( 0 ) . __le__ # type: ignore <... method ... complex ...> What the shit? Do they work? 1 2 3 4 >>> complex ( 0 ) <= complex ( 0 ) # type: ignore Traceback ( most recent call last ): ... TypeError : '<=' not supported between instances of 'complex' and 'complex' Wait. Complex numbers implement comparisons in complete contradiction to the documentation just to return NotImplemented ?! \ud83e\udd2c off ! How does Mypy know? Because the type definitions for complex and Complex are lies that conveniently omit mention of those methods. Quote \u201cWhen it becomes serious, you have to lie.\u201d \u2014Jean-Claude Juncker Do you see?! Do you see now why we can\u2019t have nice things?! I mean, I get casting as a rare case, but who builds sophisticated deception tooling into the very fabric a type definition mechanism to claim that non-compliant native primitives comply? How can you trust anything anymore?! Shouldn\u2019t that be a pretty strong hint that maybe you should step back and rethink your approach? Astute readers may note beartype could help restore truth for us. 1 2 3 4 5 6 7 8 9 from beartype import beartype from beartype.vale import Is from typing import Annotated SupportsRealComparisonsNotComplexLies = Annotated [ SupportsRealComparisons , Is [ lambda arg : not isinstance ( arg , complex )] ] @beartype def require_real ( arg : SupportsRealComparisons ) -> None : assert isinstance ( arg , SupportsRealComparisons ) That\u2019s because Bear is hip to the scene. Bear is down . Bear knows what\u2019s what. If you have a typing problem, if no one else can help, and if you can find them (which should be easy; I just gave you the link ; twice), maybe you can hire the Bear-Team. I digress. Okay. Can we still work with any of this shit and have type checking? Dunno. Let\u2019s try. Because somebody \ud83e\udd2cing has to.","title":"The calculation function, an allegory"},{"location":"#a-taste","text":"numerary strives to define composable, efficient protocols that one can use to construct numeric requirements. It expands on the Supports pattern used in the standard library. For example, numerary.types.SupportsIntegralOps is a @typing.runtime_checkable protocol that approximates the binary operators introduced by numbers.Integral . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 >>> from numerary.types import SupportsIntegralOps >>> def shift_right_one ( arg : SupportsIntegralOps ) -> SupportsIntegralOps : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg >> 1 >>> shift_right_one ( 2 ) 1 >>> from sympy import sympify >>> two = sympify ( \"2\" ) ; type ( two ) < class ' sympy . core . numbers . Integer '> >>> res = shift_right_one ( two ) ; res 1 >>> type ( res ) < class ' sympy . core . numbers . One '> >>> shift_right_one ( Fraction ( 1 , 2 )) # type: ignore # properly caught by Mypy Traceback ( most recent call last ): ... AssertionError Note that the above would still (properly) result in a type checking error as well as a runtime failure for SymPy versions prior to 1.9, because, until 1.9, sympy.core.numbers.Integer lacked the requisite bitwise operators . By default, protocols frustrate runtime type checking performance . numerary applies two layered optimization strategies: cached __instancecheck__ results for numerary -defined protocols and short-circuit type enumerations.","title":"A taste"},{"location":"#cached-__instancecheck__-results","text":"It caches, so it\u2019s faster. Bang. Done. (NSFW warning. Although, in retrospect, that warning probably should have been presented more prominently and earlier in this diatribe.) TODO(@posita): Describe how this works.","title":"Cached __instancecheck__ results"},{"location":"#short-circuit-type-enumerations","text":"If the interface is to be used most often with native types ( int s, float s, bool s) or those registered with the numeric tower, there is an optimization to be had at runtime by short-circuiting protocol type checking. These come in two flavors. \u2026T objects which are Union s for defining types. \u2026Ts tuples, which are identical to the corresponding Union arguments and useful for runtime isinstance checking. Following our SupportsIntegralOps example from above, numerary defines two additional interfaces (some details and safeguards omitted). 1 2 SupportsIntegralOpsT = Union [ int , bool , Integral , SupportsIntegralOps ] SupportsIntegralOpsTs = ( int , bool , Integral , SupportsIntegralOps ) 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> from numerary.types import SupportsIntegralOpsT # for type annotations >>> def shift_left_one ( arg : SupportsIntegralOpsT ) -> SupportsIntegralOpsT : ... from numerary.types import SupportsIntegralOpsTs # for runtime checking ... assert isinstance ( arg , SupportsIntegralOpsTs ) ... return arg << 1 >>> shift_left_one ( 1 ) 2 >>> shift_left_one ( sympify ( \"1\" )) 2 >>> shift_left_one ( \"1\" ) # type: ignore Traceback ( most recent call last ): ... AssertionError Why two? Because you can\u2019t do this: 1 isinstance ( 1 , Union [ int , Integral ]) # syntax error And because Mypy is confused by this 2 : 1 2 def my_func ( arg : ( int , Integral )): # Mypy \"syntax\" error pass So Python needs one thing for isinstance checks, and Mypy needs an entirely separate thing for annotations. Yay. \ud83d\ude12 Does the Union provide any benefit? Yes. Because beartype . beartype is awesome . Its author is even awesomer . More generally, runtime checkers that inspect and enforce annotations face problems similar to isinstance . Defining a Union provides an annotation-based short-circuit opportunity to those checkers. There\u2019s a downside, though. (Isn\u2019t there always?) Short-circuiting trusts implementations when they register themselves in the numeric tower. But sometimes, out there in the real world, they lie . Consider: 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsRealImag , SupportsRealImagTs >>> hasattr ( Integral , \"real\" ) and hasattr ( Integral , \"imag\" ) True >>> one = sympify ( \"1\" ) >>> isinstance ( one , Integral ) True >>> hasattr ( one , \"real\" ) or hasattr ( one , \"imag\" ) # somebody's tellin' stories False >>> isinstance ( one , SupportsRealImag ) # detects the lie False >>> isinstance ( one , SupportsRealImagTs ) # trusts the registration True","title":"Short-circuit type enumerations"},{"location":"#shut-up-and-take-my-money","text":"All that being said, if all you deal with are integrals and reals and what you want is arithmetic operator compatibility, this should probably get you most of where you likely want to go: 1 2 3 4 >>> from numerary import IntegralLike , RealLike >>> def deeper_thought ( arg : RealLike ) -> IntegralLike : ... assert arg != 0 and arg ** 0 == 1 ... return arg // arg + 42 \u2026 or, if you prefer the short-circuiting versions \u2026 1 >>> from numerary import IntegralLikeT , IntegralLikeTs , RealLikeT , RealLikeTs Much more coming soon. I promise ! No, really. Not a PEP promise. A real one. \u270c\ufe0f\ud83d\ude0a","title":"Shut up and take my money!"},{"location":"#license","text":"numerary is licensed under the GLWTS License (NSFW version only ). See the included LICENSE file for details. Source code is available on GitHub .","title":"License"},{"location":"#installation","text":"Installation can be performed via PyPI . 1 2 % pip install numerary ... Alternately, you can download the source and install manually. 1 2 3 4 5 % git clone https://github.com/posita/numerary.git ... % cd numerary % python -m pip install . # -or- python -c 'from setuptools import setup ; setup()' install . ...","title":"Installation"},{"location":"#requirements","text":"numerary requires a relatively modern version of Python: CPython (3.7+) PyPy (CPython 3.7+ compatible) It has the following runtime dependencies: typing-extensions (with Python <3.9) numerary will opportunistically use the following, if available at runtime: beartype for yummy runtime type-checking goodness (0.8+) If you use beartype for type checking your code that interacts with numerary , but don\u2019t want numerary to use it internally (e.g., for performance reasons), set the NUMERARY_BEARTYPE environment variable to a falsy 3 value before numerary is loaded. See the hacking quick-start for additional development and testing dependencies. You know, super weird, off-the-wall shit, like members of the numeric tower , or standard library primitives that remain non -members for some \ud83e\udd2ced up reason , or legitimate non-members because they predate PEP 3141 and conforming would amount to breaking changes , or\u2014I don\u2019t know\u2014oodles of libraries and applications that have been around for literally decades that bring huge value to vast scientific and mathematic audiences, but whose number primitives break type checking if one abides by the ubiquitous bum steer, \u201cI don\u2019t have any experience trying to do what you\u2019re doing, but just use float , bro.\u201d Because, hey, \ud83e\udd2c numbers! Am I right? \u21a9 Even though the syntax is legal and beartype gladly does the right thing by treating the tuple literal as a Union . Not sure if this is a bug or a feature, but my vote is for feature. \u21a9 I.E., one of: 0 , off , f , false , and no . \u21a9","title":"Requirements"},{"location":"contrib/","text":"Contributing to numerary There are many ways you can contribute. You have only but to try. Filing issues You can file new issues as you find them. Please try to avoid duplicating issues. \u201cWriting Effective Bug Reports\u201d by Elisabeth Hendrickson (PDF) may be helpful. Hacking quick-start An easy way to bootstrap an isolated development environment is: 1 2 3 4 5 6 7 8 9 10 % git clone --recurse-submodules https://github.com/posita/numerary.git \u2026 % cd numerary % /path/to/python -m venv .venv \u2026 % . .venv/bin/activate % pip install --upgrade --editable '.[dev]' \u2026 % python -m pre_commit install \u2026 Substitute your preferred virtual environment process for venv . The [dev] variant includes additional dependencies necessary for development and testing. See the [options.extras_require] section in setup.cfg . Unit tests are run with pytest via Tox . 1 2 3 4 % cd \u2026/path/to/numerary % . .venv/bin/activate % tox [ TOX_ARGS... [ -- PYTEST_ARGS... ]] \u2026 Submission guidelines If you are willing and able, consider submitting a pull request with a fix. See the docs if you\u2019re not already familiar with pull requests. numerary releases from master (although not always immediately), so a lot of these workflows are helpful. There are only a few additional guidelines: If it is not already present, please add your name (and optionally your email, GitHub username, website address, or other contact information) to the LICENSE file. 1 2 3 ... * [ Matt Bogosian ]( mailto:matt@bogosian.net?Subject=numerary ); GitHub \u2013 [ **@posita** ](https://github.com/posita) ... Use Black to format your changes. Do your best to follow the source conventions as you observe them. If it\u2019s important to you, Existing comments are wrapped at 88 characters per line to match Black\u2019s default. (Don\u2019t spend too much effort on strict conformance, though. I can clean things up later if they really bother me.) Provide tests where feasible and appropriate. At the very least, existing tests should not fail. (There are exceptions, but if there is any doubt, they probably do not apply.) Unit tests live in tests . If you want feedback on a work-in-progress, consider \u201cmentioning\u201d me ( @posita ), and describe specifically how I can help. Consider prefixing your pull request\u2019s title with something like, \u201c NEED FEEDBACK \u2013 \u201d. If your pull request is still in progress, but you are not blocked on anything, consider using the draft feature . Once you are ready for a merge, resolve any conflicts, squash your commits, and provide a useful commit message. ( This and this may be helpful.) If your pull request started out as a draft, promote it by requesting a review. Consider prefixing the pull request\u2019s title to something like, \u201c READY FOR MERGE \u2013 \u201d. I will try to get to it as soon as I can.","title":"Contributing"},{"location":"contrib/#contributing-to-numerary","text":"There are many ways you can contribute. You have only but to try.","title":"Contributing to numerary"},{"location":"contrib/#filing-issues","text":"You can file new issues as you find them. Please try to avoid duplicating issues. \u201cWriting Effective Bug Reports\u201d by Elisabeth Hendrickson (PDF) may be helpful.","title":"Filing issues"},{"location":"contrib/#hacking-quick-start","text":"An easy way to bootstrap an isolated development environment is: 1 2 3 4 5 6 7 8 9 10 % git clone --recurse-submodules https://github.com/posita/numerary.git \u2026 % cd numerary % /path/to/python -m venv .venv \u2026 % . .venv/bin/activate % pip install --upgrade --editable '.[dev]' \u2026 % python -m pre_commit install \u2026 Substitute your preferred virtual environment process for venv . The [dev] variant includes additional dependencies necessary for development and testing. See the [options.extras_require] section in setup.cfg . Unit tests are run with pytest via Tox . 1 2 3 4 % cd \u2026/path/to/numerary % . .venv/bin/activate % tox [ TOX_ARGS... [ -- PYTEST_ARGS... ]] \u2026","title":"Hacking quick-start"},{"location":"contrib/#submission-guidelines","text":"If you are willing and able, consider submitting a pull request with a fix. See the docs if you\u2019re not already familiar with pull requests. numerary releases from master (although not always immediately), so a lot of these workflows are helpful. There are only a few additional guidelines: If it is not already present, please add your name (and optionally your email, GitHub username, website address, or other contact information) to the LICENSE file. 1 2 3 ... * [ Matt Bogosian ]( mailto:matt@bogosian.net?Subject=numerary ); GitHub \u2013 [ **@posita** ](https://github.com/posita) ... Use Black to format your changes. Do your best to follow the source conventions as you observe them. If it\u2019s important to you, Existing comments are wrapped at 88 characters per line to match Black\u2019s default. (Don\u2019t spend too much effort on strict conformance, though. I can clean things up later if they really bother me.) Provide tests where feasible and appropriate. At the very least, existing tests should not fail. (There are exceptions, but if there is any doubt, they probably do not apply.) Unit tests live in tests . If you want feedback on a work-in-progress, consider \u201cmentioning\u201d me ( @posita ), and describe specifically how I can help. Consider prefixing your pull request\u2019s title with something like, \u201c NEED FEEDBACK \u2013 \u201d. If your pull request is still in progress, but you are not blocked on anything, consider using the draft feature . Once you are ready for a merge, resolve any conflicts, squash your commits, and provide a useful commit message. ( This and this may be helpful.) If your pull request started out as a draft, promote it by requesting a review. Consider prefixing the pull request\u2019s title to something like, \u201c READY FOR MERGE \u2013 \u201d. I will try to get to it as soon as I can.","title":"Submission guidelines"},{"location":"license/","text":"GLWTS (Good Luck With That Shit) Public License Copyright (c) Every-fucking-one, except the Author Everyone is permitted to copy, distribute, modify, merge, sell, publish, sublicense or whatever the fuck they want with this software but at their OWN RISK. Preamble The author has absolutely no fucking clue what the code in this project does. It might just fucking work or not, there is no third option. GOOD LUCK WITH THAT SHIT PUBLIC LICENSE TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION, AND MODIFICATION You just DO WHATEVER THE FUCK YOU WANT TO as long as you NEVER LEAVE A FUCKING TRACE TO TRACK THE AUTHOR of the original product to blame for or held responsible. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Good luck and Godspeed.","title":"License"},{"location":"license/#glwts-good-luck-with-that-shit-public-license","text":"Copyright (c) Every-fucking-one, except the Author Everyone is permitted to copy, distribute, modify, merge, sell, publish, sublicense or whatever the fuck they want with this software but at their OWN RISK.","title":"GLWTS (Good Luck With That Shit) Public License"},{"location":"license/#preamble","text":"The author has absolutely no fucking clue what the code in this project does. It might just fucking work or not, there is no third option.","title":"Preamble"},{"location":"license/#good-luck-with-that-shit-public-license","text":"","title":"GOOD LUCK WITH THAT SHIT PUBLIC LICENSE"},{"location":"license/#terms-and-conditions-for-copying-distribution-and-modification","text":"You just DO WHATEVER THE FUCK YOU WANT TO as long as you NEVER LEAVE A FUCKING TRACE TO TRACK THE AUTHOR of the original product to blame for or held responsible. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Good luck and Godspeed.","title":"TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION, AND MODIFICATION"},{"location":"notes/","text":"numerary release notes 0.0.1 numerary leaves the dyce nest to become its own library!","title":"Release notes"},{"location":"notes/#numerary-release-notes","text":"","title":"numerary release notes"},{"location":"notes/#001","text":"numerary leaves the dyce nest to become its own library!","title":"0.0.1"},{"location":"numerary/","text":"numerary package reference Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. These are composition protocols that should suit common use cases. IntegralLike ( SupportsAbs , SupportsFloat , SupportsIndex , SupportsInt , SupportsIntegralOps , SupportsIntegralPow , SupportsRealOps , SupportsComplexOps , Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __hash__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __hash__ ( self ) -> int : ... __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True RationalLike ( SupportsAbs , SupportsFloat , SupportsNumeratorDenominator , SupportsRealOps , SupportsComplexOps , SupportsComplexPow , Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __hash__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __hash__ ( self ) -> int : ... __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True RealLike ( SupportsAbs , SupportsFloat , SupportsRealOps , SupportsComplexOps , SupportsComplexPow , Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __hash__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __hash__ ( self ) -> int : ... __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True denominator ( operand : SupportsNumeratorDenominator ) TODO(posita): Document this! Source code in numerary/types.py @beartype def denominator ( operand : SupportsNumeratorDenominator ): r \"\"\" TODO(posita): Document this! \"\"\" if hasattr ( operand , \"denominator\" ): if callable ( operand . denominator ): return operand . denominator () else : return operand . denominator else : raise TypeError ( f \" { operand !r} has no denominator\" ) numerator ( operand : SupportsNumeratorDenominator ) TODO(posita): Document this! Source code in numerary/types.py @beartype def numerator ( operand : SupportsNumeratorDenominator ): r \"\"\" TODO(posita): Document this! \"\"\" if hasattr ( operand , \"numerator\" ): if callable ( operand . numerator ): return operand . numerator () else : return operand . numerator else : raise TypeError ( f \" { operand !r} has no numerator\" )","title":"<tt>numerary</tt>"},{"location":"numerary/#numerary-package-reference","text":"Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. These are composition protocols that should suit common use cases.","title":"numerary package reference"},{"location":"numerary/#numerary.types.IntegralLike","text":"TODO(posita): Document this!","title":"IntegralLike"},{"location":"numerary/#numerary.types.IntegralLike.__slots__","text":"","title":"__slots__"},{"location":"numerary/#numerary.types.IntegralLike.__hash__","text":"Source code in numerary/types.py @abstractmethod def __hash__ ( self ) -> int : ...","title":"__hash__()"},{"location":"numerary/#numerary.types.IntegralLike.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary/#numerary.types.IntegralLike.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary/#numerary.types.RationalLike","text":"TODO(posita): Document this!","title":"RationalLike"},{"location":"numerary/#numerary.types.RationalLike.__slots__","text":"","title":"__slots__"},{"location":"numerary/#numerary.types.RationalLike.__hash__","text":"Source code in numerary/types.py @abstractmethod def __hash__ ( self ) -> int : ...","title":"__hash__()"},{"location":"numerary/#numerary.types.RationalLike.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary/#numerary.types.RationalLike.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary/#numerary.types.RealLike","text":"TODO(posita): Document this!","title":"RealLike"},{"location":"numerary/#numerary.types.RealLike.__slots__","text":"","title":"__slots__"},{"location":"numerary/#numerary.types.RealLike.__hash__","text":"Source code in numerary/types.py @abstractmethod def __hash__ ( self ) -> int : ...","title":"__hash__()"},{"location":"numerary/#numerary.types.RealLike.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary/#numerary.types.RealLike.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary/#numerary.types.denominator","text":"TODO(posita): Document this! Source code in numerary/types.py @beartype def denominator ( operand : SupportsNumeratorDenominator ): r \"\"\" TODO(posita): Document this! \"\"\" if hasattr ( operand , \"denominator\" ): if callable ( operand . denominator ): return operand . denominator () else : return operand . denominator else : raise TypeError ( f \" { operand !r} has no denominator\" )","title":"denominator()"},{"location":"numerary/#numerary.types.numerator","text":"TODO(posita): Document this! Source code in numerary/types.py @beartype def numerator ( operand : SupportsNumeratorDenominator ): r \"\"\" TODO(posita): Document this! \"\"\" if hasattr ( operand , \"numerator\" ): if callable ( operand . numerator ): return operand . numerator () else : return operand . numerator else : raise TypeError ( f \" { operand !r} has no numerator\" )","title":"numerator()"},{"location":"numerary.types/","text":"numerary . types package reference Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. These are additional protocols that can be composed as desired. CachingProtocolMeta ( _ProtocolMeta ) Stand-in for Protocol \u2019s base class that caches results of __instancecheck__ , (which is otherwise really \ud83e\udd2cing expensive ). (When this was introduced, it resulted in about a 5\u00d7 performance increase for dyce \u2019s unit tests, which was the only benchmark I had at the time.) The downside is that this will yield unpredictable results for objects whose methods don\u2019t stem from any type (e.g., are assembled at runtime). I don\u2019t know of any real-world case where that would be true. We\u2019ll jump off that bridge when we come to it. __instancecheck__ ( self , inst : Any ) -> bool special Source code in numerary/types.py def __instancecheck__ ( self , inst : Any ) -> bool : inst_t = type ( inst ) if ( self , inst_t ) not in self . _abc_inst_check_cache : self . _abc_inst_check_cache [ self , inst_t ] = super () . __instancecheck__ ( inst ) return self . _abc_inst_check_cache [ self , inst_t ] __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any ) -> _TT special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in numerary/types.py def __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any , ) -> _TT : # See <https://github.com/python/mypy/issues/9282> cls = super () . __new__ ( mcls , name , bases , namespace , ** kw ) # type: ignore # Prefixing this class member with \"_abc_\" is necessary to prevent it from being # considered part of the Protocol. (See # <https://github.com/python/cpython/blob/main/Lib/typing.py>.) cache : Dict [ Tuple [ type , type ], bool ] = {} cls . _abc_inst_check_cache = cache return cls SupportsAbs ( SupportsAbs , Protocol ) An ABC with one abstract method abs that is covariant in its return type. __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsCeil ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __ceil__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __ceil__ ( self ) -> int : ... __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsComplex ( SupportsComplex , Protocol ) An ABC with one abstract method complex . __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsComplexOps ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __add__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __add__ ( self , other : Any ) -> _T_co : ... __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __mul__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __mul__ ( self , other : Any ) -> _T_co : ... __neg__ ( self ) -> _T_co special Source code in numerary/types.py @abstractmethod def __neg__ ( self ) -> _T_co : ... __pos__ ( self ) -> _T_co special Source code in numerary/types.py @abstractmethod def __pos__ ( self ) -> _T_co : ... __radd__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __radd__ ( self , other : Any ) -> _T_co : ... __rmul__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rmul__ ( self , other : Any ) -> _T_co : ... __rsub__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rsub__ ( self , other : Any ) -> _T_co : ... __rtruediv__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rtruediv__ ( self , other : Any ) -> _T_co : ... __sub__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __sub__ ( self , other : Any ) -> _T_co : ... __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True __truediv__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __truediv__ ( self , other : Any ) -> _T_co : ... SupportsComplexPow ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __pow__ ( self , exponent : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any ) -> _T_co : ... __rpow__ ( self , exponent : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any ) -> _T_co : ... __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsConjugate ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True conjugate ( self ) -> Any Source code in numerary/types.py @abstractmethod def conjugate ( self ) -> Any : ... SupportsDivmod ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ] special Source code in numerary/types.py @abstractmethod def __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: ... __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ] special Source code in numerary/types.py @abstractmethod def __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: ... __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsFloat ( SupportsFloat , Protocol ) An ABC with one abstract method float . __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsFloor ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __floor__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __floor__ ( self ) -> int : ... __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsIndex ( SupportsIndex , Protocol ) An ABC with one abstract method index . __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsInt ( SupportsInt , Protocol ) An ABC with one abstract method int . __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsIntegralOps ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __and__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __and__ ( self , other : Any ) -> _T_co : ... __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __invert__ ( self ) -> _T_co special Source code in numerary/types.py @abstractmethod def __invert__ ( self ) -> _T_co : ... __lshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __lshift__ ( self , other : Any ) -> _T_co : ... __or__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __or__ ( self , other : Any ) -> _T_co : ... __rand__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rand__ ( self , other : Any ) -> _T_co : ... __rlshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rlshift__ ( self , other : Any ) -> _T_co : ... __ror__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __ror__ ( self , other : Any ) -> _T_co : ... __rrshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rrshift__ ( self , other : Any ) -> _T_co : ... __rshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rshift__ ( self , other : Any ) -> _T_co : ... __rxor__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rxor__ ( self , other : Any ) -> _T_co : ... __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True __xor__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __xor__ ( self , other : Any ) -> _T_co : ... SupportsIntegralPow ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co special Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co : ... __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co : ... __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsNumeratorDenominator ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special denominator : int property readonly numerator : int property readonly __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsRealImag ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special imag : Any property readonly real : Any property readonly __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsRealOps ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __floordiv__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __floordiv__ ( self , other : Any ) -> _T_co : ... __ge__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __ge__ ( self , other : Any ) -> bool : ... __gt__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __gt__ ( self , other : Any ) -> bool : ... __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __le__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __le__ ( self , other : Any ) -> bool : ... __lt__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __lt__ ( self , other : Any ) -> bool : ... __mod__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __mod__ ( self , other : Any ) -> _T_co : ... __rfloordiv__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rfloordiv__ ( self , other : Any ) -> _T_co : ... __rmod__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rmod__ ( self , other : Any ) -> _T_co : ... __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsRound ( SupportsRound , Protocol ) An ABC with one abstract method round that is covariant in its return type. __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True SupportsTrunc ( Protocol ) TODO(posita): Document this! __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True __trunc__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __trunc__ ( self ) -> int : ... ceil ( operand : SupportsCeil ) TODO(posita): Document this! Source code in numerary/types.py @beartype def ceil ( operand : SupportsCeil ): r \"\"\" TODO(posita): Document this! \"\"\" assert isinstance ( operand , SupportsFloat ) return math . ceil ( operand ) floor ( operand : SupportsFloor ) TODO(posita): Document this! Source code in numerary/types.py @beartype def floor ( operand : SupportsFloor ): r \"\"\" TODO(posita): Document this! \"\"\" assert isinstance ( operand , SupportsFloat ) return math . floor ( operand ) trunc ( operand : SupportsTrunc ) TODO(posita): Document this! Source code in numerary/types.py @beartype def trunc ( operand : SupportsTrunc ): r \"\"\" TODO(posita): Document this! \"\"\" assert isinstance ( operand , SupportsFloat ) return math . trunc ( operand )","title":"<tt>numerary.types</tt>"},{"location":"numerary.types/#numerarytypes-package-reference","text":"Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. These are additional protocols that can be composed as desired.","title":"numerary.types package reference"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta","text":"Stand-in for Protocol \u2019s base class that caches results of __instancecheck__ , (which is otherwise really \ud83e\udd2cing expensive ). (When this was introduced, it resulted in about a 5\u00d7 performance increase for dyce \u2019s unit tests, which was the only benchmark I had at the time.) The downside is that this will yield unpredictable results for objects whose methods don\u2019t stem from any type (e.g., are assembled at runtime). I don\u2019t know of any real-world case where that would be true. We\u2019ll jump off that bridge when we come to it.","title":"CachingProtocolMeta"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta.__instancecheck__","text":"Source code in numerary/types.py def __instancecheck__ ( self , inst : Any ) -> bool : inst_t = type ( inst ) if ( self , inst_t ) not in self . _abc_inst_check_cache : self . _abc_inst_check_cache [ self , inst_t ] = super () . __instancecheck__ ( inst ) return self . _abc_inst_check_cache [ self , inst_t ]","title":"__instancecheck__()"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in numerary/types.py def __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any , ) -> _TT : # See <https://github.com/python/mypy/issues/9282> cls = super () . __new__ ( mcls , name , bases , namespace , ** kw ) # type: ignore # Prefixing this class member with \"_abc_\" is necessary to prevent it from being # considered part of the Protocol. (See # <https://github.com/python/cpython/blob/main/Lib/typing.py>.) cache : Dict [ Tuple [ type , type ], bool ] = {} cls . _abc_inst_check_cache = cache return cls","title":"__new__()"},{"location":"numerary.types/#numerary.types.SupportsAbs","text":"An ABC with one abstract method abs that is covariant in its return type.","title":"SupportsAbs"},{"location":"numerary.types/#numerary.types.SupportsAbs.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsAbs.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsAbs.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsCeil","text":"TODO(posita): Document this!","title":"SupportsCeil"},{"location":"numerary.types/#numerary.types.SupportsCeil.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsCeil.__ceil__","text":"Source code in numerary/types.py @abstractmethod def __ceil__ ( self ) -> int : ...","title":"__ceil__()"},{"location":"numerary.types/#numerary.types.SupportsCeil.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsCeil.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsComplex","text":"An ABC with one abstract method complex .","title":"SupportsComplex"},{"location":"numerary.types/#numerary.types.SupportsComplex.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsComplex.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsComplex.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps","text":"TODO(posita): Document this!","title":"SupportsComplexOps"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__add__","text":"Source code in numerary/types.py @abstractmethod def __add__ ( self , other : Any ) -> _T_co : ...","title":"__add__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__mul__","text":"Source code in numerary/types.py @abstractmethod def __mul__ ( self , other : Any ) -> _T_co : ...","title":"__mul__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__neg__","text":"Source code in numerary/types.py @abstractmethod def __neg__ ( self ) -> _T_co : ...","title":"__neg__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__pos__","text":"Source code in numerary/types.py @abstractmethod def __pos__ ( self ) -> _T_co : ...","title":"__pos__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__radd__","text":"Source code in numerary/types.py @abstractmethod def __radd__ ( self , other : Any ) -> _T_co : ...","title":"__radd__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__rmul__","text":"Source code in numerary/types.py @abstractmethod def __rmul__ ( self , other : Any ) -> _T_co : ...","title":"__rmul__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__rsub__","text":"Source code in numerary/types.py @abstractmethod def __rsub__ ( self , other : Any ) -> _T_co : ...","title":"__rsub__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__rtruediv__","text":"Source code in numerary/types.py @abstractmethod def __rtruediv__ ( self , other : Any ) -> _T_co : ...","title":"__rtruediv__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__sub__","text":"Source code in numerary/types.py @abstractmethod def __sub__ ( self , other : Any ) -> _T_co : ...","title":"__sub__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsComplexOps.__truediv__","text":"Source code in numerary/types.py @abstractmethod def __truediv__ ( self , other : Any ) -> _T_co : ...","title":"__truediv__()"},{"location":"numerary.types/#numerary.types.SupportsComplexPow","text":"TODO(posita): Document this!","title":"SupportsComplexPow"},{"location":"numerary.types/#numerary.types.SupportsComplexPow.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsComplexPow.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsComplexPow.__pow__","text":"Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any ) -> _T_co : ...","title":"__pow__()"},{"location":"numerary.types/#numerary.types.SupportsComplexPow.__rpow__","text":"Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any ) -> _T_co : ...","title":"__rpow__()"},{"location":"numerary.types/#numerary.types.SupportsComplexPow.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsConjugate","text":"TODO(posita): Document this!","title":"SupportsConjugate"},{"location":"numerary.types/#numerary.types.SupportsConjugate.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsConjugate.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsConjugate.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsConjugate.conjugate","text":"Source code in numerary/types.py @abstractmethod def conjugate ( self ) -> Any : ...","title":"conjugate()"},{"location":"numerary.types/#numerary.types.SupportsDivmod","text":"TODO(posita): Document this!","title":"SupportsDivmod"},{"location":"numerary.types/#numerary.types.SupportsDivmod.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsDivmod.__divmod__","text":"Source code in numerary/types.py @abstractmethod def __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: ...","title":"__divmod__()"},{"location":"numerary.types/#numerary.types.SupportsDivmod.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsDivmod.__rdivmod__","text":"Source code in numerary/types.py @abstractmethod def __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: ...","title":"__rdivmod__()"},{"location":"numerary.types/#numerary.types.SupportsDivmod.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsFloat","text":"An ABC with one abstract method float .","title":"SupportsFloat"},{"location":"numerary.types/#numerary.types.SupportsFloat.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsFloat.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsFloat.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsFloor","text":"TODO(posita): Document this!","title":"SupportsFloor"},{"location":"numerary.types/#numerary.types.SupportsFloor.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsFloor.__floor__","text":"Source code in numerary/types.py @abstractmethod def __floor__ ( self ) -> int : ...","title":"__floor__()"},{"location":"numerary.types/#numerary.types.SupportsFloor.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsFloor.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsIndex","text":"An ABC with one abstract method index .","title":"SupportsIndex"},{"location":"numerary.types/#numerary.types.SupportsIndex.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsIndex.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsIndex.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsInt","text":"An ABC with one abstract method int .","title":"SupportsInt"},{"location":"numerary.types/#numerary.types.SupportsInt.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsInt.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsInt.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps","text":"TODO(posita): Document this!","title":"SupportsIntegralOps"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__and__","text":"Source code in numerary/types.py @abstractmethod def __and__ ( self , other : Any ) -> _T_co : ...","title":"__and__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__invert__","text":"Source code in numerary/types.py @abstractmethod def __invert__ ( self ) -> _T_co : ...","title":"__invert__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__lshift__","text":"Source code in numerary/types.py @abstractmethod def __lshift__ ( self , other : Any ) -> _T_co : ...","title":"__lshift__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__or__","text":"Source code in numerary/types.py @abstractmethod def __or__ ( self , other : Any ) -> _T_co : ...","title":"__or__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__rand__","text":"Source code in numerary/types.py @abstractmethod def __rand__ ( self , other : Any ) -> _T_co : ...","title":"__rand__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__rlshift__","text":"Source code in numerary/types.py @abstractmethod def __rlshift__ ( self , other : Any ) -> _T_co : ...","title":"__rlshift__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__ror__","text":"Source code in numerary/types.py @abstractmethod def __ror__ ( self , other : Any ) -> _T_co : ...","title":"__ror__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__rrshift__","text":"Source code in numerary/types.py @abstractmethod def __rrshift__ ( self , other : Any ) -> _T_co : ...","title":"__rrshift__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__rshift__","text":"Source code in numerary/types.py @abstractmethod def __rshift__ ( self , other : Any ) -> _T_co : ...","title":"__rshift__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__rxor__","text":"Source code in numerary/types.py @abstractmethod def __rxor__ ( self , other : Any ) -> _T_co : ...","title":"__rxor__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps.__xor__","text":"Source code in numerary/types.py @abstractmethod def __xor__ ( self , other : Any ) -> _T_co : ...","title":"__xor__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow","text":"TODO(posita): Document this!","title":"SupportsIntegralPow"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow.__pow__","text":"Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co : ...","title":"__pow__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow.__rpow__","text":"Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co : ...","title":"__rpow__()"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominator","text":"TODO(posita): Document this!","title":"SupportsNumeratorDenominator"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominator.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominator.denominator","text":"","title":"denominator"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominator.numerator","text":"","title":"numerator"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominator.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominator.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsRealImag","text":"TODO(posita): Document this!","title":"SupportsRealImag"},{"location":"numerary.types/#numerary.types.SupportsRealImag.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsRealImag.imag","text":"","title":"imag"},{"location":"numerary.types/#numerary.types.SupportsRealImag.real","text":"","title":"real"},{"location":"numerary.types/#numerary.types.SupportsRealImag.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsRealImag.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps","text":"TODO(posita): Document this!","title":"SupportsRealOps"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__floordiv__","text":"Source code in numerary/types.py @abstractmethod def __floordiv__ ( self , other : Any ) -> _T_co : ...","title":"__floordiv__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__ge__","text":"Source code in numerary/types.py @abstractmethod def __ge__ ( self , other : Any ) -> bool : ...","title":"__ge__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__gt__","text":"Source code in numerary/types.py @abstractmethod def __gt__ ( self , other : Any ) -> bool : ...","title":"__gt__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__le__","text":"Source code in numerary/types.py @abstractmethod def __le__ ( self , other : Any ) -> bool : ...","title":"__le__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__lt__","text":"Source code in numerary/types.py @abstractmethod def __lt__ ( self , other : Any ) -> bool : ...","title":"__lt__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__mod__","text":"Source code in numerary/types.py @abstractmethod def __mod__ ( self , other : Any ) -> _T_co : ...","title":"__mod__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__rfloordiv__","text":"Source code in numerary/types.py @abstractmethod def __rfloordiv__ ( self , other : Any ) -> _T_co : ...","title":"__rfloordiv__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__rmod__","text":"Source code in numerary/types.py @abstractmethod def __rmod__ ( self , other : Any ) -> _T_co : ...","title":"__rmod__()"},{"location":"numerary.types/#numerary.types.SupportsRealOps.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsRound","text":"An ABC with one abstract method round that is covariant in its return type.","title":"SupportsRound"},{"location":"numerary.types/#numerary.types.SupportsRound.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsRound.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsRound.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsTrunc","text":"TODO(posita): Document this!","title":"SupportsTrunc"},{"location":"numerary.types/#numerary.types.SupportsTrunc.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types.SupportsTrunc.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types.SupportsTrunc.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types.SupportsTrunc.__trunc__","text":"Source code in numerary/types.py @abstractmethod def __trunc__ ( self ) -> int : ...","title":"__trunc__()"},{"location":"numerary.types/#numerary.types.ceil","text":"TODO(posita): Document this! Source code in numerary/types.py @beartype def ceil ( operand : SupportsCeil ): r \"\"\" TODO(posita): Document this! \"\"\" assert isinstance ( operand , SupportsFloat ) return math . ceil ( operand )","title":"ceil()"},{"location":"numerary.types/#numerary.types.floor","text":"TODO(posita): Document this! Source code in numerary/types.py @beartype def floor ( operand : SupportsFloor ): r \"\"\" TODO(posita): Document this! \"\"\" assert isinstance ( operand , SupportsFloat ) return math . floor ( operand )","title":"floor()"},{"location":"numerary.types/#numerary.types.trunc","text":"TODO(posita): Document this! Source code in numerary/types.py @beartype def trunc ( operand : SupportsTrunc ): r \"\"\" TODO(posita): Document this! \"\"\" assert isinstance ( operand , SupportsFloat ) return math . trunc ( operand )","title":"trunc()"}]}