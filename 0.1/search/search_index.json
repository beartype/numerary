{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Copyright and other protections apply. Please see the accompanying LICENSE file for rights and restrictions governing use of this software. All rights not expressly waived or licensed are reserved. If that file is missing or appears to be modified from its original, then please contact the author before viewing or using this software in any capacity. Are you defining a numeric interface that should work with more than just int s and float s? Are you annotating that interface for documentation and type-checking? Were you excited by PEP 3141 \u2019s glitz and gloss promising a clean, straightforward number type definition mechanism, only to learn the hard way\u2014after many hours of searching, tweaking, hacking, and testing ever more convoluted code, again and again\u2014that you could\u2019t actually make it work with Python\u2019s type-checking system? Do you now wonder whether numbers were something new to computing in general because nothing else would explain such a gaping hole in a programming language so popular with the STEM crowd that has been around since the early 1990s? Does the number 3186 haunt you in your dreams? Do you find yourself shouting to no one in particular, \u201cThere has to be a better way?\u201d Well I\u2019m here to tell you there ain\u2019t. But until there is, there\u2019s \u2026 numerary \u2014Now with Protocol Power\u2122 That\u2019s right! For a hopefully limited time, you too can benefit from someone else\u2019s deranged work-arounds for the enormous chasms in Python that lie between the esoteric fields of computation that are \u201ctyping\u201d and \u201cnumbers\u201d instead of having to roll your own out of sheer desperation from first principles ! If you still have no idea what I\u2019m talking about, this may help illustrate . numerary is a pure-Python codified rant for signaling that your interface is usable with non-native numeric primitives 1 without breaking type-checking. More simply, numerary aspires to a world where numbers and types can work together. If you\u2019re thinking that you shouldn\u2019t need a \ud83e\udd2cing library for that, you\u2019re right . This madness should enjoy no audience. It should not exist. Yet here we are. Its author gauges its success by how quickly it can be forgotten, relegated to the annals of superfluous folly. numerary is licensed under the MIT License . See the accompanying LICENSE file for details. It should be considered experimental for now, but should settle down quickly. See the release notes for a summary of version-to-version changes. Source code is available on GitHub . If you find it lacking in any way, please don\u2019t hesitate to bring it to my attention . You had me at, \u201cnumbers and types can work together\u201d numerary strives to define composable, efficient protocols that one can use to construct numeric requirements. If all you deal with are integrals and reals, and what you want is broad arithmetic operator compatibility, this will probably get you where you likely want to go: 1 2 3 4 5 >>> from numerary import IntegralLike , RealLike >>> def deeper_thot ( arg : RealLike ) -> IntegralLike : ... assert arg != 0 and arg ** 0 == 1 ... return arg // arg + 42 Beyond default compositions for common use cases, numerary expands on the Supports pattern used in the standard library. For example, numerary.types.SupportsIntegralOps is a @typing.runtime_checkable protocol that approximates the unary and binary operators introduced by numbers.Integral . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from numerary.types import SupportsIntegralOps >>> def shift_right_one ( arg : SupportsIntegralOps ) -> SupportsIntegralOps : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg >> 1 >>> shift_right_one ( 2 ) 1 >>> from sympy import sympify >>> two = sympify ( \"2\" ) ; type ( two ) < class ' sympy . core . numbers . Integer '> >>> res = shift_right_one ( two ) ; res 1 >>> type ( res ) < class ' sympy . core . numbers . One '> >>> from fractions import Fraction >>> shift_right_one ( Fraction ( 1 , 2 )) # type: ignore [arg-type] # properly caught by Mypy Traceback ( most recent call last ): ... AssertionError Note Until 1.9, sympy.core.numbers.Integer lacked the requisite bitwise operators . numerary catches that! The above properly results in both a type-checking error as well as a runtime failure for SymPy versions prior to 1.9. numerary \u2019s Supports protocols can be composed to refine requirements. For example, let\u2019s say one wanted to ensure type compatibility with primitives that support both __abs__ and __divmod__ . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 >>> from typing import TypeVar >>> T_co = TypeVar ( \"T_co\" , covariant = True ) >>> from numerary.types import ( ... CachingProtocolMeta , Protocol , runtime_checkable , ... SupportsAbs , SupportsDivmod , ... ) >>> @runtime_checkable ... class MyType ( ... SupportsAbs [ T_co ], SupportsDivmod [ T_co ], ... Protocol , metaclass = CachingProtocolMeta , ... ): pass >>> my_type : MyType >>> my_type = 3.5 >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) 3.5 >>> divmod ( my_type , 2 ) ( 1.0 , 1.5 ) >>> from fractions import Fraction >>> my_type = Fraction ( 22 , 7 ) >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) Fraction ( 22 , 7 ) >>> divmod ( my_type , 2 ) ( 1 , Fraction ( 8 , 7 )) >>> from decimal import Decimal >>> my_type = Decimal ( \"5.2\" ) >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) Decimal ( '5.2' ) >>> divmod ( my_type , 2 ) ( Decimal ( '2' ), Decimal ( '1.2' )) >>> my_type = \"nope\" # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( my_type , MyType ) False Remember that scandal where complex defined exception-throwing comparators it wasn\u2019t supposed to have, which confused runtime protocol checking, and then its type definitions lied about it to cover it up ? Yeah, that shit ends here . 1 2 3 4 5 6 >>> from numerary.types import SupportsRealOps >>> isinstance ( 1.0 , SupportsRealOps ) # all good True >>> has_real_ops : SupportsRealOps = complex ( 1 ) # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( complex ( 1 ), SupportsRealOps ) # you're not fooling anyone, buddy False That is because numerary not only caches runtime protocol evaluations, but allows overriding those evaluations when the default machinery gets it wrong. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 >>> from abc import abstractmethod >>> from typing import Iterable , Union >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsOne ( Protocol , metaclass = CachingProtocolMeta ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @abstractmethod ... def one ( self ) -> int : pass >>> class Imposter : ... def one ( self ) -> str : ... return \"one\" >>> imp : SupportsOne = Imposter () # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( imp , SupportsOne ) # fool me once, shame on you ... True >>> SupportsOne . excludes ( Imposter ) >>> isinstance ( imp , SupportsOne ) # ... can't get fooled again False numerary has default overrides to correct for known oddities with native types (like our old friend, complex ) and with popular libraries like numpy and sympy . Others will be added as they are identified. If I\u2019ve missed any, or if you would like numerary to support additional number implementations out of the box, please let me know . Performance Enhanced Protocols\u2014A different kind of \u201cPEP\u201d for your step By default, protocols frustrate runtime type-checking performance . A lot. numerary applies two distinct, layered optimization strategies: Cached __instancecheck__ results for numerary -defined protocols; and Optional(-ish) short-circuit type enumerations. Cached __instancecheck__ results To understand why numerary protocols are faster for runtime checks, it helps to understand why non- numerary protocols are so slow. At runtime (i.e., via isinstance ), the default Protocol implementation delegates to _ProtocolMeta.__instancecheck__ to perform a crude comparison of an instance\u2019s callable attributes against the protocol\u2019s. More attributes means more comparisons. Further, it performs these comparisons \u2026 Every. Single. \ud83e\udd2cing. Time. Protocols provided by numerary use instead CachingProtocolMeta as their meta class. CachingProtocolMeta derives from _ProtocolMeta and overrides __instancecheck__ to cache the default implementation\u2019s results based on instance type. Conceptually: 1 2 3 4 5 6 7 8 >>> isinstance ( 1 , SupportsIntegralOps ) # first check for an int is delegated to _ProtcolMeta.__instancecheck__ True >>> isinstance ( 2 , SupportsIntegralOps ) # cached result True >>> isinstance ( 1.0 , SupportsIntegralOps ) # the first check for a float is delegated to _ProtcolMeta.__instancecheck__ False >>> isinstance ( 2.0 , SupportsIntegralOps ) # cached result False These offer significant performance improvements, especially where protocols define many methods. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 % timeit isinstance ( builtins . int ( 1 ), _SupportsComplexOps ) 11.8 \u00b5s \u00b1 314 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( builtins . int ( 1 ), SupportsComplexOps ) 307 ns \u00b1 2.97 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( builtins . float ( 2.0 ), _SupportsComplexOps ) 11.6 \u00b5s \u00b1 104 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( builtins . float ( 2.0 ), SupportsComplexOps ) 312 ns \u00b1 6.29 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( decimal . Decimal ( 3 ), _SupportsComplexOps ) 11.7 \u00b5s \u00b1 68.1 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( decimal . Decimal ( 3 ), SupportsComplexOps ) 306 ns \u00b1 3.7 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( fractions . Fraction ( 4 ), _SupportsComplexOps ) 11.7 \u00b5s \u00b1 100 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( fractions . Fraction ( 4 ), SupportsComplexOps ) 308 ns \u00b1 4.24 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( sympy . core . numbers . Integer ( 5 ), _SupportsComplexOps ) 11.9 \u00b5s \u00b1 251 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( sympy . core . numbers . Integer ( 5 ), SupportsComplexOps ) 306 ns \u00b1 1.5 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) Source: perf_supports_complex.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from decimal import Decimal from fractions import Fraction from numerary.types import _SupportsComplexOps # non-caching version from numerary.types import SupportsComplexOps # CachingProtocolMeta version import sympy one_int = 1 two_float = 2.0 three_dec = Decimal ( 3 ) four_frac = Fraction ( 4 ) five_sym = sympy . sympify ( 5 ) vals = ( one_int , two_float , three_dec , four_frac , five_sym ) for v in vals : for t in ( _SupportsComplexOps , SupportsComplexOps , ): print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) print () Short-circuit type enumerations If the interface is to be used most often with native types ( int s, float s, bool s), an additional optimization may be had at runtime by short-circuiting protocol type-checking. \u2026SCU objects provide Union s for compliant types. As one example, for the aforementioned SupportsIntegralOps , numerary defines an additional interface. 1 SupportsIntegralOpsSCU = Union [ int , bool , Integral , SupportsIntegralOps ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> from numerary.types import SupportsIntegralOpsSCU >>> def shift_left_one ( arg : SupportsIntegralOpsSCU ) -> SupportsIntegralOpsSCU : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg << 1 >>> shift_left_one ( 1 ) 2 >>> shift_left_one ( sympify ( \"1\" )) 2 >>> shift_left_one ( Fraction ( 1 , 2 )) # type: ignore [arg-type] Traceback ( most recent call last ): ... AssertionError Where do \u2026SCU protocols help? In a word, beartype . beartype is awesome . Its author is even awesomer . 2 More generally, runtime checkers that inspect and enforce annotations may benefit from short-circuiting where protocol validation is expensive. Union s are also useful when trying to accommodate non-compliant primitives that fail static type-checking, but will work anyway at runtime. float s in Python versions prior to 3.9 are an excellent example, because they officially lacked __floor__ and __ceil__ methods, but were registered with the numeric tower and worked just fine with math.floor and math.ceil . How do numerary \u2019s SupportsFloor and SupportsCeil deal with this situation? Not super well on their own, unfortunately. 1 2 3 4 5 6 7 8 9 >>> import math >>> from numerary.types import SupportsFloor >>> def my_dumb_floor_func ( arg : SupportsFloor ) -> int : ... assert isinstance ( arg , SupportsFloor ) # will work, even for floats, thanks to default overrides ... return math . floor ( arg ) # type: ignore [arg-type] # doesn't understand SupportsFloor >>> my_dumb_floor_func ( float ( 1.2 )) # type: ignore [arg-type] # still results in a Mypy error for Python version <3.9 1 Union s allow a work-around for the static type-checking issue. 1 2 3 4 5 6 7 8 9 10 11 >>> from numerary.types import SupportsFloor , SupportsFloorSCU , floor >>> SupportsFloorSCU # float is included here typing . Union [ int , float , bool , numbers . Real , numerary . types . SupportsFloor ] >>> import sys >>> def my_floor_func ( arg : SupportsFloorSCU ) -> int : ... assert isinstance ( arg , SupportsFloor ) ... return floor ( arg ) >>> my_floor_func ( float ( 1.2 )) # works in 3.7+ 1 This is largely a contrived example, since math.floor and math.ceil happily accept SupportsFloat , but it is useful for illustration. Limitations There are some downsides, though. (Aren\u2019t there always?) Sometimes protocols are too trusting Protocols trust numeric tower registrations. TODO(@posita): Is this really true? But sometimes, out there in the real world, implementations lie . Consider: 1 2 3 4 5 6 7 8 9 10 11 >>> from numbers import Integral >>> hasattr ( Integral , \"real\" ) and hasattr ( Integral , \"imag\" ) True >>> import sympy.core.numbers >>> pants_on_fire = sympy . core . numbers . Integer ( 1 ) >>> isinstance ( pants_on_fire , Integral ) True >>> hasattr ( pants_on_fire , \"real\" ) or hasattr ( pants_on_fire , \"imag\" ) # somebody's tellin' stories False >>> from numerary.types import SupportsRealImag >>> real_imag : SupportsRealImag = pants_on_fire # fails to detect the lie Protocols loses fidelity during runtime checking At runtime, protocols match names , not signatures . For example, SupportsNumeratorDenominatorProperties \u2019s numerator and denominator properties will match sage.rings.integer.Integer \u2019s similarly named functions . In other words, isinstance(sage_integer, SupportsNumeratorDenominatorProperties) will return True . Further, if the short-circuiting approach is used, because sage.rings.integer.Integer registers itself with the numeric tower, this may 3 not be caught by Mypy. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 >>> class SageLikeRational : ... def __init__ ( self , numerator : int , denominator : int = 1 ): ... self . _numerator = numerator ... self . _denominator = denominator ... def numerator ( self ) -> int : ... return self . _numerator ... def denominator ( self ) -> int : ... return self . _denominator >>> from numerary.types import SupportsNumeratorDenominatorProperties >>> frac : SupportsNumeratorDenominatorProperties = Fraction ( 29 , 3 ) # no typing error >>> sage_rational1 : SupportsNumeratorDenominatorProperties = SageLikeRational ( 29 , 3 ) # type: ignore [assignment] # Mypy catches this >>> isinstance ( sage_rational1 , SupportsNumeratorDenominatorProperties ) # isinstance does not True >>> sage_rational1 . numerator <... method ... numerator ...> >>> frac . numerator 29 Known warts could be cured by cache overriding as discussed above. However, to combat this particular situation, numerary provides an alternative: the SupportsNumeratorDenominatorMethods protocol and the numerator and denominator helper functions. These allow accommodation of rational implementations like Sage\u2019s that are mostly compliant with the exception of their respective numerator and denominator implementations. 1 2 3 4 5 6 7 8 9 10 >>> from numerary.types import numerator >>> numerator ( sage_rational1 ) 29 >>> numerator ( frac ) 29 >>> from numerary.types import SupportsNumeratorDenominatorMethods , numerator >>> sage_rational2 : SupportsNumeratorDenominatorMethods = SageLikeRational ( 3 , 29 ) # no type error >>> numerator ( sage_rational2 ) 3 numerary also defines: 1 2 3 4 5 6 7 8 SupportsNumeratorDenominatorMixedU = Union [ SupportsNumeratorDenominatorProperties , SupportsNumeratorDenominatorMethods , ] SupportsNumeratorDenominatorMixedT = ( SupportsNumeratorDenominatorProperties , SupportsNumeratorDenominatorMethods , ) 1 2 3 4 5 6 7 8 >>> from numerary.types import SupportsNumeratorDenominatorMixedU , numerator >>> chimera_rational : SupportsNumeratorDenominatorMixedU >>> chimera_rational = Fraction ( 29 , 3 ) # no type error >>> numerator ( chimera_rational ) 29 >>> chimera_rational = SageLikeRational ( 3 , 29 ) # still no type error >>> numerator ( chimera_rational ) 3 The SupportsNumeratorDenominator* primitives provide the basis for analogous numerary.types.RationalLike* primitives , which should provide sufficient (if idiosyncratic) coverage for dealing with (seemingly mis-appropriately named) rationals. Pass-through caching with composition implementation is pretty sketchy This is really getting into where the sausage is made. However, in the spirit of full transparency, this must be disclosed. Let\u2019s say we register an errant implementation as non-compliant. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> from numerary.types import SupportsFloat >>> class FloatImposter : ... def __float__ ( self ) -> float : ... raise NotImplementedError ( \"Haha! JK! @#$% you!\" ) ... def __int__ ( self ) -> int : ... return 42 >>> float_imp = FloatImposter () >>> isinstance ( float_imp , SupportsFloat ) True >>> SupportsFloat . excludes ( FloatImposter ) >>> isinstance ( float_imp , SupportsFloat ) False For composition to be ergonomic, this registration should be indelible, survive composition, but allow overriding by inheritors. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 >>> from numerary.types import ( ... CachingProtocolMeta , Protocol , runtime_checkable , ... SupportsInt , ... ) >>> @runtime_checkable ... class MyFloatInt ( ... SupportsFloat , SupportsInt , ... Protocol , metaclass = CachingProtocolMeta , ... ): pass >>> isinstance ( float_imp , MyFloatInt ) # picks up excludes override from SupportsFloat False >>> SupportsFloat . reset_for ( FloatImposter ) >>> isinstance ( float_imp , SupportsFloat ) True >>> isinstance ( float_imp , MyFloatInt ) # picks up resetting of SupportsFloat override True >>> MyFloatInt . excludes ( FloatImposter ) # overrides in composition >>> isinstance ( float_imp , MyFloatInt ) False >>> SupportsFloat . includes ( FloatImposter ) >>> isinstance ( float_imp , FloatImposter ) True >>> isinstance ( float_imp , MyFloatInt ) # overrides/resets in member protocols are hidden False >>> MyFloatInt . reset_for ( FloatImposter ) # removes override in composition >>> isinstance ( float_imp , MyFloatInt ) # member protocol is visible again True >>> SupportsFloat . excludes ( FloatImposter ) >>> isinstance ( float_imp , MyFloatInt ) False For this to work under the current implementation, we cannot rely exclusively on the standard library\u2019s implementation of __instancecheck__ , since it flattens and inspects all properties (with some proprietary exceptions) of all classes in order of the MRO, not just the current instance. In lay terms, this means that an ancestor\u2019s __instancecheck__ cache is effectively hidden from its progeny. Without intervention, that would require one to register exceptions with every inheritor, which would suck. Overriding the behavior is problematic, because the standard library uses a non-public function called _get_protocol_attrs to perform its attribute enumeration. CachingProtocolMeta tries to work around this by importing _get_protocol_attrs and performing some set arithmetic to limit its evaluation to directly defined attributes, and then delegate isinstance evaluation to its __base__ classes. In doing so, it picks up its bases\u2019 then-cached values, but at the cost of re-implementing the attribute check as well as taking a dependency on an implementation detail of the standard library, which creates a fragility. Further, for post-inheritance updates, CachingProtocolMeta implements a simplistic publish/subscribe mechanism that dirties non-overridden caches in inheritors when member protocols caches are updated. These are deliberate compromises. (See the implementation for details.) One subtlety is that the implementation deviates from performing checks in MRO order (and may perform redundant checks). This is probably fine as long as runtime comparisons remain limited to crude checks whether attributes merely exist. It would likely fail if runtime checking becomes more sophisticated, at which time, this implementation will need to be revisited. Hopefully by then, we can just delete numerary as the aspirationally unnecessary hack it is and move on with our lives. License numerary is licensed under the MIT License . See the included LICENSE file for details. Source code is available on GitHub . Installation Installation can be performed via PyPI . 1 2 % pip install numerary ... Alternately, you can download the source and install manually. 1 2 3 4 5 % git clone https://github.com/posita/numerary.git ... % cd numerary % python -m pip install . # -or- python -c 'from setuptools import setup ; setup()' install . ... Requirements numerary requires a relatively modern version of Python: CPython (3.7+) PyPy (CPython 3.7+ compatible) It has the following runtime dependencies: typing-extensions (with Python <3.9) numerary will opportunistically use the following, if available at runtime: beartype for yummy runtime type-checking goodness (0.8+) If you use beartype for type-checking your code that interacts with numerary , but don\u2019t want numerary to use it internally (e.g., for some strange reason), set the NUMERARY_BEARTYPE environment variable to a falsy 4 value before numerary is loaded. See the hacking quick-start for additional development and testing dependencies. Customers dyce - a pure-Python library for modeling arbitrarily complex dice mechanics and mother birthing code base of numerary ! The next one could be you ! \ud83d\udc4b Do you have a project that suffers problems made slightly less annoying by numerary ? Let me know , and I\u2019ll promote it here! And don\u2019t forget to do your part in perpetuating gratuitous badge-ification! 1 2 3 4 <!-- Markdown --> As of version 0.4.1, ``dyce`` is [ ![numerary-encumbered ]( https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg )][numerary-encumbered]! [ numerary-encumbered ]: https://posita.github.io/numerary/ \"numerary-encumbered\" 1 2 3 4 5 6 7 8 9 .. reStructuredText - see https://docutils.sourceforge.io/docs/ref/rst/directives.html#image As of version 0.4.1, ``dyce`` is |numerary-encumbered|! .. |numerary-encumbered| image :: https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg :align: top :target: https://posita.github.io/numerary/ :alt: numerary-encumbered 1 2 3 4 5 <!-- HTML --> As of version 0.4.1, < code > dyce </ code > is < a href = \"https://posita.github.io/numerary/\" >< img src = \"https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg\" alt = \"numerary-encumbered\" style = \"vertical-align: middle;\" ></ a > ! You know, super weird, off-the-wall shit, like members of the numeric tower , or standard library primitives that remain non -members for some \ud83e\udd2ced up reason , or legitimate non-members because they predate PEP 3141 and conforming would amount to breaking changes , or\u2014I don\u2019t know\u2014oodles of libraries and applications that have been around for literally decades that bring huge value to vast scientific and mathematic audiences, but whose number primitives break type-checking if one abides by the ubiquitous bum steer, \u201cI don\u2019t have any experience trying to do what you\u2019re doing, but just use float , bro.\u201d Because, hey, \ud83e\udd2c numbers! Am I right? \u21a9 I acknowledge that the subject of who is awesomer, beartype or the man who made it, is hotly contested . \u21a9 I say may because I don\u2019t really understand how Sage\u2019s number registrations work. \u21a9 I.E., one of: 0 , off , f , false , and no . \u21a9","title":"Introduction"},{"location":"#numerarynow-with-protocol-powertm","text":"That\u2019s right! For a hopefully limited time, you too can benefit from someone else\u2019s deranged work-arounds for the enormous chasms in Python that lie between the esoteric fields of computation that are \u201ctyping\u201d and \u201cnumbers\u201d instead of having to roll your own out of sheer desperation from first principles ! If you still have no idea what I\u2019m talking about, this may help illustrate . numerary is a pure-Python codified rant for signaling that your interface is usable with non-native numeric primitives 1 without breaking type-checking. More simply, numerary aspires to a world where numbers and types can work together. If you\u2019re thinking that you shouldn\u2019t need a \ud83e\udd2cing library for that, you\u2019re right . This madness should enjoy no audience. It should not exist. Yet here we are. Its author gauges its success by how quickly it can be forgotten, relegated to the annals of superfluous folly. numerary is licensed under the MIT License . See the accompanying LICENSE file for details. It should be considered experimental for now, but should settle down quickly. See the release notes for a summary of version-to-version changes. Source code is available on GitHub . If you find it lacking in any way, please don\u2019t hesitate to bring it to my attention .","title":"numerary\u2014Now with Protocol Power\u2122"},{"location":"#you-had-me-at-numbers-and-types-can-work-together","text":"numerary strives to define composable, efficient protocols that one can use to construct numeric requirements. If all you deal with are integrals and reals, and what you want is broad arithmetic operator compatibility, this will probably get you where you likely want to go: 1 2 3 4 5 >>> from numerary import IntegralLike , RealLike >>> def deeper_thot ( arg : RealLike ) -> IntegralLike : ... assert arg != 0 and arg ** 0 == 1 ... return arg // arg + 42 Beyond default compositions for common use cases, numerary expands on the Supports pattern used in the standard library. For example, numerary.types.SupportsIntegralOps is a @typing.runtime_checkable protocol that approximates the unary and binary operators introduced by numbers.Integral . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from numerary.types import SupportsIntegralOps >>> def shift_right_one ( arg : SupportsIntegralOps ) -> SupportsIntegralOps : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg >> 1 >>> shift_right_one ( 2 ) 1 >>> from sympy import sympify >>> two = sympify ( \"2\" ) ; type ( two ) < class ' sympy . core . numbers . Integer '> >>> res = shift_right_one ( two ) ; res 1 >>> type ( res ) < class ' sympy . core . numbers . One '> >>> from fractions import Fraction >>> shift_right_one ( Fraction ( 1 , 2 )) # type: ignore [arg-type] # properly caught by Mypy Traceback ( most recent call last ): ... AssertionError Note Until 1.9, sympy.core.numbers.Integer lacked the requisite bitwise operators . numerary catches that! The above properly results in both a type-checking error as well as a runtime failure for SymPy versions prior to 1.9. numerary \u2019s Supports protocols can be composed to refine requirements. For example, let\u2019s say one wanted to ensure type compatibility with primitives that support both __abs__ and __divmod__ . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 >>> from typing import TypeVar >>> T_co = TypeVar ( \"T_co\" , covariant = True ) >>> from numerary.types import ( ... CachingProtocolMeta , Protocol , runtime_checkable , ... SupportsAbs , SupportsDivmod , ... ) >>> @runtime_checkable ... class MyType ( ... SupportsAbs [ T_co ], SupportsDivmod [ T_co ], ... Protocol , metaclass = CachingProtocolMeta , ... ): pass >>> my_type : MyType >>> my_type = 3.5 >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) 3.5 >>> divmod ( my_type , 2 ) ( 1.0 , 1.5 ) >>> from fractions import Fraction >>> my_type = Fraction ( 22 , 7 ) >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) Fraction ( 22 , 7 ) >>> divmod ( my_type , 2 ) ( 1 , Fraction ( 8 , 7 )) >>> from decimal import Decimal >>> my_type = Decimal ( \"5.2\" ) >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) Decimal ( '5.2' ) >>> divmod ( my_type , 2 ) ( Decimal ( '2' ), Decimal ( '1.2' )) >>> my_type = \"nope\" # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( my_type , MyType ) False Remember that scandal where complex defined exception-throwing comparators it wasn\u2019t supposed to have, which confused runtime protocol checking, and then its type definitions lied about it to cover it up ? Yeah, that shit ends here . 1 2 3 4 5 6 >>> from numerary.types import SupportsRealOps >>> isinstance ( 1.0 , SupportsRealOps ) # all good True >>> has_real_ops : SupportsRealOps = complex ( 1 ) # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( complex ( 1 ), SupportsRealOps ) # you're not fooling anyone, buddy False That is because numerary not only caches runtime protocol evaluations, but allows overriding those evaluations when the default machinery gets it wrong. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 >>> from abc import abstractmethod >>> from typing import Iterable , Union >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsOne ( Protocol , metaclass = CachingProtocolMeta ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @abstractmethod ... def one ( self ) -> int : pass >>> class Imposter : ... def one ( self ) -> str : ... return \"one\" >>> imp : SupportsOne = Imposter () # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( imp , SupportsOne ) # fool me once, shame on you ... True >>> SupportsOne . excludes ( Imposter ) >>> isinstance ( imp , SupportsOne ) # ... can't get fooled again False numerary has default overrides to correct for known oddities with native types (like our old friend, complex ) and with popular libraries like numpy and sympy . Others will be added as they are identified. If I\u2019ve missed any, or if you would like numerary to support additional number implementations out of the box, please let me know .","title":"You had me at, \u201cnumbers and types can work together\u201d"},{"location":"#performance-enhanced-protocolsa-different-kind-of-pep-for-your-step","text":"By default, protocols frustrate runtime type-checking performance . A lot. numerary applies two distinct, layered optimization strategies: Cached __instancecheck__ results for numerary -defined protocols; and Optional(-ish) short-circuit type enumerations.","title":"Performance Enhanced Protocols\u2014A different kind of \u201cPEP\u201d for your step"},{"location":"#cached-__instancecheck__-results","text":"To understand why numerary protocols are faster for runtime checks, it helps to understand why non- numerary protocols are so slow. At runtime (i.e., via isinstance ), the default Protocol implementation delegates to _ProtocolMeta.__instancecheck__ to perform a crude comparison of an instance\u2019s callable attributes against the protocol\u2019s. More attributes means more comparisons. Further, it performs these comparisons \u2026 Every. Single. \ud83e\udd2cing. Time. Protocols provided by numerary use instead CachingProtocolMeta as their meta class. CachingProtocolMeta derives from _ProtocolMeta and overrides __instancecheck__ to cache the default implementation\u2019s results based on instance type. Conceptually: 1 2 3 4 5 6 7 8 >>> isinstance ( 1 , SupportsIntegralOps ) # first check for an int is delegated to _ProtcolMeta.__instancecheck__ True >>> isinstance ( 2 , SupportsIntegralOps ) # cached result True >>> isinstance ( 1.0 , SupportsIntegralOps ) # the first check for a float is delegated to _ProtcolMeta.__instancecheck__ False >>> isinstance ( 2.0 , SupportsIntegralOps ) # cached result False These offer significant performance improvements, especially where protocols define many methods. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 % timeit isinstance ( builtins . int ( 1 ), _SupportsComplexOps ) 11.8 \u00b5s \u00b1 314 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( builtins . int ( 1 ), SupportsComplexOps ) 307 ns \u00b1 2.97 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( builtins . float ( 2.0 ), _SupportsComplexOps ) 11.6 \u00b5s \u00b1 104 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( builtins . float ( 2.0 ), SupportsComplexOps ) 312 ns \u00b1 6.29 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( decimal . Decimal ( 3 ), _SupportsComplexOps ) 11.7 \u00b5s \u00b1 68.1 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( decimal . Decimal ( 3 ), SupportsComplexOps ) 306 ns \u00b1 3.7 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( fractions . Fraction ( 4 ), _SupportsComplexOps ) 11.7 \u00b5s \u00b1 100 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( fractions . Fraction ( 4 ), SupportsComplexOps ) 308 ns \u00b1 4.24 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( sympy . core . numbers . Integer ( 5 ), _SupportsComplexOps ) 11.9 \u00b5s \u00b1 251 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( sympy . core . numbers . Integer ( 5 ), SupportsComplexOps ) 306 ns \u00b1 1.5 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) Source: perf_supports_complex.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from decimal import Decimal from fractions import Fraction from numerary.types import _SupportsComplexOps # non-caching version from numerary.types import SupportsComplexOps # CachingProtocolMeta version import sympy one_int = 1 two_float = 2.0 three_dec = Decimal ( 3 ) four_frac = Fraction ( 4 ) five_sym = sympy . sympify ( 5 ) vals = ( one_int , two_float , three_dec , four_frac , five_sym ) for v in vals : for t in ( _SupportsComplexOps , SupportsComplexOps , ): print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) print ()","title":"Cached __instancecheck__ results"},{"location":"#short-circuit-type-enumerations","text":"If the interface is to be used most often with native types ( int s, float s, bool s), an additional optimization may be had at runtime by short-circuiting protocol type-checking. \u2026SCU objects provide Union s for compliant types. As one example, for the aforementioned SupportsIntegralOps , numerary defines an additional interface. 1 SupportsIntegralOpsSCU = Union [ int , bool , Integral , SupportsIntegralOps ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> from numerary.types import SupportsIntegralOpsSCU >>> def shift_left_one ( arg : SupportsIntegralOpsSCU ) -> SupportsIntegralOpsSCU : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg << 1 >>> shift_left_one ( 1 ) 2 >>> shift_left_one ( sympify ( \"1\" )) 2 >>> shift_left_one ( Fraction ( 1 , 2 )) # type: ignore [arg-type] Traceback ( most recent call last ): ... AssertionError Where do \u2026SCU protocols help? In a word, beartype . beartype is awesome . Its author is even awesomer . 2 More generally, runtime checkers that inspect and enforce annotations may benefit from short-circuiting where protocol validation is expensive. Union s are also useful when trying to accommodate non-compliant primitives that fail static type-checking, but will work anyway at runtime. float s in Python versions prior to 3.9 are an excellent example, because they officially lacked __floor__ and __ceil__ methods, but were registered with the numeric tower and worked just fine with math.floor and math.ceil . How do numerary \u2019s SupportsFloor and SupportsCeil deal with this situation? Not super well on their own, unfortunately. 1 2 3 4 5 6 7 8 9 >>> import math >>> from numerary.types import SupportsFloor >>> def my_dumb_floor_func ( arg : SupportsFloor ) -> int : ... assert isinstance ( arg , SupportsFloor ) # will work, even for floats, thanks to default overrides ... return math . floor ( arg ) # type: ignore [arg-type] # doesn't understand SupportsFloor >>> my_dumb_floor_func ( float ( 1.2 )) # type: ignore [arg-type] # still results in a Mypy error for Python version <3.9 1 Union s allow a work-around for the static type-checking issue. 1 2 3 4 5 6 7 8 9 10 11 >>> from numerary.types import SupportsFloor , SupportsFloorSCU , floor >>> SupportsFloorSCU # float is included here typing . Union [ int , float , bool , numbers . Real , numerary . types . SupportsFloor ] >>> import sys >>> def my_floor_func ( arg : SupportsFloorSCU ) -> int : ... assert isinstance ( arg , SupportsFloor ) ... return floor ( arg ) >>> my_floor_func ( float ( 1.2 )) # works in 3.7+ 1 This is largely a contrived example, since math.floor and math.ceil happily accept SupportsFloat , but it is useful for illustration.","title":"Short-circuit type enumerations"},{"location":"#limitations","text":"There are some downsides, though. (Aren\u2019t there always?)","title":"Limitations"},{"location":"#sometimes-protocols-are-too-trusting","text":"Protocols trust numeric tower registrations. TODO(@posita): Is this really true? But sometimes, out there in the real world, implementations lie . Consider: 1 2 3 4 5 6 7 8 9 10 11 >>> from numbers import Integral >>> hasattr ( Integral , \"real\" ) and hasattr ( Integral , \"imag\" ) True >>> import sympy.core.numbers >>> pants_on_fire = sympy . core . numbers . Integer ( 1 ) >>> isinstance ( pants_on_fire , Integral ) True >>> hasattr ( pants_on_fire , \"real\" ) or hasattr ( pants_on_fire , \"imag\" ) # somebody's tellin' stories False >>> from numerary.types import SupportsRealImag >>> real_imag : SupportsRealImag = pants_on_fire # fails to detect the lie","title":"Sometimes protocols are too trusting"},{"location":"#protocols-loses-fidelity-during-runtime-checking","text":"At runtime, protocols match names , not signatures . For example, SupportsNumeratorDenominatorProperties \u2019s numerator and denominator properties will match sage.rings.integer.Integer \u2019s similarly named functions . In other words, isinstance(sage_integer, SupportsNumeratorDenominatorProperties) will return True . Further, if the short-circuiting approach is used, because sage.rings.integer.Integer registers itself with the numeric tower, this may 3 not be caught by Mypy. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 >>> class SageLikeRational : ... def __init__ ( self , numerator : int , denominator : int = 1 ): ... self . _numerator = numerator ... self . _denominator = denominator ... def numerator ( self ) -> int : ... return self . _numerator ... def denominator ( self ) -> int : ... return self . _denominator >>> from numerary.types import SupportsNumeratorDenominatorProperties >>> frac : SupportsNumeratorDenominatorProperties = Fraction ( 29 , 3 ) # no typing error >>> sage_rational1 : SupportsNumeratorDenominatorProperties = SageLikeRational ( 29 , 3 ) # type: ignore [assignment] # Mypy catches this >>> isinstance ( sage_rational1 , SupportsNumeratorDenominatorProperties ) # isinstance does not True >>> sage_rational1 . numerator <... method ... numerator ...> >>> frac . numerator 29 Known warts could be cured by cache overriding as discussed above. However, to combat this particular situation, numerary provides an alternative: the SupportsNumeratorDenominatorMethods protocol and the numerator and denominator helper functions. These allow accommodation of rational implementations like Sage\u2019s that are mostly compliant with the exception of their respective numerator and denominator implementations. 1 2 3 4 5 6 7 8 9 10 >>> from numerary.types import numerator >>> numerator ( sage_rational1 ) 29 >>> numerator ( frac ) 29 >>> from numerary.types import SupportsNumeratorDenominatorMethods , numerator >>> sage_rational2 : SupportsNumeratorDenominatorMethods = SageLikeRational ( 3 , 29 ) # no type error >>> numerator ( sage_rational2 ) 3 numerary also defines: 1 2 3 4 5 6 7 8 SupportsNumeratorDenominatorMixedU = Union [ SupportsNumeratorDenominatorProperties , SupportsNumeratorDenominatorMethods , ] SupportsNumeratorDenominatorMixedT = ( SupportsNumeratorDenominatorProperties , SupportsNumeratorDenominatorMethods , ) 1 2 3 4 5 6 7 8 >>> from numerary.types import SupportsNumeratorDenominatorMixedU , numerator >>> chimera_rational : SupportsNumeratorDenominatorMixedU >>> chimera_rational = Fraction ( 29 , 3 ) # no type error >>> numerator ( chimera_rational ) 29 >>> chimera_rational = SageLikeRational ( 3 , 29 ) # still no type error >>> numerator ( chimera_rational ) 3 The SupportsNumeratorDenominator* primitives provide the basis for analogous numerary.types.RationalLike* primitives , which should provide sufficient (if idiosyncratic) coverage for dealing with (seemingly mis-appropriately named) rationals.","title":"Protocols loses fidelity during runtime checking"},{"location":"#pass-through-caching-with-composition-implementation-is-pretty-sketchy","text":"This is really getting into where the sausage is made. However, in the spirit of full transparency, this must be disclosed. Let\u2019s say we register an errant implementation as non-compliant. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> from numerary.types import SupportsFloat >>> class FloatImposter : ... def __float__ ( self ) -> float : ... raise NotImplementedError ( \"Haha! JK! @#$% you!\" ) ... def __int__ ( self ) -> int : ... return 42 >>> float_imp = FloatImposter () >>> isinstance ( float_imp , SupportsFloat ) True >>> SupportsFloat . excludes ( FloatImposter ) >>> isinstance ( float_imp , SupportsFloat ) False For composition to be ergonomic, this registration should be indelible, survive composition, but allow overriding by inheritors. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 >>> from numerary.types import ( ... CachingProtocolMeta , Protocol , runtime_checkable , ... SupportsInt , ... ) >>> @runtime_checkable ... class MyFloatInt ( ... SupportsFloat , SupportsInt , ... Protocol , metaclass = CachingProtocolMeta , ... ): pass >>> isinstance ( float_imp , MyFloatInt ) # picks up excludes override from SupportsFloat False >>> SupportsFloat . reset_for ( FloatImposter ) >>> isinstance ( float_imp , SupportsFloat ) True >>> isinstance ( float_imp , MyFloatInt ) # picks up resetting of SupportsFloat override True >>> MyFloatInt . excludes ( FloatImposter ) # overrides in composition >>> isinstance ( float_imp , MyFloatInt ) False >>> SupportsFloat . includes ( FloatImposter ) >>> isinstance ( float_imp , FloatImposter ) True >>> isinstance ( float_imp , MyFloatInt ) # overrides/resets in member protocols are hidden False >>> MyFloatInt . reset_for ( FloatImposter ) # removes override in composition >>> isinstance ( float_imp , MyFloatInt ) # member protocol is visible again True >>> SupportsFloat . excludes ( FloatImposter ) >>> isinstance ( float_imp , MyFloatInt ) False For this to work under the current implementation, we cannot rely exclusively on the standard library\u2019s implementation of __instancecheck__ , since it flattens and inspects all properties (with some proprietary exceptions) of all classes in order of the MRO, not just the current instance. In lay terms, this means that an ancestor\u2019s __instancecheck__ cache is effectively hidden from its progeny. Without intervention, that would require one to register exceptions with every inheritor, which would suck. Overriding the behavior is problematic, because the standard library uses a non-public function called _get_protocol_attrs to perform its attribute enumeration. CachingProtocolMeta tries to work around this by importing _get_protocol_attrs and performing some set arithmetic to limit its evaluation to directly defined attributes, and then delegate isinstance evaluation to its __base__ classes. In doing so, it picks up its bases\u2019 then-cached values, but at the cost of re-implementing the attribute check as well as taking a dependency on an implementation detail of the standard library, which creates a fragility. Further, for post-inheritance updates, CachingProtocolMeta implements a simplistic publish/subscribe mechanism that dirties non-overridden caches in inheritors when member protocols caches are updated. These are deliberate compromises. (See the implementation for details.) One subtlety is that the implementation deviates from performing checks in MRO order (and may perform redundant checks). This is probably fine as long as runtime comparisons remain limited to crude checks whether attributes merely exist. It would likely fail if runtime checking becomes more sophisticated, at which time, this implementation will need to be revisited. Hopefully by then, we can just delete numerary as the aspirationally unnecessary hack it is and move on with our lives.","title":"Pass-through caching with composition implementation is pretty sketchy"},{"location":"#license","text":"numerary is licensed under the MIT License . See the included LICENSE file for details. Source code is available on GitHub .","title":"License"},{"location":"#installation","text":"Installation can be performed via PyPI . 1 2 % pip install numerary ... Alternately, you can download the source and install manually. 1 2 3 4 5 % git clone https://github.com/posita/numerary.git ... % cd numerary % python -m pip install . # -or- python -c 'from setuptools import setup ; setup()' install . ...","title":"Installation"},{"location":"#requirements","text":"numerary requires a relatively modern version of Python: CPython (3.7+) PyPy (CPython 3.7+ compatible) It has the following runtime dependencies: typing-extensions (with Python <3.9) numerary will opportunistically use the following, if available at runtime: beartype for yummy runtime type-checking goodness (0.8+) If you use beartype for type-checking your code that interacts with numerary , but don\u2019t want numerary to use it internally (e.g., for some strange reason), set the NUMERARY_BEARTYPE environment variable to a falsy 4 value before numerary is loaded. See the hacking quick-start for additional development and testing dependencies.","title":"Requirements"},{"location":"#customers","text":"dyce - a pure-Python library for modeling arbitrarily complex dice mechanics and mother birthing code base of numerary ! The next one could be you ! \ud83d\udc4b Do you have a project that suffers problems made slightly less annoying by numerary ? Let me know , and I\u2019ll promote it here! And don\u2019t forget to do your part in perpetuating gratuitous badge-ification! 1 2 3 4 <!-- Markdown --> As of version 0.4.1, ``dyce`` is [ ![numerary-encumbered ]( https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg )][numerary-encumbered]! [ numerary-encumbered ]: https://posita.github.io/numerary/ \"numerary-encumbered\" 1 2 3 4 5 6 7 8 9 .. reStructuredText - see https://docutils.sourceforge.io/docs/ref/rst/directives.html#image As of version 0.4.1, ``dyce`` is |numerary-encumbered|! .. |numerary-encumbered| image :: https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg :align: top :target: https://posita.github.io/numerary/ :alt: numerary-encumbered 1 2 3 4 5 <!-- HTML --> As of version 0.4.1, < code > dyce </ code > is < a href = \"https://posita.github.io/numerary/\" >< img src = \"https://raw.githubusercontent.com/posita/numerary/master/docs/numerary-encumbered.svg\" alt = \"numerary-encumbered\" style = \"vertical-align: middle;\" ></ a > ! You know, super weird, off-the-wall shit, like members of the numeric tower , or standard library primitives that remain non -members for some \ud83e\udd2ced up reason , or legitimate non-members because they predate PEP 3141 and conforming would amount to breaking changes , or\u2014I don\u2019t know\u2014oodles of libraries and applications that have been around for literally decades that bring huge value to vast scientific and mathematic audiences, but whose number primitives break type-checking if one abides by the ubiquitous bum steer, \u201cI don\u2019t have any experience trying to do what you\u2019re doing, but just use float , bro.\u201d Because, hey, \ud83e\udd2c numbers! Am I right? \u21a9 I acknowledge that the subject of who is awesomer, beartype or the man who made it, is hotly contested . \u21a9 I say may because I don\u2019t really understand how Sage\u2019s number registrations work. \u21a9 I.E., one of: 0 , off , f , false , and no . \u21a9","title":"Customers"},{"location":"contrib/","text":"Contributing to numerary There are many ways you can contribute. You have only but to try. Filing issues You can file new issues as you find them. Please try to avoid duplicating issues. \u201cWriting Effective Bug Reports\u201d by Elisabeth Hendrickson (PDF) may be helpful. Hacking quick-start An easy way to bootstrap an isolated development environment is: 1 2 3 4 5 6 7 8 9 10 % git clone --recurse-submodules https://github.com/posita/numerary.git \u2026 % cd numerary % /path/to/python -m venv .venv \u2026 % . .venv/bin/activate % pip install --upgrade --editable '.[dev]' \u2026 % python -m pre_commit install \u2026 Substitute your preferred virtual environment process for venv . The [dev] variant includes additional dependencies necessary for development and testing. See the [options.extras_require] section in setup.cfg . Unit tests are run with pytest via Tox . 1 2 3 4 % cd \u2026/path/to/numerary % . .venv/bin/activate % tox [ TOX_ARGS... [ -- PYTEST_ARGS... ]] \u2026 Submission guidelines If you are willing and able, consider submitting a pull request with a fix. See the docs if you\u2019re not already familiar with pull requests. numerary releases from master (although not always immediately), so a lot of these workflows are helpful. There are only a few additional guidelines: If it is not already present, please add your name (and optionally your email, GitHub username, website address, or other contact information) to the LICENSE file. 1 2 3 ... * [ Matt Bogosian ]( mailto:matt@bogosian.net?Subject=numerary ); GitHub \u2013 [ **@posita** ](https://github.com/posita) ... Use Black to format your changes. Do your best to follow the source conventions as you observe them. If it\u2019s important to you, Existing comments are wrapped at 88 characters per line to match Black\u2019s default. (Don\u2019t spend too much effort on strict conformance, though. I can clean things up later if they really bother me.) Provide tests where feasible and appropriate. At the very least, existing tests should not fail. (There are exceptions, but if there is any doubt, they probably do not apply.) Unit tests live in tests . If you want feedback on a work-in-progress, consider \u201cmentioning\u201d me ( @posita ), and describe specifically how I can help. Consider prefixing your pull request\u2019s title with something like, \u201c NEED FEEDBACK \u2013 \u201d. If your pull request is still in progress, but you are not blocked on anything, consider using the draft feature . Once you are ready for a merge, resolve any conflicts, squash your commits, and provide a useful commit message. ( This and this may be helpful.) If your pull request started out as a draft, promote it by requesting a review. Consider prefixing the pull request\u2019s title to something like, \u201c READY FOR MERGE \u2013 \u201d. I will try to get to it as soon as I can.","title":"Contributing"},{"location":"contrib/#contributing-to-numerary","text":"There are many ways you can contribute. You have only but to try.","title":"Contributing to numerary"},{"location":"contrib/#filing-issues","text":"You can file new issues as you find them. Please try to avoid duplicating issues. \u201cWriting Effective Bug Reports\u201d by Elisabeth Hendrickson (PDF) may be helpful.","title":"Filing issues"},{"location":"contrib/#hacking-quick-start","text":"An easy way to bootstrap an isolated development environment is: 1 2 3 4 5 6 7 8 9 10 % git clone --recurse-submodules https://github.com/posita/numerary.git \u2026 % cd numerary % /path/to/python -m venv .venv \u2026 % . .venv/bin/activate % pip install --upgrade --editable '.[dev]' \u2026 % python -m pre_commit install \u2026 Substitute your preferred virtual environment process for venv . The [dev] variant includes additional dependencies necessary for development and testing. See the [options.extras_require] section in setup.cfg . Unit tests are run with pytest via Tox . 1 2 3 4 % cd \u2026/path/to/numerary % . .venv/bin/activate % tox [ TOX_ARGS... [ -- PYTEST_ARGS... ]] \u2026","title":"Hacking quick-start"},{"location":"contrib/#submission-guidelines","text":"If you are willing and able, consider submitting a pull request with a fix. See the docs if you\u2019re not already familiar with pull requests. numerary releases from master (although not always immediately), so a lot of these workflows are helpful. There are only a few additional guidelines: If it is not already present, please add your name (and optionally your email, GitHub username, website address, or other contact information) to the LICENSE file. 1 2 3 ... * [ Matt Bogosian ]( mailto:matt@bogosian.net?Subject=numerary ); GitHub \u2013 [ **@posita** ](https://github.com/posita) ... Use Black to format your changes. Do your best to follow the source conventions as you observe them. If it\u2019s important to you, Existing comments are wrapped at 88 characters per line to match Black\u2019s default. (Don\u2019t spend too much effort on strict conformance, though. I can clean things up later if they really bother me.) Provide tests where feasible and appropriate. At the very least, existing tests should not fail. (There are exceptions, but if there is any doubt, they probably do not apply.) Unit tests live in tests . If you want feedback on a work-in-progress, consider \u201cmentioning\u201d me ( @posita ), and describe specifically how I can help. Consider prefixing your pull request\u2019s title with something like, \u201c NEED FEEDBACK \u2013 \u201d. If your pull request is still in progress, but you are not blocked on anything, consider using the draft feature . Once you are ready for a merge, resolve any conflicts, squash your commits, and provide a useful commit message. ( This and this may be helpful.) If your pull request started out as a draft, promote it by requesting a review. Consider prefixing the pull request\u2019s title to something like, \u201c READY FOR MERGE \u2013 \u201d. I will try to get to it as soon as I can.","title":"Submission guidelines"},{"location":"license/","text":"License and credits The MIT License (MIT) Copyright \u00a9 2015-2021 Matt Bogosian ( @posita ). Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Contributors The following individuals or entities have contributed to this software: Matt Bogosian ; GitHub \u2013 @posita By adding your name to this list, you grant a nonexclusive, perpetual license to your contributions to this software under the same terms as its license, above. Further, you warrant that your contributions to this software are exclusively your own creations and no one else has any superior right or claim to them. Finally, you agree to indemnify and hold harmless this software\u2019s owner against any colorable claim of infringement by a third party for this software\u2019s owner\u2019s otherwise lawful use of your contribution, whether or not such use was contemplated by you at the time you made it.","title":"License"},{"location":"license/#license-and-credits","text":"","title":"License and credits"},{"location":"license/#the-mit-license-mit","text":"Copyright \u00a9 2015-2021 Matt Bogosian ( @posita ). Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License (MIT)"},{"location":"license/#contributors","text":"The following individuals or entities have contributed to this software: Matt Bogosian ; GitHub \u2013 @posita By adding your name to this list, you grant a nonexclusive, perpetual license to your contributions to this software under the same terms as its license, above. Further, you warrant that your contributions to this software are exclusively your own creations and no one else has any superior right or claim to them. Finally, you agree to indemnify and hold harmless this software\u2019s owner against any colorable claim of infringement by a third party for this software\u2019s owner\u2019s otherwise lawful use of your contribution, whether or not such use was contemplated by you at the time you made it.","title":"Contributors"},{"location":"notes/","text":"numerary release notes 0.0.6 Adds CachingProtocolMeta.includes , CachingProtocolMeta.excludes , and CachingProtocolMeta.reset_for cache override functions. Retires \u2026SCT tuples as unnecessary, especially in light of cache overrides. (Runtime isinstance protocol checking is fast enough.) For limited backward compatibility, they are now merely type aliases for similarly named protocols and will be removed in the next version. Updates docs. Custom runtime comparison implementation allows composition to lean on base types\u2019 caches. (\u26a0\ufe0f WARNING: Severe jank alert! \u26a0\ufe0f) 0.0.5 Updates license to the MIT License . Gets rid of self redundancy in __isinstance__ checks. 0.0.4 numerary finally leaves the dyce nest to become its own library! It didn\u2019t quite leave before because its maintainer is a bonehead who doesn\u2019t understand setuptools\u2019 multitude of oh-so-simple packaging mechanisms. No, it stuck around most weekends to do laundry while eating all of dyce \u2019s food. Now it has officially left the nest.","title":"Release notes"},{"location":"notes/#numerary-release-notes","text":"","title":"numerary release notes"},{"location":"notes/#006","text":"Adds CachingProtocolMeta.includes , CachingProtocolMeta.excludes , and CachingProtocolMeta.reset_for cache override functions. Retires \u2026SCT tuples as unnecessary, especially in light of cache overrides. (Runtime isinstance protocol checking is fast enough.) For limited backward compatibility, they are now merely type aliases for similarly named protocols and will be removed in the next version. Updates docs. Custom runtime comparison implementation allows composition to lean on base types\u2019 caches. (\u26a0\ufe0f WARNING: Severe jank alert! \u26a0\ufe0f)","title":"0.0.6"},{"location":"notes/#005","text":"Updates license to the MIT License . Gets rid of self redundancy in __isinstance__ checks.","title":"0.0.5"},{"location":"notes/#004","text":"numerary finally leaves the dyce nest to become its own library! It didn\u2019t quite leave before because its maintainer is a bonehead who doesn\u2019t understand setuptools\u2019 multitude of oh-so-simple packaging mechanisms. No, it stuck around most weekends to do laundry while eating all of dyce \u2019s food. Now it has officially left the nest.","title":"0.0.4"},{"location":"numerary/","text":"numerary package reference Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. These are composition protocols that should suit common use cases. IntegralLike ( SupportsAbs , SupportsFloat , SupportsIndex , SupportsInt , SupportsIntegralOps , SupportsIntegralPow , SupportsRealOps , SupportsComplexOps , Protocol ) A caching ABC that defines a core set of operations for interacting with integrals. It is a composition of: SupportsAbs SupportsFloat SupportsIndex SupportsInt SupportsIntegralOps SupportsIntegralPow SupportsRealOps SupportsComplexOps This is a practically useful, but incomplete list. To enforce equivalence to numbers . Integral , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloor SupportsCeil SupportsDivmod SupportsNumeratorDenominatorProperties RealLike ( SupportsAbs , SupportsFloat , SupportsRealOps , SupportsComplexOps , SupportsComplexPow , Protocol ) A caching ABC that defines a core set of operations for interacting with reals. It is a composition of: SupportsAbs SupportsFloat SupportsRealOps SupportsComplexOps SupportsComplexPow This is a practically useful, but incomplete list. To enforce equivalence to numbers . Real , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloor SupportsCeil SupportsDivmod","title":"<tt>numerary</tt>"},{"location":"numerary/#numerary-package-reference","text":"Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. These are composition protocols that should suit common use cases.","title":"numerary package reference"},{"location":"numerary/#numerary.types.IntegralLike","text":"A caching ABC that defines a core set of operations for interacting with integrals. It is a composition of: SupportsAbs SupportsFloat SupportsIndex SupportsInt SupportsIntegralOps SupportsIntegralPow SupportsRealOps SupportsComplexOps This is a practically useful, but incomplete list. To enforce equivalence to numbers . Integral , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloor SupportsCeil SupportsDivmod SupportsNumeratorDenominatorProperties","title":"IntegralLike"},{"location":"numerary/#numerary.types.RealLike","text":"A caching ABC that defines a core set of operations for interacting with reals. It is a composition of: SupportsAbs SupportsFloat SupportsRealOps SupportsComplexOps SupportsComplexPow This is a practically useful, but incomplete list. To enforce equivalence to numbers . Real , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloor SupportsCeil SupportsDivmod","title":"RealLike"},{"location":"numerary.types/","text":"numerary . types package reference Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. In addition to the following protocols and helper functions, numerary.types also resolves importing Annotated , Protocol , and runtime_checkable from the best available source. This can be helpful if you need to support Python versions prior to 3.9, but don\u2019t want to take a runtime dependency on typing_extensions unless needed. Instead of doing this all over the place \u2026 1 2 3 4 try : from typing import Annotated , Protocol , runtime_checkable except ImportError : from typing_extensions import Annotated , Protocol , runtime_checkable \u2026 you can do this instead \u2026 1 from numerary.types import Annotated , Protocol , runtime_checkable Bang. Done. Further, if you want to opportunistically take advantage of beartype without imposing a strict runtime dependency, you can do this: 1 from numerary.bt import beartype # will resolve to the identity decorator if beartype is unavailable at runtime CachingProtocolMeta ( _ProtocolMeta ) Stand-in for Protocol \u2019s base class that caches results of __instancecheck__ , (which is otherwise really \ud83e\udd2cing expensive ). (When this was introduced, it resulted in about a 5\u00d7 performance increase for dyce \u2019s unit tests, which was the only benchmark I had at the time.) The downside is that this will yield unpredictable results for objects whose methods don\u2019t stem from any type (e.g., are assembled at runtime). I don\u2019t know of any real-world case where that would be true. We\u2019ll jump off that bridge when we come to it. __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any ) -> _TT special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in numerary/types.py def __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any , ) -> _TT : # See <https://github.com/python/mypy/issues/9282> cls = super () . __new__ ( mcls , name , bases , namespace , ** kw ) # type: ignore [misc] # Prefixing this class member with \"_abc_\" is necessary to prevent it from being # considered part of the Protocol. (See # <https://github.com/python/cpython/blob/main/Lib/typing.py>.) cache : Dict [ Type , bool ] = {} cls . _abc_inst_check_cache = cache overridden : Dict [ Type , bool ] = {} cls . _abc_inst_check_cache_overridden = overridden listeners : Set [ CachingProtocolMeta ] = set () cls . _abc_inst_check_cache_listeners = listeners for base in bases : if hasattr ( base , \"_abc_inst_check_cache_listeners\" ): base . _abc_inst_check_cache_listeners . add ( cls ) return cls excludes ( cls , inst_t : Type ) -> None Registers inst_t as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsHam ( ... Protocol , ... metaclass = CachingProtocolMeta ... ): ... @abstractmethod ... def ham ( self ) -> str : pass >>> class NoHam : ... def ham ( self ) -> str : ... raise NotImplementedError >>> isinstance ( NoHam (), SupportsHam ) True >>> SupportsHam . excludes ( NoHam ) >>> isinstance ( NoHam (), SupportsHam ) False Note This does not affect static type-checking. 1 >>> my_ham : SupportsHam = NoHam () # does *not* generate a Mypy warning Source code in numerary/types.py def excludes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsHam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def ham(self) -> str: pass >>> class NoHam: ... def ham(self) -> str: ... raise NotImplementedError >>> isinstance(NoHam(), SupportsHam) True >>> SupportsHam.excludes(NoHam) >>> isinstance(NoHam(), SupportsHam) False ``` !!! note This does not affect static type-checking. ``` python >>> my_ham: SupportsHam = NoHam() # does *not* generate a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = False cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t ) includes ( cls , inst_t : Type ) -> None Registers inst_t as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsSpam ( ... Protocol , ... metaclass = CachingProtocolMeta ... ): ... @abstractmethod ... def spam ( self ) -> str : pass >>> class NoSpam : pass >>> isinstance ( NoSpam (), SupportsSpam ) False >>> SupportsSpam . includes ( NoSpam ) >>> isinstance ( NoSpam (), SupportsSpam ) True Note This does not affect static type-checking. 1 >>> my_spam : SupportsSpam = NoSpam () # type: ignore [assignment] # still generates a Mypy warning Source code in numerary/types.py def includes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsSpam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def spam(self) -> str: pass >>> class NoSpam: pass >>> isinstance(NoSpam(), SupportsSpam) False >>> SupportsSpam.includes(NoSpam) >>> isinstance(NoSpam(), SupportsSpam) True ``` !!! note This does not affect static type-checking. ``` python >>> my_spam: SupportsSpam = NoSpam() # type: ignore [assignment] # still generates a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = True cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t ) reset_for ( cls , inst_t : Type ) -> None Clears any cached instance check for inst_t . Source code in numerary/types.py def reset_for ( cls , inst_t : Type ) -> None : r \"\"\" Clears any cached instance check for *inst_t*. \"\"\" if inst_t in cls . _abc_inst_check_cache : del cls . _abc_inst_check_cache [ inst_t ] del cls . _abc_inst_check_cache_overridden [ inst_t ] cls . _dirty_for ( inst_t ) RationalLikeMethods ( SupportsAbs , SupportsFloat , SupportsNumeratorDenominatorMethods , SupportsRealOps , SupportsComplexOps , SupportsComplexPow , Protocol ) A caching ABC that defines a core set of operations for interacting with rationals. It is identical to RationalLikeProperties with one important exception. Instead of SupportsNumeratorDenominatorProperties , this protocol provides SupportsNumeratorDenominatorMethods . This is probably not very useful on its own, but is important to the construction of RationalLikeMixedU and RationalLikeMixedT . 1 2 RationalLikeMixedU = typing . Union [ numerary . types . RationalLikeProperties , numerary . types . RationalLikeMethods ] RationalLikeMixedT = ( RationalLikeProperties , RationalLikeMethods ) RationalLikeProperties ( SupportsAbs , SupportsFloat , SupportsNumeratorDenominatorProperties , SupportsRealOps , SupportsComplexOps , SupportsComplexPow , Protocol ) A caching ABC that defines a core set of operations for interacting with rationals. It is a composition of: SupportsAbs SupportsFloat SupportsNumeratorDenominatorProperties SupportsRealOps SupportsComplexOps SupportsComplexPow This is a practically useful, but incomplete list. To enforce equivalence to numbers . Rational , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloor SupportsCeil SupportsDivmod SupportsAbs ( SupportsAbs , Protocol ) A caching version of the typing . SupportsAbs ABC defining the __abs__ method with a covariant return value. SupportsCeil ( _SupportsCeil , Protocol ) A caching ABC defining the __ceil__ method . ( _SupportsCeil is the raw, non-caching version that defines the actual methods.) See also the ceil helper function . Note This is of limited value for Python versions prior to 3.9, since float . __ceil__ was not defined. If support for those environments is important, consider using SupportsFloat instead, since that is what math . ceil expects. SupportsComplex ( SupportsComplex , Protocol ) A caching version of the typing . SupportsComplex ABC defining the __complex__ method . SupportsComplexOps ( _SupportsComplexOps , Protocol ) A caching ABC defining the Complex operator methods with covariant return values. ( _SupportsComplexOps is the raw, non-caching version that defines the actual methods.) SupportsComplexPow ( _SupportsComplexPow , Protocol ) A caching ABC defining the Complex (i.e., non-modulo) versions of the __pow__ and __rpow__ , each with a covariant return value. ( _SupportsComplexPow is the raw, non-caching version that defines the actual methods.) SupportsConjugate ( _SupportsConjugate , Protocol ) A caching ABC defining the conjugate method . ( _SupportsConjugate is the raw, non-caching version that defines the actual methods.) SupportsDivmod ( _SupportsDivmod , Protocol ) A caching ABC defining the __divmod__ and __rdivmod__ methods. Each returns a 2-tuple of covariants. ( _SupportsDivmod is the raw, non-caching version that defines the actual methods.) SupportsFloat ( SupportsFloat , Protocol ) A caching version of the typing . SupportsFloat ABC defining the __float__ method . SupportsFloor ( _SupportsFloor , Protocol ) A caching ABC defining the __floor__ method . See also the floor helper function . ( _SupportsFloor is the raw, non-caching version that defines the actual methods.) Note This is of limited value for Python versions prior to 3.9, since float . __floor__ was not defined. If support for those environments is important, consider using SupportsFloat instead. SupportsIndex ( SupportsIndex , Protocol ) A caching version of the typing . SupportsIndex ABC defining the __index__ method . SupportsInt ( SupportsInt , Protocol ) A caching version of the typing . SupportsInt ABC defining the __int__ method . SupportsIntegralOps ( _SupportsIntegralOps , Protocol ) A caching ABC defining the Integral operator methods with covariant return values. ( _SupportsIntegralOps is the raw, non-caching version that defines the actual methods.) SupportsIntegralPow ( _SupportsIntegralPow , Protocol ) A caching ABC defining the Integral (i.e., modulo) versions of the __pow__ and __rpow__ , each with a covariant return value. ( _SupportsIntegralPow is the raw, non-caching version that defines the actual methods.) SupportsNumeratorDenominatorMethods ( _SupportsNumeratorDenominatorMethods , Protocol ) A caching ABC defining numerator and denominator methods. Each returns a SupportsInt . ( _SupportsNumeratorDenominatorMethods is the raw, non-caching version that defines the actual methods.) SupportsNumeratorDenominatorProperties ( _SupportsNumeratorDenominatorProperties , Protocol ) A caching ABC defining the numerator and denominator properties. ( _SupportsNumeratorDenominatorProperties is the raw, non-caching version that defines the actual properties.) SupportsRealImag ( _SupportsRealImag , Protocol ) A caching ABC defining the real and imag properties. ( _SupportsRealImag is the raw, non-caching version that defines the actual methods.) SupportsRealOps ( _SupportsRealOps , Protocol ) A caching ABC defining the Real operator methods with covariant return values. ( _SupportsRealOps is the raw, non-caching version that defines the actual methods.) SupportsRound ( SupportsRound , Protocol ) A caching version of the typing . SupportsRound ABC defining the __round__ method with a covariant return value. SupportsTrunc ( _SupportsTrunc , Protocol ) A caching ABC defining the __trunc__ method . See also the trunc helper function . ( _SupportsTrunc is the raw, non-caching version that defines the actual methods.) ceil ( operand : Union [ SupportsFloat , SupportsCeil ]) Helper function that wraps math.ceil . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsCeil , SupportsFloat , ceil >>> my_ceil : SupportsCeil >>> my_ceil = 1 >>> ceil ( my_ceil ) 1 >>> from fractions import Fraction >>> my_ceil = Fraction ( 1 , 2 ) >>> ceil ( my_ceil ) 1 >>> my_ceil_float : SupportsFloat = 1.2 >>> ceil ( my_ceil_float ) 2 Source code in numerary/types.py @beartype def ceil ( operand : Union [ SupportsFloat , SupportsCeil ]): r \"\"\" Helper function that wraps ``math.ceil``. ``` python >>> from numerary.types import SupportsCeil, SupportsFloat, ceil >>> my_ceil: SupportsCeil >>> my_ceil = 1 >>> ceil(my_ceil) 1 >>> from fractions import Fraction >>> my_ceil = Fraction(1, 2) >>> ceil(my_ceil) 1 >>> my_ceil_float: SupportsFloat = 1.2 >>> ceil(my_ceil_float) 2 ``` \"\"\" return math . ceil ( operand ) # type: ignore [arg-type] denominator ( operand : SupportsNumeratorDenominatorMixedU ) Helper function that extracts the denominator from operand including resolving non-compliant rational implementations that implement denominator as a method rather than a property. 1 2 3 4 >>> from fractions import Fraction >>> from numerary.types import denominator >>> denominator ( Fraction ( 22 , 7 )) 7 See SupportsNumeratorDenominatorProperties and SupportsNumeratorDenominatorMethods . Source code in numerary/types.py @beartype def denominator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" Helper function that extracts the denominator from *operand* including resolving non-compliant rational implementations that implement ``denominator`` as a method rather than a property. ``` python >>> from fractions import Fraction >>> from numerary.types import denominator >>> denominator(Fraction(22, 7)) 7 ``` See [SupportsNumeratorDenominatorProperties][numerary.types.SupportsNumeratorDenominatorProperties] and [SupportsNumeratorDenominatorMethods][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" if hasattr ( operand , \"denominator\" ): if callable ( operand . denominator ): return operand . denominator () else : return operand . denominator else : raise TypeError ( f \" { operand !r} has no denominator\" ) floor ( operand : Union [ SupportsFloat , SupportsFloor ]) Helper function that wraps math.floor . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsFloor , floor >>> my_floor : SupportsFloor >>> my_floor = 1 >>> floor ( my_floor ) 1 >>> from fractions import Fraction >>> my_floor = Fraction ( 1 , 2 ) >>> floor ( my_floor ) 0 >>> my_floor_float : SupportsFloat = 1.2 >>> floor ( my_floor_float ) 1 Source code in numerary/types.py @beartype def floor ( operand : Union [ SupportsFloat , SupportsFloor ]): r \"\"\" Helper function that wraps ``math.floor``. ``` python >>> from numerary.types import SupportsFloat, SupportsFloor, floor >>> my_floor: SupportsFloor >>> my_floor = 1 >>> floor(my_floor) 1 >>> from fractions import Fraction >>> my_floor = Fraction(1, 2) >>> floor(my_floor) 0 >>> my_floor_float: SupportsFloat = 1.2 >>> floor(my_floor_float) 1 ``` \"\"\" return math . floor ( operand ) # type: ignore [arg-type] numerator ( operand : SupportsNumeratorDenominatorMixedU ) Helper function that extracts the numerator from operand including resolving non-compliant rational implementations that implement numerator as a method rather than a property. 1 2 3 4 >>> from fractions import Fraction >>> from numerary.types import numerator >>> numerator ( Fraction ( 22 , 7 )) 22 See SupportsNumeratorDenominatorProperties and SupportsNumeratorDenominatorMethods . Source code in numerary/types.py @beartype def numerator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" Helper function that extracts the numerator from *operand* including resolving non-compliant rational implementations that implement ``numerator`` as a method rather than a property. ``` python >>> from fractions import Fraction >>> from numerary.types import numerator >>> numerator(Fraction(22, 7)) 22 ``` See [SupportsNumeratorDenominatorProperties][numerary.types.SupportsNumeratorDenominatorProperties] and [SupportsNumeratorDenominatorMethods][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" if hasattr ( operand , \"numerator\" ): if callable ( operand . numerator ): return operand . numerator () else : return operand . numerator else : raise TypeError ( f \" { operand !r} has no numerator\" ) trunc ( operand : Union [ SupportsFloat , SupportsTrunc ]) Helper function that wraps math.trunc . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsTrunc , trunc >>> my_trunc : SupportsTrunc >>> my_trunc = 1 >>> trunc ( my_trunc ) 1 >>> from fractions import Fraction >>> my_trunc = Fraction ( 1 , 2 ) >>> trunc ( my_trunc ) 0 >>> my_trunc_float : SupportsFloat = 1.2 >>> trunc ( my_trunc_float ) 1 Source code in numerary/types.py @beartype def trunc ( operand : Union [ SupportsFloat , SupportsTrunc ]): r \"\"\" Helper function that wraps ``math.trunc``. ``` python >>> from numerary.types import SupportsFloat, SupportsTrunc, trunc >>> my_trunc: SupportsTrunc >>> my_trunc = 1 >>> trunc(my_trunc) 1 >>> from fractions import Fraction >>> my_trunc = Fraction(1, 2) >>> trunc(my_trunc) 0 >>> my_trunc_float: SupportsFloat = 1.2 >>> trunc(my_trunc_float) 1 ``` \"\"\" return math . trunc ( operand ) # type: ignore [arg-type] RationalLikeMixedT RationalLikeMixedU SupportsNumeratorDenominatorMixedT SupportsNumeratorDenominatorMixedU _SupportsCeil ( Protocol ) private The raw, non-caching version of SupportsCeil . __slots__ : Union [ str , Iterable [ str ]] special __ceil__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __ceil__ ( self ) -> int : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True _SupportsComplexOps ( Protocol ) private The raw, non-caching version of SupportsComplexOps . __slots__ : Union [ str , Iterable [ str ]] special __add__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __add__ ( self , other : Any ) -> _T_co : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __mul__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __mul__ ( self , other : Any ) -> _T_co : pass __neg__ ( self ) -> _T_co special Source code in numerary/types.py @abstractmethod def __neg__ ( self ) -> _T_co : pass __pos__ ( self ) -> _T_co special Source code in numerary/types.py @abstractmethod def __pos__ ( self ) -> _T_co : pass __radd__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __radd__ ( self , other : Any ) -> _T_co : pass __rmul__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rmul__ ( self , other : Any ) -> _T_co : pass __rsub__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rsub__ ( self , other : Any ) -> _T_co : pass __rtruediv__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rtruediv__ ( self , other : Any ) -> _T_co : pass __sub__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __sub__ ( self , other : Any ) -> _T_co : pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True __truediv__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __truediv__ ( self , other : Any ) -> _T_co : pass _SupportsComplexPow ( Protocol ) private The raw, non-caching version of SupportsComplexPow . __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __pow__ ( self , exponent : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any ) -> _T_co : pass __rpow__ ( self , exponent : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any ) -> _T_co : pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True _SupportsConjugate ( Protocol ) private The raw, non-caching version of SupportsConjugate . __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True conjugate ( self ) -> Any Source code in numerary/types.py @abstractmethod def conjugate ( self ) -> Any : pass _SupportsDivmod ( Protocol ) private The raw, non-caching version of SupportsDivmod . __slots__ : Union [ str , Iterable [ str ]] special __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ] special Source code in numerary/types.py @abstractmethod def __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ] special Source code in numerary/types.py @abstractmethod def __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True _SupportsFloor ( Protocol ) private The raw, non-caching version of SupportsFloor . __slots__ : Union [ str , Iterable [ str ]] special __floor__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __floor__ ( self ) -> int : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True _SupportsIntegralOps ( Protocol ) private The raw, non-caching version of SupportsIntegralOps . __slots__ : Union [ str , Iterable [ str ]] special __and__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __and__ ( self , other : Any ) -> _T_co : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __invert__ ( self ) -> _T_co special Source code in numerary/types.py @abstractmethod def __invert__ ( self ) -> _T_co : pass __lshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __lshift__ ( self , other : Any ) -> _T_co : pass __or__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __or__ ( self , other : Any ) -> _T_co : pass __rand__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rand__ ( self , other : Any ) -> _T_co : pass __rlshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rlshift__ ( self , other : Any ) -> _T_co : pass __ror__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __ror__ ( self , other : Any ) -> _T_co : pass __rrshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rrshift__ ( self , other : Any ) -> _T_co : pass __rshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rshift__ ( self , other : Any ) -> _T_co : pass __rxor__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rxor__ ( self , other : Any ) -> _T_co : pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True __xor__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __xor__ ( self , other : Any ) -> _T_co : pass _SupportsIntegralPow ( Protocol ) private The raw, non-caching version of SupportsIntegralPow . __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co special Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co : pass __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co : pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True _SupportsNumeratorDenominatorMethods ( Protocol ) private The raw, non-caching version of SupportsNumeratorDenominatorMethods . __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True denominator ( self ) -> SupportsInt Source code in numerary/types.py @abstractmethod def denominator ( self ) -> SupportsInt : pass numerator ( self ) -> SupportsInt Source code in numerary/types.py @abstractmethod def numerator ( self ) -> SupportsInt : pass _SupportsNumeratorDenominatorProperties ( Protocol ) private The raw, non-caching version of SupportsNumeratorDenominatorProperties . __slots__ : Union [ str , Iterable [ str ]] special denominator : int property readonly numerator : int property readonly __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True _SupportsRealImag ( Protocol ) private The raw, non-caching version of SupportsRealImag . __slots__ : Union [ str , Iterable [ str ]] special imag : Any property readonly real : Any property readonly __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True _SupportsRealOps ( Protocol ) private The raw, non-caching version of SupportsRealOps . __slots__ : Union [ str , Iterable [ str ]] special __floordiv__ ( self , other : Any ) -> Any special Source code in numerary/types.py @abstractmethod def __floordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass __ge__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __ge__ ( self , other : Any ) -> bool : pass __gt__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __gt__ ( self , other : Any ) -> bool : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __le__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __le__ ( self , other : Any ) -> bool : pass __lt__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __lt__ ( self , other : Any ) -> bool : pass __mod__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __mod__ ( self , other : Any ) -> _T_co : pass __rfloordiv__ ( self , other : Any ) -> Any special Source code in numerary/types.py @abstractmethod def __rfloordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass __rmod__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rmod__ ( self , other : Any ) -> _T_co : pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True _SupportsTrunc ( Protocol ) private The raw, non-caching version of SupportsTrunc . __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True __trunc__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __trunc__ ( self ) -> int : pass","title":"<tt>numerary.types</tt>"},{"location":"numerary.types/#numerarytypes-package-reference","text":"Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. In addition to the following protocols and helper functions, numerary.types also resolves importing Annotated , Protocol , and runtime_checkable from the best available source. This can be helpful if you need to support Python versions prior to 3.9, but don\u2019t want to take a runtime dependency on typing_extensions unless needed. Instead of doing this all over the place \u2026 1 2 3 4 try : from typing import Annotated , Protocol , runtime_checkable except ImportError : from typing_extensions import Annotated , Protocol , runtime_checkable \u2026 you can do this instead \u2026 1 from numerary.types import Annotated , Protocol , runtime_checkable Bang. Done. Further, if you want to opportunistically take advantage of beartype without imposing a strict runtime dependency, you can do this: 1 from numerary.bt import beartype # will resolve to the identity decorator if beartype is unavailable at runtime","title":"numerary.types package reference"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta","text":"Stand-in for Protocol \u2019s base class that caches results of __instancecheck__ , (which is otherwise really \ud83e\udd2cing expensive ). (When this was introduced, it resulted in about a 5\u00d7 performance increase for dyce \u2019s unit tests, which was the only benchmark I had at the time.) The downside is that this will yield unpredictable results for objects whose methods don\u2019t stem from any type (e.g., are assembled at runtime). I don\u2019t know of any real-world case where that would be true. We\u2019ll jump off that bridge when we come to it.","title":"CachingProtocolMeta"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in numerary/types.py def __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any , ) -> _TT : # See <https://github.com/python/mypy/issues/9282> cls = super () . __new__ ( mcls , name , bases , namespace , ** kw ) # type: ignore [misc] # Prefixing this class member with \"_abc_\" is necessary to prevent it from being # considered part of the Protocol. (See # <https://github.com/python/cpython/blob/main/Lib/typing.py>.) cache : Dict [ Type , bool ] = {} cls . _abc_inst_check_cache = cache overridden : Dict [ Type , bool ] = {} cls . _abc_inst_check_cache_overridden = overridden listeners : Set [ CachingProtocolMeta ] = set () cls . _abc_inst_check_cache_listeners = listeners for base in bases : if hasattr ( base , \"_abc_inst_check_cache_listeners\" ): base . _abc_inst_check_cache_listeners . add ( cls ) return cls","title":"__new__()"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta.excludes","text":"Registers inst_t as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsHam ( ... Protocol , ... metaclass = CachingProtocolMeta ... ): ... @abstractmethod ... def ham ( self ) -> str : pass >>> class NoHam : ... def ham ( self ) -> str : ... raise NotImplementedError >>> isinstance ( NoHam (), SupportsHam ) True >>> SupportsHam . excludes ( NoHam ) >>> isinstance ( NoHam (), SupportsHam ) False Note This does not affect static type-checking. 1 >>> my_ham : SupportsHam = NoHam () # does *not* generate a Mypy warning Source code in numerary/types.py def excludes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsHam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def ham(self) -> str: pass >>> class NoHam: ... def ham(self) -> str: ... raise NotImplementedError >>> isinstance(NoHam(), SupportsHam) True >>> SupportsHam.excludes(NoHam) >>> isinstance(NoHam(), SupportsHam) False ``` !!! note This does not affect static type-checking. ``` python >>> my_ham: SupportsHam = NoHam() # does *not* generate a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = False cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t )","title":"excludes()"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta.includes","text":"Registers inst_t as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsSpam ( ... Protocol , ... metaclass = CachingProtocolMeta ... ): ... @abstractmethod ... def spam ( self ) -> str : pass >>> class NoSpam : pass >>> isinstance ( NoSpam (), SupportsSpam ) False >>> SupportsSpam . includes ( NoSpam ) >>> isinstance ( NoSpam (), SupportsSpam ) True Note This does not affect static type-checking. 1 >>> my_spam : SupportsSpam = NoSpam () # type: ignore [assignment] # still generates a Mypy warning Source code in numerary/types.py def includes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsSpam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def spam(self) -> str: pass >>> class NoSpam: pass >>> isinstance(NoSpam(), SupportsSpam) False >>> SupportsSpam.includes(NoSpam) >>> isinstance(NoSpam(), SupportsSpam) True ``` !!! note This does not affect static type-checking. ``` python >>> my_spam: SupportsSpam = NoSpam() # type: ignore [assignment] # still generates a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = True cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t )","title":"includes()"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta.reset_for","text":"Clears any cached instance check for inst_t . Source code in numerary/types.py def reset_for ( cls , inst_t : Type ) -> None : r \"\"\" Clears any cached instance check for *inst_t*. \"\"\" if inst_t in cls . _abc_inst_check_cache : del cls . _abc_inst_check_cache [ inst_t ] del cls . _abc_inst_check_cache_overridden [ inst_t ] cls . _dirty_for ( inst_t )","title":"reset_for()"},{"location":"numerary.types/#numerary.types.RationalLikeMethods","text":"A caching ABC that defines a core set of operations for interacting with rationals. It is identical to RationalLikeProperties with one important exception. Instead of SupportsNumeratorDenominatorProperties , this protocol provides SupportsNumeratorDenominatorMethods . This is probably not very useful on its own, but is important to the construction of RationalLikeMixedU and RationalLikeMixedT . 1 2 RationalLikeMixedU = typing . Union [ numerary . types . RationalLikeProperties , numerary . types . RationalLikeMethods ] RationalLikeMixedT = ( RationalLikeProperties , RationalLikeMethods )","title":"RationalLikeMethods"},{"location":"numerary.types/#numerary.types.RationalLikeProperties","text":"A caching ABC that defines a core set of operations for interacting with rationals. It is a composition of: SupportsAbs SupportsFloat SupportsNumeratorDenominatorProperties SupportsRealOps SupportsComplexOps SupportsComplexPow This is a practically useful, but incomplete list. To enforce equivalence to numbers . Rational , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloor SupportsCeil SupportsDivmod","title":"RationalLikeProperties"},{"location":"numerary.types/#numerary.types.SupportsAbs","text":"A caching version of the typing . SupportsAbs ABC defining the __abs__ method with a covariant return value.","title":"SupportsAbs"},{"location":"numerary.types/#numerary.types.SupportsCeil","text":"A caching ABC defining the __ceil__ method . ( _SupportsCeil is the raw, non-caching version that defines the actual methods.) See also the ceil helper function . Note This is of limited value for Python versions prior to 3.9, since float . __ceil__ was not defined. If support for those environments is important, consider using SupportsFloat instead, since that is what math . ceil expects.","title":"SupportsCeil"},{"location":"numerary.types/#numerary.types.SupportsComplex","text":"A caching version of the typing . SupportsComplex ABC defining the __complex__ method .","title":"SupportsComplex"},{"location":"numerary.types/#numerary.types.SupportsComplexOps","text":"A caching ABC defining the Complex operator methods with covariant return values. ( _SupportsComplexOps is the raw, non-caching version that defines the actual methods.)","title":"SupportsComplexOps"},{"location":"numerary.types/#numerary.types.SupportsComplexPow","text":"A caching ABC defining the Complex (i.e., non-modulo) versions of the __pow__ and __rpow__ , each with a covariant return value. ( _SupportsComplexPow is the raw, non-caching version that defines the actual methods.)","title":"SupportsComplexPow"},{"location":"numerary.types/#numerary.types.SupportsConjugate","text":"A caching ABC defining the conjugate method . ( _SupportsConjugate is the raw, non-caching version that defines the actual methods.)","title":"SupportsConjugate"},{"location":"numerary.types/#numerary.types.SupportsDivmod","text":"A caching ABC defining the __divmod__ and __rdivmod__ methods. Each returns a 2-tuple of covariants. ( _SupportsDivmod is the raw, non-caching version that defines the actual methods.)","title":"SupportsDivmod"},{"location":"numerary.types/#numerary.types.SupportsFloat","text":"A caching version of the typing . SupportsFloat ABC defining the __float__ method .","title":"SupportsFloat"},{"location":"numerary.types/#numerary.types.SupportsFloor","text":"A caching ABC defining the __floor__ method . See also the floor helper function . ( _SupportsFloor is the raw, non-caching version that defines the actual methods.) Note This is of limited value for Python versions prior to 3.9, since float . __floor__ was not defined. If support for those environments is important, consider using SupportsFloat instead.","title":"SupportsFloor"},{"location":"numerary.types/#numerary.types.SupportsIndex","text":"A caching version of the typing . SupportsIndex ABC defining the __index__ method .","title":"SupportsIndex"},{"location":"numerary.types/#numerary.types.SupportsInt","text":"A caching version of the typing . SupportsInt ABC defining the __int__ method .","title":"SupportsInt"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps","text":"A caching ABC defining the Integral operator methods with covariant return values. ( _SupportsIntegralOps is the raw, non-caching version that defines the actual methods.)","title":"SupportsIntegralOps"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow","text":"A caching ABC defining the Integral (i.e., modulo) versions of the __pow__ and __rpow__ , each with a covariant return value. ( _SupportsIntegralPow is the raw, non-caching version that defines the actual methods.)","title":"SupportsIntegralPow"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMethods","text":"A caching ABC defining numerator and denominator methods. Each returns a SupportsInt . ( _SupportsNumeratorDenominatorMethods is the raw, non-caching version that defines the actual methods.)","title":"SupportsNumeratorDenominatorMethods"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorProperties","text":"A caching ABC defining the numerator and denominator properties. ( _SupportsNumeratorDenominatorProperties is the raw, non-caching version that defines the actual properties.)","title":"SupportsNumeratorDenominatorProperties"},{"location":"numerary.types/#numerary.types.SupportsRealImag","text":"A caching ABC defining the real and imag properties. ( _SupportsRealImag is the raw, non-caching version that defines the actual methods.)","title":"SupportsRealImag"},{"location":"numerary.types/#numerary.types.SupportsRealOps","text":"A caching ABC defining the Real operator methods with covariant return values. ( _SupportsRealOps is the raw, non-caching version that defines the actual methods.)","title":"SupportsRealOps"},{"location":"numerary.types/#numerary.types.SupportsRound","text":"A caching version of the typing . SupportsRound ABC defining the __round__ method with a covariant return value.","title":"SupportsRound"},{"location":"numerary.types/#numerary.types.SupportsTrunc","text":"A caching ABC defining the __trunc__ method . See also the trunc helper function . ( _SupportsTrunc is the raw, non-caching version that defines the actual methods.)","title":"SupportsTrunc"},{"location":"numerary.types/#numerary.types.ceil","text":"Helper function that wraps math.ceil . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsCeil , SupportsFloat , ceil >>> my_ceil : SupportsCeil >>> my_ceil = 1 >>> ceil ( my_ceil ) 1 >>> from fractions import Fraction >>> my_ceil = Fraction ( 1 , 2 ) >>> ceil ( my_ceil ) 1 >>> my_ceil_float : SupportsFloat = 1.2 >>> ceil ( my_ceil_float ) 2 Source code in numerary/types.py @beartype def ceil ( operand : Union [ SupportsFloat , SupportsCeil ]): r \"\"\" Helper function that wraps ``math.ceil``. ``` python >>> from numerary.types import SupportsCeil, SupportsFloat, ceil >>> my_ceil: SupportsCeil >>> my_ceil = 1 >>> ceil(my_ceil) 1 >>> from fractions import Fraction >>> my_ceil = Fraction(1, 2) >>> ceil(my_ceil) 1 >>> my_ceil_float: SupportsFloat = 1.2 >>> ceil(my_ceil_float) 2 ``` \"\"\" return math . ceil ( operand ) # type: ignore [arg-type]","title":"ceil()"},{"location":"numerary.types/#numerary.types.denominator","text":"Helper function that extracts the denominator from operand including resolving non-compliant rational implementations that implement denominator as a method rather than a property. 1 2 3 4 >>> from fractions import Fraction >>> from numerary.types import denominator >>> denominator ( Fraction ( 22 , 7 )) 7 See SupportsNumeratorDenominatorProperties and SupportsNumeratorDenominatorMethods . Source code in numerary/types.py @beartype def denominator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" Helper function that extracts the denominator from *operand* including resolving non-compliant rational implementations that implement ``denominator`` as a method rather than a property. ``` python >>> from fractions import Fraction >>> from numerary.types import denominator >>> denominator(Fraction(22, 7)) 7 ``` See [SupportsNumeratorDenominatorProperties][numerary.types.SupportsNumeratorDenominatorProperties] and [SupportsNumeratorDenominatorMethods][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" if hasattr ( operand , \"denominator\" ): if callable ( operand . denominator ): return operand . denominator () else : return operand . denominator else : raise TypeError ( f \" { operand !r} has no denominator\" )","title":"denominator()"},{"location":"numerary.types/#numerary.types.floor","text":"Helper function that wraps math.floor . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsFloor , floor >>> my_floor : SupportsFloor >>> my_floor = 1 >>> floor ( my_floor ) 1 >>> from fractions import Fraction >>> my_floor = Fraction ( 1 , 2 ) >>> floor ( my_floor ) 0 >>> my_floor_float : SupportsFloat = 1.2 >>> floor ( my_floor_float ) 1 Source code in numerary/types.py @beartype def floor ( operand : Union [ SupportsFloat , SupportsFloor ]): r \"\"\" Helper function that wraps ``math.floor``. ``` python >>> from numerary.types import SupportsFloat, SupportsFloor, floor >>> my_floor: SupportsFloor >>> my_floor = 1 >>> floor(my_floor) 1 >>> from fractions import Fraction >>> my_floor = Fraction(1, 2) >>> floor(my_floor) 0 >>> my_floor_float: SupportsFloat = 1.2 >>> floor(my_floor_float) 1 ``` \"\"\" return math . floor ( operand ) # type: ignore [arg-type]","title":"floor()"},{"location":"numerary.types/#numerary.types.numerator","text":"Helper function that extracts the numerator from operand including resolving non-compliant rational implementations that implement numerator as a method rather than a property. 1 2 3 4 >>> from fractions import Fraction >>> from numerary.types import numerator >>> numerator ( Fraction ( 22 , 7 )) 22 See SupportsNumeratorDenominatorProperties and SupportsNumeratorDenominatorMethods . Source code in numerary/types.py @beartype def numerator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" Helper function that extracts the numerator from *operand* including resolving non-compliant rational implementations that implement ``numerator`` as a method rather than a property. ``` python >>> from fractions import Fraction >>> from numerary.types import numerator >>> numerator(Fraction(22, 7)) 22 ``` See [SupportsNumeratorDenominatorProperties][numerary.types.SupportsNumeratorDenominatorProperties] and [SupportsNumeratorDenominatorMethods][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" if hasattr ( operand , \"numerator\" ): if callable ( operand . numerator ): return operand . numerator () else : return operand . numerator else : raise TypeError ( f \" { operand !r} has no numerator\" )","title":"numerator()"},{"location":"numerary.types/#numerary.types.trunc","text":"Helper function that wraps math.trunc . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsTrunc , trunc >>> my_trunc : SupportsTrunc >>> my_trunc = 1 >>> trunc ( my_trunc ) 1 >>> from fractions import Fraction >>> my_trunc = Fraction ( 1 , 2 ) >>> trunc ( my_trunc ) 0 >>> my_trunc_float : SupportsFloat = 1.2 >>> trunc ( my_trunc_float ) 1 Source code in numerary/types.py @beartype def trunc ( operand : Union [ SupportsFloat , SupportsTrunc ]): r \"\"\" Helper function that wraps ``math.trunc``. ``` python >>> from numerary.types import SupportsFloat, SupportsTrunc, trunc >>> my_trunc: SupportsTrunc >>> my_trunc = 1 >>> trunc(my_trunc) 1 >>> from fractions import Fraction >>> my_trunc = Fraction(1, 2) >>> trunc(my_trunc) 0 >>> my_trunc_float: SupportsFloat = 1.2 >>> trunc(my_trunc_float) 1 ``` \"\"\" return math . trunc ( operand ) # type: ignore [arg-type]","title":"trunc()"},{"location":"numerary.types/#numerary.types.RationalLikeMixedT","text":"","title":"RationalLikeMixedT"},{"location":"numerary.types/#numerary.types.RationalLikeMixedU","text":"","title":"RationalLikeMixedU"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMixedT","text":"","title":"SupportsNumeratorDenominatorMixedT"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMixedU","text":"","title":"SupportsNumeratorDenominatorMixedU"},{"location":"numerary.types/#numerary.types._SupportsCeil","text":"The raw, non-caching version of SupportsCeil .","title":"_SupportsCeil"},{"location":"numerary.types/#numerary.types._SupportsCeil.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsCeil.__ceil__","text":"Source code in numerary/types.py @abstractmethod def __ceil__ ( self ) -> int : pass","title":"__ceil__()"},{"location":"numerary.types/#numerary.types._SupportsCeil.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsCeil.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps","text":"The raw, non-caching version of SupportsComplexOps .","title":"_SupportsComplexOps"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__add__","text":"Source code in numerary/types.py @abstractmethod def __add__ ( self , other : Any ) -> _T_co : pass","title":"__add__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__mul__","text":"Source code in numerary/types.py @abstractmethod def __mul__ ( self , other : Any ) -> _T_co : pass","title":"__mul__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__neg__","text":"Source code in numerary/types.py @abstractmethod def __neg__ ( self ) -> _T_co : pass","title":"__neg__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__pos__","text":"Source code in numerary/types.py @abstractmethod def __pos__ ( self ) -> _T_co : pass","title":"__pos__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__radd__","text":"Source code in numerary/types.py @abstractmethod def __radd__ ( self , other : Any ) -> _T_co : pass","title":"__radd__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__rmul__","text":"Source code in numerary/types.py @abstractmethod def __rmul__ ( self , other : Any ) -> _T_co : pass","title":"__rmul__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__rsub__","text":"Source code in numerary/types.py @abstractmethod def __rsub__ ( self , other : Any ) -> _T_co : pass","title":"__rsub__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__rtruediv__","text":"Source code in numerary/types.py @abstractmethod def __rtruediv__ ( self , other : Any ) -> _T_co : pass","title":"__rtruediv__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__sub__","text":"Source code in numerary/types.py @abstractmethod def __sub__ ( self , other : Any ) -> _T_co : pass","title":"__sub__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__truediv__","text":"Source code in numerary/types.py @abstractmethod def __truediv__ ( self , other : Any ) -> _T_co : pass","title":"__truediv__()"},{"location":"numerary.types/#numerary.types._SupportsComplexPow","text":"The raw, non-caching version of SupportsComplexPow .","title":"_SupportsComplexPow"},{"location":"numerary.types/#numerary.types._SupportsComplexPow.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsComplexPow.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsComplexPow.__pow__","text":"Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any ) -> _T_co : pass","title":"__pow__()"},{"location":"numerary.types/#numerary.types._SupportsComplexPow.__rpow__","text":"Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any ) -> _T_co : pass","title":"__rpow__()"},{"location":"numerary.types/#numerary.types._SupportsComplexPow.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsConjugate","text":"The raw, non-caching version of SupportsConjugate .","title":"_SupportsConjugate"},{"location":"numerary.types/#numerary.types._SupportsConjugate.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsConjugate.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsConjugate.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsConjugate.conjugate","text":"Source code in numerary/types.py @abstractmethod def conjugate ( self ) -> Any : pass","title":"conjugate()"},{"location":"numerary.types/#numerary.types._SupportsDivmod","text":"The raw, non-caching version of SupportsDivmod .","title":"_SupportsDivmod"},{"location":"numerary.types/#numerary.types._SupportsDivmod.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsDivmod.__divmod__","text":"Source code in numerary/types.py @abstractmethod def __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass","title":"__divmod__()"},{"location":"numerary.types/#numerary.types._SupportsDivmod.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsDivmod.__rdivmod__","text":"Source code in numerary/types.py @abstractmethod def __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass","title":"__rdivmod__()"},{"location":"numerary.types/#numerary.types._SupportsDivmod.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsFloor","text":"The raw, non-caching version of SupportsFloor .","title":"_SupportsFloor"},{"location":"numerary.types/#numerary.types._SupportsFloor.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsFloor.__floor__","text":"Source code in numerary/types.py @abstractmethod def __floor__ ( self ) -> int : pass","title":"__floor__()"},{"location":"numerary.types/#numerary.types._SupportsFloor.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsFloor.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps","text":"The raw, non-caching version of SupportsIntegralOps .","title":"_SupportsIntegralOps"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__and__","text":"Source code in numerary/types.py @abstractmethod def __and__ ( self , other : Any ) -> _T_co : pass","title":"__and__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__invert__","text":"Source code in numerary/types.py @abstractmethod def __invert__ ( self ) -> _T_co : pass","title":"__invert__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__lshift__","text":"Source code in numerary/types.py @abstractmethod def __lshift__ ( self , other : Any ) -> _T_co : pass","title":"__lshift__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__or__","text":"Source code in numerary/types.py @abstractmethod def __or__ ( self , other : Any ) -> _T_co : pass","title":"__or__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rand__","text":"Source code in numerary/types.py @abstractmethod def __rand__ ( self , other : Any ) -> _T_co : pass","title":"__rand__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rlshift__","text":"Source code in numerary/types.py @abstractmethod def __rlshift__ ( self , other : Any ) -> _T_co : pass","title":"__rlshift__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__ror__","text":"Source code in numerary/types.py @abstractmethod def __ror__ ( self , other : Any ) -> _T_co : pass","title":"__ror__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rrshift__","text":"Source code in numerary/types.py @abstractmethod def __rrshift__ ( self , other : Any ) -> _T_co : pass","title":"__rrshift__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rshift__","text":"Source code in numerary/types.py @abstractmethod def __rshift__ ( self , other : Any ) -> _T_co : pass","title":"__rshift__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rxor__","text":"Source code in numerary/types.py @abstractmethod def __rxor__ ( self , other : Any ) -> _T_co : pass","title":"__rxor__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__xor__","text":"Source code in numerary/types.py @abstractmethod def __xor__ ( self , other : Any ) -> _T_co : pass","title":"__xor__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow","text":"The raw, non-caching version of SupportsIntegralPow .","title":"_SupportsIntegralPow"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow.__pow__","text":"Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co : pass","title":"__pow__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow.__rpow__","text":"Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> _T_co : pass","title":"__rpow__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods","text":"The raw, non-caching version of SupportsNumeratorDenominatorMethods .","title":"_SupportsNumeratorDenominatorMethods"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods.denominator","text":"Source code in numerary/types.py @abstractmethod def denominator ( self ) -> SupportsInt : pass","title":"denominator()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods.numerator","text":"Source code in numerary/types.py @abstractmethod def numerator ( self ) -> SupportsInt : pass","title":"numerator()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorProperties","text":"The raw, non-caching version of SupportsNumeratorDenominatorProperties .","title":"_SupportsNumeratorDenominatorProperties"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorProperties.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorProperties.denominator","text":"","title":"denominator"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorProperties.numerator","text":"","title":"numerator"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorProperties.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorProperties.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsRealImag","text":"The raw, non-caching version of SupportsRealImag .","title":"_SupportsRealImag"},{"location":"numerary.types/#numerary.types._SupportsRealImag.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsRealImag.imag","text":"","title":"imag"},{"location":"numerary.types/#numerary.types._SupportsRealImag.real","text":"","title":"real"},{"location":"numerary.types/#numerary.types._SupportsRealImag.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsRealImag.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps","text":"The raw, non-caching version of SupportsRealOps .","title":"_SupportsRealOps"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__floordiv__","text":"Source code in numerary/types.py @abstractmethod def __floordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass","title":"__floordiv__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__ge__","text":"Source code in numerary/types.py @abstractmethod def __ge__ ( self , other : Any ) -> bool : pass","title":"__ge__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__gt__","text":"Source code in numerary/types.py @abstractmethod def __gt__ ( self , other : Any ) -> bool : pass","title":"__gt__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__le__","text":"Source code in numerary/types.py @abstractmethod def __le__ ( self , other : Any ) -> bool : pass","title":"__le__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__lt__","text":"Source code in numerary/types.py @abstractmethod def __lt__ ( self , other : Any ) -> bool : pass","title":"__lt__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__mod__","text":"Source code in numerary/types.py @abstractmethod def __mod__ ( self , other : Any ) -> _T_co : pass","title":"__mod__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__rfloordiv__","text":"Source code in numerary/types.py @abstractmethod def __rfloordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass","title":"__rfloordiv__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__rmod__","text":"Source code in numerary/types.py @abstractmethod def __rmod__ ( self , other : Any ) -> _T_co : pass","title":"__rmod__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsTrunc","text":"The raw, non-caching version of SupportsTrunc .","title":"_SupportsTrunc"},{"location":"numerary.types/#numerary.types._SupportsTrunc.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsTrunc.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsTrunc.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsTrunc.__trunc__","text":"Source code in numerary/types.py @abstractmethod def __trunc__ ( self ) -> int : pass","title":"__trunc__()"},{"location":"whytho/","text":"This story may feel familiar. If it does, you are in good company. Your pain is my pain. May it motivate us to grow and adapt. The calculation function\u2014An allegory We have a simple vision. We want to define an API that works with reals (not just float s), performs a calculation, and returns integers (not just int s). 1 2 3 4 5 >>> def deep_thought ( arg ): ... from time import sleep ... sleep ( 7_500_000 * 365.24219265 * 24 * 60 * 60 ) # doctest: +SKIP ... assert arg != 0 and arg ** 0 == 1 ... return 42 Native primitives We want to tell the world how to call it and what to expect in return, so we annotate it: 1 2 3 >>> def deep_thought_typed ( arg : float ) -> int : ... assert arg != 0 and arg ** 0 == 1 ... return 42 So simple! We\u2019re done, right? Not quite. We find that the runtime works well, but we\u2019re Mypy errors. 1 2 3 4 5 >>> deep_thought_typed ( 1.0 ) # this is fine ... 42 >>> from fractions import Fraction >>> deep_thought_typed ( Fraction ( 1 , 2 )) # type: ignore [arg-type] # ... but this fails 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_typed\" has incompatible type \"Fraction\"; expected \"float\" Numeric tower With a little research, we learn about the numeric tower [cue angelic singing] . Surely, it has the answer! Both float and Fraction are Real s. Let\u2019s test that to make sure. 1 2 3 4 5 6 7 >>> from numbers import Integral , Real >>> isinstance ( 42 , Integral ) True >>> isinstance ( 1.0 , Real ) True >>> isinstance ( Fraction ( 1 , 2 ), Real ) True Huzzah! What could be simpler? It appears a small tweak is all that is required! 1 2 3 >>> def deep_thought_towered ( arg : Real ) -> Integral : ... assert arg != 0 and arg ** 0 == 1 ... return 42 # type: ignore [return-value] # now this fails Without the # type: ignore , we get: 1 \u2026: error: Incompatible return value type (got \"int\", expected \"Integral\") Hold the phone. isinstance(42, Integral) was True , was it not? This is starting to get confusing. Erm \u2026 we mean native primitives or the numeric tower? 1 2 3 4 5 6 7 >>> from typing import Union >>> IntegralT = Union [ int , Integral ] >>> RealT = Union [ float , Real ] >>> def deep_thought_crumbling ( arg : RealT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 Well, that was odd , but such warts are a small price to pay. All is right in the world again! 1 2 3 4 5 6 7 >>> deep_thought_crumbling ( 1.0 ) 42 >>> deep_thought_crumbling ( Fraction ( 1 , 2 )) 42 >>> from decimal import Decimal >>> deep_thought_crumbling ( Decimal ( \"0.123\" )) # type: ignore [arg-type] # fail 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_crumbling\" has incompatible type \"Decimal\"; expected \"Union[float, Real]\" Native primitives, the numeric tower, or other things that define all the methods, but didn\u2019t (or couldn\u2019t) register in the numeric tower for some reason Oh, come on ! 1 2 3 4 5 6 7 >>> RealAndDecimalT = Union [ float , Real , Decimal ] >>> def deep_thought_toppled ( arg : RealAndDecimalT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 >>> deep_thought_toppled ( Decimal ( \"0.123\" )) 42 \ud83e\udd2c me. If we have to engage in these kinds of gymnastics just to reach escape velocity from the standard library, how the heck are we supposed to survive contact with numeric implementations we haven\u2019t even heard of yet?! We can\u2019t enumerate them all ! For many years, the numeric tower was declared a \u201cdead end\u201d by maintainers. Unsurprisingly, many longstanding library authors didn\u2019t see much benefit to conforming to its API. Adoption has grown, but we can\u2019t rely on it. What should we rely on, then? Surely the exalted few who have steered us away from one thing are prepared to steer us toward something else, no? Sadly, the apparent attitude of many seems to be, \u201cSomething, something, protocols? Meh. I don\u2019t know. We\u2019ll figure it out later.\u201d Protocols! Can we fix this with protocols? The standard library provides some simple precedents . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore [misc] >>> from typing import Iterable , Union >>> @runtime_checkable ... class SupportsNumeratorDenominator ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @property ... def numerator ( self ) -> int : pass ... @property ... def denominator ( self ) -> int : pass >>> def require_rational ( arg : SupportsNumeratorDenominator ) -> None : ... assert isinstance ( arg , SupportsNumeratorDenominator ) >>> require_rational ( 1 ) >>> require_rational ( Fraction ( 1 , 2 )) >>> require_rational ( 1.0 ) # type: ignore [arg-type] Traceback ( most recent call last ): ... AssertionError Without the # type: ignore , we get: 1 2 3 \u2026: error: Argument 1 to \"require_rational\" has incompatible type \"float\"; expected \"SupportsNumeratorDenominator\" \u2026: note: \"float\" is missing following \"SupportsNumeratorDenominator\" protocol members: \u2026: note: denominator, numerator Oh. My. Godetia. Could this be it? Have we stumbled into the promised land? Puh \u2026 ROH \u2026 tih \u2026 caaahhhlllz \u2026 ! Let\u2019s see how they perform. First, let\u2019s get a baseline. 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), Rational ) 322 ns \u00b1 1.08 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), Rational ) 324 ns \u00b1 1.57 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), Rational ) 346 ns \u00b1 1.18 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) Source: perf_rational_baseline.ipy 1 2 3 4 5 6 7 8 9 10 11 12 from fractions import Fraction from numbers import Rational one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) t = Rational for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) Now let\u2019s compare that with our two-property protocol. 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), SupportsNumeratorDenominator ) 12.3 \u00b5s \u00b1 95.6 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), SupportsNumeratorDenominator ) 12.4 \u00b5s \u00b1 91.6 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), SupportsNumeratorDenominator ) 12.5 \u00b5s \u00b1 167 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) Source: perf_rational_protocol.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from fractions import Fraction from numbers import Rational from typing import Iterable , Protocol , Union , runtime_checkable one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) @runtime_checkable class SupportsNumeratorDenominator ( Protocol ): __slots__ : Union [ str , Iterable [ str ]] = () @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass t = SupportsNumeratorDenominator for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) That\u2019s forty times slower. \ud83d\ude36 And that\u2019s just with a two-property protocol. How much worse would it be if we had enumerated all the dunder methods? \ud83d\ude30 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), SupportsLotsOfNumberStuff ) 132 \u00b5s \u00b1 238 ns per loop ( mean \u00b1 std . dev . of 7 runs , 10000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), SupportsLotsOfNumberStuff ) 151 \u00b5s \u00b1 7.27 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 10000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), SupportsLotsOfNumberStuff ) 134 \u00b5s \u00b1 835 ns per loop ( mean \u00b1 std . dev . of 7 runs , 10000 loops each ) Source: perf_rational_big_protocol.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 from fractions import Fraction from numbers import Rational from numerary.types import ( # \"raw\" (non-caching) versions _SupportsCeil , _SupportsComplexOps , _SupportsConjugate , _SupportsFloor , _SupportsDivmod , _SupportsRealImag , _SupportsRealOps , _SupportsTrunc , ) from typing import ( Iterable , Protocol , SupportsAbs , SupportsFloat , SupportsComplex , SupportsRound , Union , runtime_checkable , ) one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) @runtime_checkable class SupportsLotsOfNumberStuff ( _SupportsRealOps , _SupportsComplexOps , _SupportsDivmod , _SupportsTrunc , _SupportsFloor , _SupportsCeil , _SupportsConjugate , _SupportsRealImag , SupportsAbs , SupportsFloat , SupportsComplex , SupportsRound , Protocol , ): __slots__ : Union [ str , Iterable [ str ]] = () @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass t = SupportsLotsOfNumberStuff for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) Over. Four. Hundred. Times. Slower. And that\u2019s not even all the methods! You know what? Never mind that. Where there\u2019s a will, there\u2019s a way. Note to self, \u201cSolve the performance problems with protocols later, but we\u2019re definitely onto something!\u201d Lies! Upon lies! Upon lies! All the way down! Let\u2019s do another one. Real numbers have comparisons that complex ones don\u2019t. That seems as good a place as any to tackle next. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore [misc] >>> from abc import abstractmethod >>> from typing import Any , Iterable , Union >>> @runtime_checkable ... class SupportsRealComparisons ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @abstractmethod ... def __lt__ ( self , other : Any ) -> bool : pass ... @abstractmethod ... def __le__ ( self , other : Any ) -> bool : pass ... @abstractmethod ... def __ge__ ( self , other : Any ) -> bool : pass ... @abstractmethod ... def __gt__ ( self , other : Any ) -> bool : pass >>> def require_real ( arg : SupportsRealComparisons ) -> None : ... assert isinstance ( arg , SupportsRealComparisons ) >>> require_real ( 1 ) >>> require_real ( Fraction ( 1 , 2 )) >>> require_real ( 1.0 ) >>> require_real ( complex ( 0 )) # type: ignore [arg-type] # should go ka-boom! Where was the ka-boom? There was supposed to be an earth-shattering ka-boom! Mypy spotted the error. Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"require_real\" has incompatible type \"complex\"; expected \"SupportsRealComparisons\" So what gives? Why does our protocol think a complex has comparisons at runtime? It\u2019s a complex number and complex numbers don\u2019t have those. The standard library says so ! 1 2 3 4 5 6 7 >>> from numbers import Complex >>> isinstance ( complex ( 0 ), Complex ) True >>> hasattr ( Complex , \"__le__\" ) True >>> complex ( 0 ) . __le__ # type: ignore [operator] <... method ... complex ...> What the shit? Do they work? 1 2 3 4 >>> complex ( 0 ) <= complex ( 0 ) # type: ignore [operator] Traceback ( most recent call last ): ... TypeError : '<=' not supported between instances of 'complex' and 'complex' Wait. Complex numbers implement comparisons in complete contradiction to the documentation just to return NotImplemented ?! \ud83e\udd2c off ! How does Mypy know? Because the type definitions for complex and Complex are lies that conveniently omit mention of those methods. Quote \u201cWhen it becomes serious, you have to lie.\u201d \u2014Jean-Claude Juncker Do you see?! Do you see now why we can\u2019t have nice things?! I mean, I get casting as a rare case, but who builds sophisticated deception tooling into the very fabric a type definition mechanism to claim that non-compliant native primitives comply? How can you trust anything anymore?! Shouldn\u2019t that be a pretty strong hint that maybe you should step back and rethink your approach? Astute readers may note beartype could help restore Truth for us. 1 2 3 4 5 6 7 8 9 10 from beartype import beartype from beartype.vale import Is from typing import Annotated SupportsRealComparisonsNotComplexLies = Annotated [ SupportsRealComparisons , Is [ lambda arg : not isinstance ( arg , complex )] ] @beartype def require_real ( arg : SupportsRealComparisonsNotComplexLies ) -> None : assert isinstance ( arg , SupportsRealComparisonsNotComplexLies ) That\u2019s because Bear is hip to the scene. Bear is down . Bear knows what\u2019s what. If you have a typing problem, if no one else can help, and if you can find them 1 , maybe you can hire the Bear-Team. I digress. What do we do?! Okay. Can we still work with any of this shit and have type-checking? Let\u2019s try. Because somebody \ud83e\udd2cing has to. That should be easy I just gave you the link . Twice . \u21a9","title":"Why would you do this?"},{"location":"whytho/#the-calculation-functionan-allegory","text":"We have a simple vision. We want to define an API that works with reals (not just float s), performs a calculation, and returns integers (not just int s). 1 2 3 4 5 >>> def deep_thought ( arg ): ... from time import sleep ... sleep ( 7_500_000 * 365.24219265 * 24 * 60 * 60 ) # doctest: +SKIP ... assert arg != 0 and arg ** 0 == 1 ... return 42","title":"The calculation function\u2014An allegory"},{"location":"whytho/#native-primitives","text":"We want to tell the world how to call it and what to expect in return, so we annotate it: 1 2 3 >>> def deep_thought_typed ( arg : float ) -> int : ... assert arg != 0 and arg ** 0 == 1 ... return 42 So simple! We\u2019re done, right? Not quite. We find that the runtime works well, but we\u2019re Mypy errors. 1 2 3 4 5 >>> deep_thought_typed ( 1.0 ) # this is fine ... 42 >>> from fractions import Fraction >>> deep_thought_typed ( Fraction ( 1 , 2 )) # type: ignore [arg-type] # ... but this fails 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_typed\" has incompatible type \"Fraction\"; expected \"float\"","title":"Native primitives"},{"location":"whytho/#numeric-tower","text":"With a little research, we learn about the numeric tower [cue angelic singing] . Surely, it has the answer! Both float and Fraction are Real s. Let\u2019s test that to make sure. 1 2 3 4 5 6 7 >>> from numbers import Integral , Real >>> isinstance ( 42 , Integral ) True >>> isinstance ( 1.0 , Real ) True >>> isinstance ( Fraction ( 1 , 2 ), Real ) True Huzzah! What could be simpler? It appears a small tweak is all that is required! 1 2 3 >>> def deep_thought_towered ( arg : Real ) -> Integral : ... assert arg != 0 and arg ** 0 == 1 ... return 42 # type: ignore [return-value] # now this fails Without the # type: ignore , we get: 1 \u2026: error: Incompatible return value type (got \"int\", expected \"Integral\") Hold the phone. isinstance(42, Integral) was True , was it not? This is starting to get confusing.","title":"Numeric tower"},{"location":"whytho/#erm-we-mean-native-primitives-or-the-numeric-tower","text":"1 2 3 4 5 6 7 >>> from typing import Union >>> IntegralT = Union [ int , Integral ] >>> RealT = Union [ float , Real ] >>> def deep_thought_crumbling ( arg : RealT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 Well, that was odd , but such warts are a small price to pay. All is right in the world again! 1 2 3 4 5 6 7 >>> deep_thought_crumbling ( 1.0 ) 42 >>> deep_thought_crumbling ( Fraction ( 1 , 2 )) 42 >>> from decimal import Decimal >>> deep_thought_crumbling ( Decimal ( \"0.123\" )) # type: ignore [arg-type] # fail 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_crumbling\" has incompatible type \"Decimal\"; expected \"Union[float, Real]\"","title":"Erm \u2026 we mean native primitives or the numeric tower?"},{"location":"whytho/#native-primitives-the-numeric-tower-or-other-things-that-define-all-the-methods-but-didnt-or-couldnt-register-in-the-numeric-tower-for-some-reason","text":"Oh, come on ! 1 2 3 4 5 6 7 >>> RealAndDecimalT = Union [ float , Real , Decimal ] >>> def deep_thought_toppled ( arg : RealAndDecimalT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 >>> deep_thought_toppled ( Decimal ( \"0.123\" )) 42 \ud83e\udd2c me. If we have to engage in these kinds of gymnastics just to reach escape velocity from the standard library, how the heck are we supposed to survive contact with numeric implementations we haven\u2019t even heard of yet?! We can\u2019t enumerate them all ! For many years, the numeric tower was declared a \u201cdead end\u201d by maintainers. Unsurprisingly, many longstanding library authors didn\u2019t see much benefit to conforming to its API. Adoption has grown, but we can\u2019t rely on it. What should we rely on, then? Surely the exalted few who have steered us away from one thing are prepared to steer us toward something else, no? Sadly, the apparent attitude of many seems to be, \u201cSomething, something, protocols? Meh. I don\u2019t know. We\u2019ll figure it out later.\u201d","title":"Native primitives, the numeric tower, or other things that define all the methods, but didn\u2019t (or couldn\u2019t) register in the numeric tower for some reason"},{"location":"whytho/#protocols","text":"Can we fix this with protocols? The standard library provides some simple precedents . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore [misc] >>> from typing import Iterable , Union >>> @runtime_checkable ... class SupportsNumeratorDenominator ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @property ... def numerator ( self ) -> int : pass ... @property ... def denominator ( self ) -> int : pass >>> def require_rational ( arg : SupportsNumeratorDenominator ) -> None : ... assert isinstance ( arg , SupportsNumeratorDenominator ) >>> require_rational ( 1 ) >>> require_rational ( Fraction ( 1 , 2 )) >>> require_rational ( 1.0 ) # type: ignore [arg-type] Traceback ( most recent call last ): ... AssertionError Without the # type: ignore , we get: 1 2 3 \u2026: error: Argument 1 to \"require_rational\" has incompatible type \"float\"; expected \"SupportsNumeratorDenominator\" \u2026: note: \"float\" is missing following \"SupportsNumeratorDenominator\" protocol members: \u2026: note: denominator, numerator Oh. My. Godetia. Could this be it? Have we stumbled into the promised land?","title":"Protocols!"},{"location":"whytho/#puh-roh-tih-caaahhhlllz","text":"Let\u2019s see how they perform. First, let\u2019s get a baseline. 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), Rational ) 322 ns \u00b1 1.08 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), Rational ) 324 ns \u00b1 1.57 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), Rational ) 346 ns \u00b1 1.18 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) Source: perf_rational_baseline.ipy 1 2 3 4 5 6 7 8 9 10 11 12 from fractions import Fraction from numbers import Rational one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) t = Rational for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) Now let\u2019s compare that with our two-property protocol. 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), SupportsNumeratorDenominator ) 12.3 \u00b5s \u00b1 95.6 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), SupportsNumeratorDenominator ) 12.4 \u00b5s \u00b1 91.6 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), SupportsNumeratorDenominator ) 12.5 \u00b5s \u00b1 167 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) Source: perf_rational_protocol.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from fractions import Fraction from numbers import Rational from typing import Iterable , Protocol , Union , runtime_checkable one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) @runtime_checkable class SupportsNumeratorDenominator ( Protocol ): __slots__ : Union [ str , Iterable [ str ]] = () @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass t = SupportsNumeratorDenominator for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) That\u2019s forty times slower. \ud83d\ude36 And that\u2019s just with a two-property protocol. How much worse would it be if we had enumerated all the dunder methods? \ud83d\ude30 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), SupportsLotsOfNumberStuff ) 132 \u00b5s \u00b1 238 ns per loop ( mean \u00b1 std . dev . of 7 runs , 10000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), SupportsLotsOfNumberStuff ) 151 \u00b5s \u00b1 7.27 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 10000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), SupportsLotsOfNumberStuff ) 134 \u00b5s \u00b1 835 ns per loop ( mean \u00b1 std . dev . of 7 runs , 10000 loops each ) Source: perf_rational_big_protocol.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 from fractions import Fraction from numbers import Rational from numerary.types import ( # \"raw\" (non-caching) versions _SupportsCeil , _SupportsComplexOps , _SupportsConjugate , _SupportsFloor , _SupportsDivmod , _SupportsRealImag , _SupportsRealOps , _SupportsTrunc , ) from typing import ( Iterable , Protocol , SupportsAbs , SupportsFloat , SupportsComplex , SupportsRound , Union , runtime_checkable , ) one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) @runtime_checkable class SupportsLotsOfNumberStuff ( _SupportsRealOps , _SupportsComplexOps , _SupportsDivmod , _SupportsTrunc , _SupportsFloor , _SupportsCeil , _SupportsConjugate , _SupportsRealImag , SupportsAbs , SupportsFloat , SupportsComplex , SupportsRound , Protocol , ): __slots__ : Union [ str , Iterable [ str ]] = () @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass t = SupportsLotsOfNumberStuff for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) Over. Four. Hundred. Times. Slower. And that\u2019s not even all the methods! You know what? Never mind that. Where there\u2019s a will, there\u2019s a way. Note to self, \u201cSolve the performance problems with protocols later, but we\u2019re definitely onto something!\u201d","title":"Puh \u2026 ROH \u2026 tih \u2026 caaahhhlllz \u2026 !"},{"location":"whytho/#lies-upon-lies-upon-lies-all-the-way-down","text":"Let\u2019s do another one. Real numbers have comparisons that complex ones don\u2019t. That seems as good a place as any to tackle next. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore [misc] >>> from abc import abstractmethod >>> from typing import Any , Iterable , Union >>> @runtime_checkable ... class SupportsRealComparisons ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @abstractmethod ... def __lt__ ( self , other : Any ) -> bool : pass ... @abstractmethod ... def __le__ ( self , other : Any ) -> bool : pass ... @abstractmethod ... def __ge__ ( self , other : Any ) -> bool : pass ... @abstractmethod ... def __gt__ ( self , other : Any ) -> bool : pass >>> def require_real ( arg : SupportsRealComparisons ) -> None : ... assert isinstance ( arg , SupportsRealComparisons ) >>> require_real ( 1 ) >>> require_real ( Fraction ( 1 , 2 )) >>> require_real ( 1.0 ) >>> require_real ( complex ( 0 )) # type: ignore [arg-type] # should go ka-boom! Where was the ka-boom? There was supposed to be an earth-shattering ka-boom! Mypy spotted the error. Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"require_real\" has incompatible type \"complex\"; expected \"SupportsRealComparisons\" So what gives? Why does our protocol think a complex has comparisons at runtime? It\u2019s a complex number and complex numbers don\u2019t have those. The standard library says so ! 1 2 3 4 5 6 7 >>> from numbers import Complex >>> isinstance ( complex ( 0 ), Complex ) True >>> hasattr ( Complex , \"__le__\" ) True >>> complex ( 0 ) . __le__ # type: ignore [operator] <... method ... complex ...> What the shit? Do they work? 1 2 3 4 >>> complex ( 0 ) <= complex ( 0 ) # type: ignore [operator] Traceback ( most recent call last ): ... TypeError : '<=' not supported between instances of 'complex' and 'complex' Wait. Complex numbers implement comparisons in complete contradiction to the documentation just to return NotImplemented ?! \ud83e\udd2c off ! How does Mypy know? Because the type definitions for complex and Complex are lies that conveniently omit mention of those methods. Quote \u201cWhen it becomes serious, you have to lie.\u201d \u2014Jean-Claude Juncker Do you see?! Do you see now why we can\u2019t have nice things?! I mean, I get casting as a rare case, but who builds sophisticated deception tooling into the very fabric a type definition mechanism to claim that non-compliant native primitives comply? How can you trust anything anymore?! Shouldn\u2019t that be a pretty strong hint that maybe you should step back and rethink your approach? Astute readers may note beartype could help restore Truth for us. 1 2 3 4 5 6 7 8 9 10 from beartype import beartype from beartype.vale import Is from typing import Annotated SupportsRealComparisonsNotComplexLies = Annotated [ SupportsRealComparisons , Is [ lambda arg : not isinstance ( arg , complex )] ] @beartype def require_real ( arg : SupportsRealComparisonsNotComplexLies ) -> None : assert isinstance ( arg , SupportsRealComparisonsNotComplexLies ) That\u2019s because Bear is hip to the scene. Bear is down . Bear knows what\u2019s what. If you have a typing problem, if no one else can help, and if you can find them 1 , maybe you can hire the Bear-Team. I digress.","title":"Lies! Upon lies! Upon lies! All the way down!"},{"location":"whytho/#what-do-we-do","text":"Okay. Can we still work with any of this shit and have type-checking? Let\u2019s try. Because somebody \ud83e\udd2cing has to. That should be easy I just gave you the link . Twice . \u21a9","title":"What do we do?!"}]}