{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Copyright and other protections apply. Please see the accompanying LICENSE file for rights and restrictions governing use of this software. All rights not expressly waived or licensed are reserved. If that file is missing or appears to be modified from its original, then please contact the author before viewing or using this software in any capacity. Are you defining a numeric interface that should work with more than just int s and float s? Are you annotating that interface for documentation and type-checking? Were you excited by PEP 3141 \u2019s glitz and gloss promising a clean, straightforward number type definition mechanism, only to learn the hard way\u2014after many hours of searching, tweaking, hacking, and testing ever more convoluted code, again and again\u2014that you could\u2019t actually make it work with Python\u2019s type-checking system? Do you now wonder whether numbers were something new to computing in general because nothing else would explain such a gaping hole in a programming language so popular with the STEM crowd that has been around since the early 1990s? Does the number 3186 haunt you in your dreams? Do you find yourself shouting to no one in particular, \u201cThere has to be a better way?\u201d Well I\u2019m here to tell you there isn\u2019t. But until there is, there\u2019s \u2026 numerary \u2014Now with Protocol Power\u2122 That\u2019s right! For a hopefully limited time, you too can benefit from someone else\u2019s deranged work-arounds for the enormous chasms in Python that lie between the esoteric fields of computation that are \u201ctyping\u201d and \u201cnumbers\u201d instead of having to roll your own out of sheer desperation from first principles ! If you still have no idea what I\u2019m talking about, this may help illustrate . numerary is a pure-Python codified rant for signaling that your interface is usable with non-native numeric primitives 1 without breaking type-checking. More simply, numerary aspires to a world where numbers and types can work together. If you\u2019re thinking that you shouldn\u2019t need a \ud83e\udd2cing library for that, you\u2019re right . This madness should enjoy no audience. It should not exist. Yet here we are. Its author gauges its success by how quickly it can be forgotten, relegated to the annals of superfluous folly. numerary is licensed under the MIT License . See the accompanying LICENSE file for details. It should be considered experimental for now, but should settle down quickly. See the release notes for a summary of version-to-version changes. Source code is available on GitHub . If you find it lacking in any way, please don\u2019t hesitate to bring it to my attention . You had me at, \u201cnumbers and types can work together\u201d numerary strives to define composable, efficient protocols that one can use to construct numeric requirements. If all you deal with are integrals and reals, and what you want is broad arithmetic operator compatibility, this will probably get you where you likely want to go: 1 2 3 4 5 >>> from numerary import IntegralLike , RealLike >>> def deeper_thot ( arg : RealLike ) -> IntegralLike : ... assert arg != 0 and arg ** 0 == 1 ... return arg // arg + 42 Beyond default compositions for common use cases, numerary expands on the Supports pattern used in the standard library. For example, numerary.types.SupportsIntegralOps is a @typing.runtime_checkable protocol that approximates the unary and binary operators introduced by numbers.Integral . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from numerary.types import SupportsIntegralOps >>> def shift_right_one ( arg : SupportsIntegralOps ) -> SupportsIntegralOps : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg >> 1 >>> shift_right_one ( 2 ) 1 >>> from sympy import sympify >>> two = sympify ( \"2\" ) ; type ( two ) < class ' sympy . core . numbers . Integer '> >>> res = shift_right_one ( two ) ; res 1 >>> type ( res ) < class ' sympy . core . numbers . One '> >>> from fractions import Fraction >>> shift_right_one ( Fraction ( 1 , 2 )) # type: ignore [arg-type] # properly caught by Mypy Traceback ( most recent call last ): ... AssertionError Note Until 1.9, sympy.Integer lacked the requisite bitwise operators . numerary catches that! The above properly results in both a type-checking error as well as a runtime failure for SymPy versions prior to 1.9. numerary \u2019s Supports protocols can be composed to refine requirements. For example, let\u2019s say one wanted to ensure type compatibility with primitives that support both __abs__ and __divmod__ . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 >>> from typing import TypeVar >>> T_co = TypeVar ( \"T_co\" , covariant = True ) >>> from numerary.types import ( ... CachingProtocolMeta , Protocol , runtime_checkable , ... SupportsAbs , SupportsDivmod , ... ) >>> @runtime_checkable ... class MyType ( ... SupportsAbs [ T_co ], SupportsDivmod [ T_co ], ... Protocol , metaclass = CachingProtocolMeta , ... ): ... pass >>> my_type : MyType >>> my_type = 3.5 >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) 3.5 >>> divmod ( my_type , 2 ) ( 1.0 , 1.5 ) >>> from fractions import Fraction >>> my_type = Fraction ( 22 , 7 ) >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) Fraction ( 22 , 7 ) >>> divmod ( my_type , 2 ) ( 1 , Fraction ( 8 , 7 )) >>> from decimal import Decimal >>> my_type = Decimal ( \"5.2\" ) >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) Decimal ( '5.2' ) >>> divmod ( my_type , 2 ) ( Decimal ( '2' ), Decimal ( '1.2' )) >>> my_type = \"nope\" # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( my_type , MyType ) False Remember that scandal where complex defined exception-throwing comparators it wasn\u2019t supposed to have, which confused runtime protocol checking, and then its type definitions lied about it to cover it up ? Yeah, that shit ends here . 1 2 3 4 5 6 >>> from numerary.types import SupportsRealOps >>> isinstance ( 1.0 , SupportsRealOps ) # all good True >>> has_real_ops : SupportsRealOps = complex ( 1 ) # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( complex ( 1 ), SupportsRealOps ) # you're not fooling anyone, buddy False numerary not only caches runtime protocol evaluations, but allows overriding those evaluations when the default machinery gets it wrong. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from abc import abstractmethod >>> from typing import Iterable , Union >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class MySupportsOne ( Protocol , metaclass = CachingProtocolMeta ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @abstractmethod ... def one ( self ) -> int : ... pass >>> class Imposter : ... def one ( self ) -> str : ... return \"one\" >>> imp : MySupportsOne = Imposter () # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( imp , MySupportsOne ) # fool me once, shame on you ... True >>> MySupportsOne . excludes ( Imposter ) >>> isinstance ( imp , MySupportsOne ) # ... can't get fooled again False numerary has default overrides to correct for known oddities with native types (like our old friend, complex ) and with popular libraries like numpy and sympy . Others will be added as they are identified. If I\u2019ve missed any, or if you would like numerary to support additional number implementations out of the box, please let me know . Performance Enhanced Protocols\u2014A different kind of \u201cPEP\u201d for your step By default, protocols frustrate runtime type-checking performance . A lot. numerary applies two distinct, layered optimization strategies: Cached __instancecheck__ results for numerary -defined protocols; and Optional(-ish) short-circuit type enumerations. Cached __instancecheck__ results To understand why numerary protocols are faster for runtime checks, it helps to understand why non- numerary protocols are so slow. At runtime (i.e., via isinstance ), the default Protocol implementation delegates to _ProtocolMeta.__instancecheck__ to perform a crude comparison of an instance\u2019s callable attributes against the protocol\u2019s. More attributes means more comparisons. Further, it performs these comparisons \u2026 Every. Single. \ud83e\udd2cing. Time. Protocols provided by numerary use instead CachingProtocolMeta as their meta class. CachingProtocolMeta derives from _ProtocolMeta and overrides __instancecheck__ to cache results based on instance type. Conceptually: 1 2 3 4 5 6 7 8 >>> isinstance ( 1 , SupportsIntegralOps ) # first check for an int is delegated to _ProtcolMeta.__instancecheck__ True >>> isinstance ( 2 , SupportsIntegralOps ) # cached result True >>> isinstance ( 1.0 , SupportsIntegralOps ) # the first check for a float is delegated to _ProtcolMeta.__instancecheck__ False >>> isinstance ( 2.0 , SupportsIntegralOps ) # cached result False These offer significant performance improvements, especially where protocols define many methods. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 % timeit isinstance ( builtins . int ( 1 ), _SupportsComplexOps ) 11.9 \u00b5s \u00b1 279 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( builtins . int ( 1 ), SupportsComplexOps ) 312 ns \u00b1 1.56 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( builtins . float ( 2.0 ), _SupportsComplexOps ) 13.1 \u00b5s \u00b1 385 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( builtins . float ( 2.0 ), SupportsComplexOps ) 380 ns \u00b1 23 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( decimal . Decimal ( 3 ), _SupportsComplexOps ) 13.3 \u00b5s \u00b1 897 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( decimal . Decimal ( 3 ), SupportsComplexOps ) 322 ns \u00b1 12.4 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( fractions . Fraction ( 4 ), _SupportsComplexOps ) 11.9 \u00b5s \u00b1 178 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( fractions . Fraction ( 4 ), SupportsComplexOps ) 314 ns \u00b1 1.54 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( sympy . core . numbers . Integer ( 5 ), _SupportsComplexOps ) 12 \u00b5s \u00b1 110 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( sympy . core . numbers . Integer ( 5 ), SupportsComplexOps ) 315 ns \u00b1 4.39 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) Source: perf_supports_complex.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from decimal import Decimal from fractions import Fraction from numerary.types import _SupportsComplexOps # non-caching version from numerary.types import SupportsComplexOps # CachingProtocolMeta version import sympy one_int = 1 two_float = 2.0 three_dec = Decimal ( 3 ) four_frac = Fraction ( 4 ) five_sym = sympy . sympify ( 5 ) vals = ( one_int , two_float , three_dec , four_frac , five_sym ) for v in vals : for t in ( _SupportsComplexOps , SupportsComplexOps , ): print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) print () Union s for inclusion Sometimes we might want types that don\u2019t comply with protocol definitions to validate anyway (e.g., because we know they will work at runtime). For example, float s in Python versions prior to 3.9 officially lacked __floor__ and __ceil__ methods, but were registered with the numeric tower and worked just fine with math.floor and math.ceil . How does numerary \u2019s SupportsFloorCeil deal with this situation? Not very well, unfortunately, at least not on its own. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> import math , sys >>> from numerary.types import SupportsFloorCeil >>> def my_dumb_floor_func ( arg : SupportsFloorCeil ) -> int : ... assert isinstance ( arg , SupportsFloorCeil ) # will work, even for floats, thanks to default overrides ... return math . floor ( arg ) # type: ignore [arg-type] # doesn't understand SupportsFloorCeil >>> float_val : float = 1.6180339887 >>> # For illustration only until <https://github.com/python/mypy/issues/5940> is fixed >>> if sys . version_info < ( 3 , 9 ): ... my_dumb_floor_func ( float_val ) # type: ignore [arg-type] # still results in a Mypy error for Python version <3.9 ... else : ... my_dumb_floor_func ( float_val ) # validates 1 Union s allow a work-around. 1 2 3 4 5 6 7 8 9 10 11 >>> from typing import Union >>> from numerary.types import SupportsFloorCeil , __floor__ >>> SupportsFloorCeilU = Union [ float , SupportsFloorCeil ] >>> import sys >>> def my_floor_func ( arg : SupportsFloorCeilU ) -> int : ... assert isinstance ( arg , SupportsFloorCeil ) ... return __floor__ ( arg ) >>> my_floor_func ( float ( 1.2 )) # works in 3.7+ 1 This is largely a contrived example, since math.floor and math.ceil happily accept SupportsFloat , but it is useful for illustration. Limitations There are some downsides, though. (Aren\u2019t there always?) Sometimes protocols are too trusting Protocols trust numeric tower registrations. TODO(@posita): Is this really true? But sometimes, out there in the real world, implementations lie . Consider: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 >>> from numbers import Integral >>> hasattr ( Integral , \"real\" ) and hasattr ( Integral , \"imag\" ) True >>> import sympy >>> pants_on_fire = sympy . Integer ( 1 ) >>> isinstance ( pants_on_fire , Integral ) True >>> hasattr ( pants_on_fire , \"real\" ) or hasattr ( pants_on_fire , \"imag\" ) # somebody's tellin' stories False >>> from numerary.types import SupportsRealImag >>> real_imag : SupportsRealImag = pants_on_fire # fails to detect the lie >>> real_imag . real Traceback ( most recent call last ): ... AttributeError : 'One' object has no attribute 'real' In this particular case, numerary provides us with a defensive mechanism. 1 2 3 4 5 6 >>> from numerary.types import SupportsRealImagMixedU , real , imag >>> real_imag_defense : SupportsRealImagMixedU = pants_on_fire >>> real ( real_imag_defense ) 1 >>> imag ( real_imag ) 0 Protocols loses fidelity during runtime checking At runtime, protocols match names , not signatures . For example, SupportsNumeratorDenominator \u2019s numerator and denominator properties will match sage.rings.integer.Integer \u2019s similarly named functions . In other words, isinstance(sage_integer, SupportsNumeratorDenominator) will return True . Further, if the short-circuiting approach is used, because sage.rings.integer.Integer registers itself with the numeric tower, this may 2 not be caught by Mypy. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 >>> class SageLikeRational : ... def __init__ ( self , numerator : int , denominator : int = 1 ): ... self . _numerator = numerator ... self . _denominator = denominator ... def numerator ( self ) -> int : ... return self . _numerator ... def denominator ( self ) -> int : ... return self . _denominator >>> from numerary.types import SupportsNumeratorDenominator >>> frac : SupportsNumeratorDenominator = Fraction ( 29 , 3 ) # no typing error >>> sage_rational1 : SupportsNumeratorDenominator = SageLikeRational ( 29 , 3 ) # type: ignore [assignment] # Mypy catches this >>> isinstance ( sage_rational1 , SupportsNumeratorDenominator ) # isinstance does not True >>> sage_rational1 . numerator <... method ... numerator ...> >>> frac . numerator 29 Known warts could be cured by cache overriding as discussed above. However, to combat this particular situation, numerary provides an alternative: the SupportsNumeratorDenominatorMethods protocol and the numerator and denominator helper functions. These accommodate rational implementations like Sage\u2019s that are mostly compliant with the exception of their respective numerator and denominator implementations. 1 2 3 4 5 6 7 8 9 10 >>> from numerary.types import numerator >>> numerator ( sage_rational1 ) 29 >>> numerator ( frac ) 29 >>> from numerary.types import SupportsNumeratorDenominatorMethods , numerator >>> sage_rational2 : SupportsNumeratorDenominatorMethods = SageLikeRational ( 3 , 29 ) # no type error >>> numerator ( sage_rational2 ) 3 numerary also defines: 1 2 3 4 5 6 7 8 SupportsNumeratorDenominatorMixedU = Union [ SupportsNumeratorDenominator , SupportsNumeratorDenominatorMethods , ] SupportsNumeratorDenominatorMixedT = ( SupportsNumeratorDenominator , SupportsNumeratorDenominatorMethods , ) 1 2 3 4 5 6 7 8 >>> from numerary.types import SupportsNumeratorDenominatorMixedU , numerator >>> chimera_rational : SupportsNumeratorDenominatorMixedU >>> chimera_rational = Fraction ( 29 , 3 ) # no type error >>> numerator ( chimera_rational ) 29 >>> chimera_rational = SageLikeRational ( 3 , 29 ) # still no type error >>> numerator ( chimera_rational ) 3 The SupportsNumeratorDenominator* primitives provide the basis for analogous numerary.types.RationalLike* primitives , which should provide sufficient (if idiosyncratic) coverage for dealing with (seemingly mis-appropriately named) rationals. Pass-through caching with composition is pretty sketchy This is really getting into where the sausage is made, but full transparency is important, because CachingProtocolMeta does change how protocols are validated at runtime. Let\u2019s say we register an errant implementation as non-compliant using the CachingProtocolMeta.excludes method . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> from numerary.types import SupportsFloat >>> class FloatImposter : ... def __float__ ( self ) -> float : ... raise NotImplementedError ( \"Haha! JK! @#$% you!\" ) ... def __int__ ( self ) -> int : ... return 42 >>> float_imp = FloatImposter () >>> isinstance ( float_imp , SupportsFloat ) True >>> SupportsFloat . excludes ( FloatImposter ) >>> isinstance ( float_imp , SupportsFloat ) False For composition to be ergonomic, such registration should be indelible, survive composition, and afford preference to overrides by inheritors. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 >>> from numerary.types import ( ... CachingProtocolMeta , Protocol , runtime_checkable , ... SupportsInt , ... ) >>> @runtime_checkable ... class MySupportsFloatInt ( ... SupportsFloat , SupportsInt , ... Protocol , ... ): ... pass >>> isinstance ( float_imp , MySupportsFloatInt ) # composition picks up override from base False >>> SupportsFloat . reset_for ( FloatImposter ) # base resets override >>> isinstance ( float_imp , SupportsFloat ) True >>> isinstance ( float_imp , MySupportsFloatInt ) # picks up base\u2019s changes True >>> MySupportsFloatInt . excludes ( FloatImposter ) # composition overrides >>> isinstance ( float_imp , MySupportsFloatInt ) False >>> SupportsFloat . includes ( FloatImposter ) # base changes >>> isinstance ( float_imp , FloatImposter ) True >>> isinstance ( float_imp , MySupportsFloatInt ) # composition remains unchanged False >>> MySupportsFloatInt . reset_for ( FloatImposter ) # removes override in composition >>> isinstance ( float_imp , MySupportsFloatInt ) # base is visible again True >>> SupportsFloat . excludes ( FloatImposter ) >>> isinstance ( float_imp , MySupportsFloatInt ) # base\u2019s changes are visible to composition again False For this to work under the current implementation, we cannot rely exclusively on the standard library\u2019s implementation of __instancecheck__ , since it flattens and inspects all properties (with some proprietary exceptions) of all classes in the inheritance tree (in order of the MRO). In practical terms, this means one can\u2019t easily delegate to an ancestor\u2019s __instancecheck__ method and a protocol\u2019s cache is effectively hidden from its progeny. In other words, leaning on the default behavior would require one to register exceptions with every inheritor. That would suck, so let\u2019s not do that. However, overriding the behavior is problematic, because the standard library uses a non-public function called _get_protocol_attrs to perform its attribute enumeration. We certainly don\u2019t want to re-implement protocol runtime checking from scratch. (At least not yet.) CachingProtocolMeta tries to work around this by importing _get_protocol_attrs and performing some set arithmetic to limit its evaluation to directly defined attributes, and then delegating isinstance evaluation to its __base__ classes. In doing so, it picks up its bases\u2019 then-cached values, but at the cost of re-implementing the attribute check as well as taking a dependency on an implementation detail of the standard library, which creates a fragility. Further, for post-inheritance updates, CachingProtocolMeta implements a simplistic publish/subscribe mechanism that dirties non-overridden caches in inheritors when member protocols caches are updated. That\u2019s completely off the beaten path and there are probably some gremlins hiding out there. One subtlety is that the implementation deviates from performing checks in MRO order (and may perform redundant checks). This is probably fine as long as runtime comparisons remain limited to crude checks whether attributes merely exist. It would likely fail if runtime checking becomes more sophisticated, at which time, this implementation will need to be revisited. Hopefully by then, we can just delete numerary as the aspirationally unnecessary hack it is and move on with our lives. (See the implementation for details.) License numerary is licensed under the MIT License . See the included LICENSE file for details. Source code is available on GitHub . Installation Installation can be performed via PyPI . 1 2 % pip install numerary ... Alternately, you can download the source and install manually. 1 2 3 4 5 % git clone https://github.com/posita/numerary.git ... % cd numerary % python -m pip install . # -or- python -c 'from setuptools import setup ; setup()' install . ... Requirements numerary requires a relatively modern version of Python: CPython (3.7+) PyPy (CPython 3.7+ compatible) It has the following runtime dependencies: typing-extensions (with Python <3.9) numerary will opportunistically use the following, if available at runtime: beartype for yummy runtime type-checking goodness (0.8+) If you use beartype for type-checking your code, but don\u2019t want numerary to use it internally, set the NUMERARY_BEARTYPE environment variable to a falsy 3 value before numerary is loaded. See the hacking quick-start for additional development and testing dependencies. Customers dyce - a pure-Python library for modeling arbitrarily complex dice mechanics and mother birthing code base of numerary ! The next one could be you ! \ud83d\udc4b Do you have a project that suffers problems made slightly less annoying by numerary ? Let me know , and I\u2019ll promote it here! And don\u2019t forget to do your part in perpetuating gratuitous badge-ification! 1 2 3 4 <!-- Markdown --> As of version 0.4.1, ``dyce`` is [ ![numerary-encumbered ]( https://raw.githubusercontent.com/posita/numerary/latest/docs/numerary-encumbered.svg )][numerary-encumbered]! [ numerary-encumbered ]: https://posita.github.io/numerary/ \"numerary-encumbered\" 1 2 3 4 5 6 7 8 9 .. reStructuredText - see https://docutils.sourceforge.io/docs/ref/rst/directives.html#image As of version 0.4.1, ``dyce`` is |numerary-encumbered|! .. |numerary-encumbered| image :: https://raw.githubusercontent.com/posita/numerary/latest/docs/numerary-encumbered.svg :align: top :target: https://posita.github.io/numerary/ :alt: numerary-encumbered 1 2 3 4 5 <!-- HTML --> As of version 0.4.1, < code > dyce </ code > is < a href = \"https://posita.github.io/numerary/\" >< img src = \"https://raw.githubusercontent.com/posita/numerary/latest/docs/numerary-encumbered.svg\" alt = \"numerary-encumbered\" style = \"vertical-align: middle;\" ></ a > ! You know, super weird, off-the-wall shit, like members of the numeric tower , or standard library primitives that remain non -members for some \ud83e\udd2ced up reason , or legitimate non-members because they predate PEP 3141 and conforming would amount to breaking changes , or\u2014I don\u2019t know\u2014oodles of libraries and applications that have been around for literally decades that bring huge value to vast scientific and mathematic audiences, but whose number primitives break type-checking if one abides by the ubiquitous bum steer, \u201cI don\u2019t have any experience trying to do what you\u2019re doing, but just use float , bro.\u201d Because, hey, \ud83e\udd2c numbers! Am I right? \u21a9 I say may because I don\u2019t really understand how Sage\u2019s number registrations work. \u21a9 I.E., one of: 0 , off , f , false , and no . \u21a9","title":"Introduction"},{"location":"#numerarynow-with-protocol-powertm","text":"That\u2019s right! For a hopefully limited time, you too can benefit from someone else\u2019s deranged work-arounds for the enormous chasms in Python that lie between the esoteric fields of computation that are \u201ctyping\u201d and \u201cnumbers\u201d instead of having to roll your own out of sheer desperation from first principles ! If you still have no idea what I\u2019m talking about, this may help illustrate . numerary is a pure-Python codified rant for signaling that your interface is usable with non-native numeric primitives 1 without breaking type-checking. More simply, numerary aspires to a world where numbers and types can work together. If you\u2019re thinking that you shouldn\u2019t need a \ud83e\udd2cing library for that, you\u2019re right . This madness should enjoy no audience. It should not exist. Yet here we are. Its author gauges its success by how quickly it can be forgotten, relegated to the annals of superfluous folly. numerary is licensed under the MIT License . See the accompanying LICENSE file for details. It should be considered experimental for now, but should settle down quickly. See the release notes for a summary of version-to-version changes. Source code is available on GitHub . If you find it lacking in any way, please don\u2019t hesitate to bring it to my attention .","title":"numerary\u2014Now with Protocol Power\u2122"},{"location":"#you-had-me-at-numbers-and-types-can-work-together","text":"numerary strives to define composable, efficient protocols that one can use to construct numeric requirements. If all you deal with are integrals and reals, and what you want is broad arithmetic operator compatibility, this will probably get you where you likely want to go: 1 2 3 4 5 >>> from numerary import IntegralLike , RealLike >>> def deeper_thot ( arg : RealLike ) -> IntegralLike : ... assert arg != 0 and arg ** 0 == 1 ... return arg // arg + 42 Beyond default compositions for common use cases, numerary expands on the Supports pattern used in the standard library. For example, numerary.types.SupportsIntegralOps is a @typing.runtime_checkable protocol that approximates the unary and binary operators introduced by numbers.Integral . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from numerary.types import SupportsIntegralOps >>> def shift_right_one ( arg : SupportsIntegralOps ) -> SupportsIntegralOps : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg >> 1 >>> shift_right_one ( 2 ) 1 >>> from sympy import sympify >>> two = sympify ( \"2\" ) ; type ( two ) < class ' sympy . core . numbers . Integer '> >>> res = shift_right_one ( two ) ; res 1 >>> type ( res ) < class ' sympy . core . numbers . One '> >>> from fractions import Fraction >>> shift_right_one ( Fraction ( 1 , 2 )) # type: ignore [arg-type] # properly caught by Mypy Traceback ( most recent call last ): ... AssertionError Note Until 1.9, sympy.Integer lacked the requisite bitwise operators . numerary catches that! The above properly results in both a type-checking error as well as a runtime failure for SymPy versions prior to 1.9. numerary \u2019s Supports protocols can be composed to refine requirements. For example, let\u2019s say one wanted to ensure type compatibility with primitives that support both __abs__ and __divmod__ . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 >>> from typing import TypeVar >>> T_co = TypeVar ( \"T_co\" , covariant = True ) >>> from numerary.types import ( ... CachingProtocolMeta , Protocol , runtime_checkable , ... SupportsAbs , SupportsDivmod , ... ) >>> @runtime_checkable ... class MyType ( ... SupportsAbs [ T_co ], SupportsDivmod [ T_co ], ... Protocol , metaclass = CachingProtocolMeta , ... ): ... pass >>> my_type : MyType >>> my_type = 3.5 >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) 3.5 >>> divmod ( my_type , 2 ) ( 1.0 , 1.5 ) >>> from fractions import Fraction >>> my_type = Fraction ( 22 , 7 ) >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) Fraction ( 22 , 7 ) >>> divmod ( my_type , 2 ) ( 1 , Fraction ( 8 , 7 )) >>> from decimal import Decimal >>> my_type = Decimal ( \"5.2\" ) >>> isinstance ( my_type , MyType ) True >>> abs ( my_type ) Decimal ( '5.2' ) >>> divmod ( my_type , 2 ) ( Decimal ( '2' ), Decimal ( '1.2' )) >>> my_type = \"nope\" # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( my_type , MyType ) False Remember that scandal where complex defined exception-throwing comparators it wasn\u2019t supposed to have, which confused runtime protocol checking, and then its type definitions lied about it to cover it up ? Yeah, that shit ends here . 1 2 3 4 5 6 >>> from numerary.types import SupportsRealOps >>> isinstance ( 1.0 , SupportsRealOps ) # all good True >>> has_real_ops : SupportsRealOps = complex ( 1 ) # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( complex ( 1 ), SupportsRealOps ) # you're not fooling anyone, buddy False numerary not only caches runtime protocol evaluations, but allows overriding those evaluations when the default machinery gets it wrong. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from abc import abstractmethod >>> from typing import Iterable , Union >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class MySupportsOne ( Protocol , metaclass = CachingProtocolMeta ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @abstractmethod ... def one ( self ) -> int : ... pass >>> class Imposter : ... def one ( self ) -> str : ... return \"one\" >>> imp : MySupportsOne = Imposter () # type: ignore [assignment] # properly caught by Mypy >>> isinstance ( imp , MySupportsOne ) # fool me once, shame on you ... True >>> MySupportsOne . excludes ( Imposter ) >>> isinstance ( imp , MySupportsOne ) # ... can't get fooled again False numerary has default overrides to correct for known oddities with native types (like our old friend, complex ) and with popular libraries like numpy and sympy . Others will be added as they are identified. If I\u2019ve missed any, or if you would like numerary to support additional number implementations out of the box, please let me know .","title":"You had me at, \u201cnumbers and types can work together\u201d"},{"location":"#performance-enhanced-protocolsa-different-kind-of-pep-for-your-step","text":"By default, protocols frustrate runtime type-checking performance . A lot. numerary applies two distinct, layered optimization strategies: Cached __instancecheck__ results for numerary -defined protocols; and Optional(-ish) short-circuit type enumerations.","title":"Performance Enhanced Protocols\u2014A different kind of \u201cPEP\u201d for your step"},{"location":"#cached-__instancecheck__-results","text":"To understand why numerary protocols are faster for runtime checks, it helps to understand why non- numerary protocols are so slow. At runtime (i.e., via isinstance ), the default Protocol implementation delegates to _ProtocolMeta.__instancecheck__ to perform a crude comparison of an instance\u2019s callable attributes against the protocol\u2019s. More attributes means more comparisons. Further, it performs these comparisons \u2026 Every. Single. \ud83e\udd2cing. Time. Protocols provided by numerary use instead CachingProtocolMeta as their meta class. CachingProtocolMeta derives from _ProtocolMeta and overrides __instancecheck__ to cache results based on instance type. Conceptually: 1 2 3 4 5 6 7 8 >>> isinstance ( 1 , SupportsIntegralOps ) # first check for an int is delegated to _ProtcolMeta.__instancecheck__ True >>> isinstance ( 2 , SupportsIntegralOps ) # cached result True >>> isinstance ( 1.0 , SupportsIntegralOps ) # the first check for a float is delegated to _ProtcolMeta.__instancecheck__ False >>> isinstance ( 2.0 , SupportsIntegralOps ) # cached result False These offer significant performance improvements, especially where protocols define many methods. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 % timeit isinstance ( builtins . int ( 1 ), _SupportsComplexOps ) 11.9 \u00b5s \u00b1 279 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( builtins . int ( 1 ), SupportsComplexOps ) 312 ns \u00b1 1.56 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( builtins . float ( 2.0 ), _SupportsComplexOps ) 13.1 \u00b5s \u00b1 385 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( builtins . float ( 2.0 ), SupportsComplexOps ) 380 ns \u00b1 23 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( decimal . Decimal ( 3 ), _SupportsComplexOps ) 13.3 \u00b5s \u00b1 897 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( decimal . Decimal ( 3 ), SupportsComplexOps ) 322 ns \u00b1 12.4 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( fractions . Fraction ( 4 ), _SupportsComplexOps ) 11.9 \u00b5s \u00b1 178 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( fractions . Fraction ( 4 ), SupportsComplexOps ) 314 ns \u00b1 1.54 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( sympy . core . numbers . Integer ( 5 ), _SupportsComplexOps ) 12 \u00b5s \u00b1 110 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( sympy . core . numbers . Integer ( 5 ), SupportsComplexOps ) 315 ns \u00b1 4.39 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) Source: perf_supports_complex.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from decimal import Decimal from fractions import Fraction from numerary.types import _SupportsComplexOps # non-caching version from numerary.types import SupportsComplexOps # CachingProtocolMeta version import sympy one_int = 1 two_float = 2.0 three_dec = Decimal ( 3 ) four_frac = Fraction ( 4 ) five_sym = sympy . sympify ( 5 ) vals = ( one_int , two_float , three_dec , four_frac , five_sym ) for v in vals : for t in ( _SupportsComplexOps , SupportsComplexOps , ): print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) print ()","title":"Cached __instancecheck__ results"},{"location":"#unions-for-inclusion","text":"Sometimes we might want types that don\u2019t comply with protocol definitions to validate anyway (e.g., because we know they will work at runtime). For example, float s in Python versions prior to 3.9 officially lacked __floor__ and __ceil__ methods, but were registered with the numeric tower and worked just fine with math.floor and math.ceil . How does numerary \u2019s SupportsFloorCeil deal with this situation? Not very well, unfortunately, at least not on its own. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> import math , sys >>> from numerary.types import SupportsFloorCeil >>> def my_dumb_floor_func ( arg : SupportsFloorCeil ) -> int : ... assert isinstance ( arg , SupportsFloorCeil ) # will work, even for floats, thanks to default overrides ... return math . floor ( arg ) # type: ignore [arg-type] # doesn't understand SupportsFloorCeil >>> float_val : float = 1.6180339887 >>> # For illustration only until <https://github.com/python/mypy/issues/5940> is fixed >>> if sys . version_info < ( 3 , 9 ): ... my_dumb_floor_func ( float_val ) # type: ignore [arg-type] # still results in a Mypy error for Python version <3.9 ... else : ... my_dumb_floor_func ( float_val ) # validates 1 Union s allow a work-around. 1 2 3 4 5 6 7 8 9 10 11 >>> from typing import Union >>> from numerary.types import SupportsFloorCeil , __floor__ >>> SupportsFloorCeilU = Union [ float , SupportsFloorCeil ] >>> import sys >>> def my_floor_func ( arg : SupportsFloorCeilU ) -> int : ... assert isinstance ( arg , SupportsFloorCeil ) ... return __floor__ ( arg ) >>> my_floor_func ( float ( 1.2 )) # works in 3.7+ 1 This is largely a contrived example, since math.floor and math.ceil happily accept SupportsFloat , but it is useful for illustration.","title":"Unions for inclusion"},{"location":"#limitations","text":"There are some downsides, though. (Aren\u2019t there always?)","title":"Limitations"},{"location":"#sometimes-protocols-are-too-trusting","text":"Protocols trust numeric tower registrations. TODO(@posita): Is this really true? But sometimes, out there in the real world, implementations lie . Consider: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 >>> from numbers import Integral >>> hasattr ( Integral , \"real\" ) and hasattr ( Integral , \"imag\" ) True >>> import sympy >>> pants_on_fire = sympy . Integer ( 1 ) >>> isinstance ( pants_on_fire , Integral ) True >>> hasattr ( pants_on_fire , \"real\" ) or hasattr ( pants_on_fire , \"imag\" ) # somebody's tellin' stories False >>> from numerary.types import SupportsRealImag >>> real_imag : SupportsRealImag = pants_on_fire # fails to detect the lie >>> real_imag . real Traceback ( most recent call last ): ... AttributeError : 'One' object has no attribute 'real' In this particular case, numerary provides us with a defensive mechanism. 1 2 3 4 5 6 >>> from numerary.types import SupportsRealImagMixedU , real , imag >>> real_imag_defense : SupportsRealImagMixedU = pants_on_fire >>> real ( real_imag_defense ) 1 >>> imag ( real_imag ) 0","title":"Sometimes protocols are too trusting"},{"location":"#protocols-loses-fidelity-during-runtime-checking","text":"At runtime, protocols match names , not signatures . For example, SupportsNumeratorDenominator \u2019s numerator and denominator properties will match sage.rings.integer.Integer \u2019s similarly named functions . In other words, isinstance(sage_integer, SupportsNumeratorDenominator) will return True . Further, if the short-circuiting approach is used, because sage.rings.integer.Integer registers itself with the numeric tower, this may 2 not be caught by Mypy. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 >>> class SageLikeRational : ... def __init__ ( self , numerator : int , denominator : int = 1 ): ... self . _numerator = numerator ... self . _denominator = denominator ... def numerator ( self ) -> int : ... return self . _numerator ... def denominator ( self ) -> int : ... return self . _denominator >>> from numerary.types import SupportsNumeratorDenominator >>> frac : SupportsNumeratorDenominator = Fraction ( 29 , 3 ) # no typing error >>> sage_rational1 : SupportsNumeratorDenominator = SageLikeRational ( 29 , 3 ) # type: ignore [assignment] # Mypy catches this >>> isinstance ( sage_rational1 , SupportsNumeratorDenominator ) # isinstance does not True >>> sage_rational1 . numerator <... method ... numerator ...> >>> frac . numerator 29 Known warts could be cured by cache overriding as discussed above. However, to combat this particular situation, numerary provides an alternative: the SupportsNumeratorDenominatorMethods protocol and the numerator and denominator helper functions. These accommodate rational implementations like Sage\u2019s that are mostly compliant with the exception of their respective numerator and denominator implementations. 1 2 3 4 5 6 7 8 9 10 >>> from numerary.types import numerator >>> numerator ( sage_rational1 ) 29 >>> numerator ( frac ) 29 >>> from numerary.types import SupportsNumeratorDenominatorMethods , numerator >>> sage_rational2 : SupportsNumeratorDenominatorMethods = SageLikeRational ( 3 , 29 ) # no type error >>> numerator ( sage_rational2 ) 3 numerary also defines: 1 2 3 4 5 6 7 8 SupportsNumeratorDenominatorMixedU = Union [ SupportsNumeratorDenominator , SupportsNumeratorDenominatorMethods , ] SupportsNumeratorDenominatorMixedT = ( SupportsNumeratorDenominator , SupportsNumeratorDenominatorMethods , ) 1 2 3 4 5 6 7 8 >>> from numerary.types import SupportsNumeratorDenominatorMixedU , numerator >>> chimera_rational : SupportsNumeratorDenominatorMixedU >>> chimera_rational = Fraction ( 29 , 3 ) # no type error >>> numerator ( chimera_rational ) 29 >>> chimera_rational = SageLikeRational ( 3 , 29 ) # still no type error >>> numerator ( chimera_rational ) 3 The SupportsNumeratorDenominator* primitives provide the basis for analogous numerary.types.RationalLike* primitives , which should provide sufficient (if idiosyncratic) coverage for dealing with (seemingly mis-appropriately named) rationals.","title":"Protocols loses fidelity during runtime checking"},{"location":"#pass-through-caching-with-composition-is-pretty-sketchy","text":"This is really getting into where the sausage is made, but full transparency is important, because CachingProtocolMeta does change how protocols are validated at runtime. Let\u2019s say we register an errant implementation as non-compliant using the CachingProtocolMeta.excludes method . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> from numerary.types import SupportsFloat >>> class FloatImposter : ... def __float__ ( self ) -> float : ... raise NotImplementedError ( \"Haha! JK! @#$% you!\" ) ... def __int__ ( self ) -> int : ... return 42 >>> float_imp = FloatImposter () >>> isinstance ( float_imp , SupportsFloat ) True >>> SupportsFloat . excludes ( FloatImposter ) >>> isinstance ( float_imp , SupportsFloat ) False For composition to be ergonomic, such registration should be indelible, survive composition, and afford preference to overrides by inheritors. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 >>> from numerary.types import ( ... CachingProtocolMeta , Protocol , runtime_checkable , ... SupportsInt , ... ) >>> @runtime_checkable ... class MySupportsFloatInt ( ... SupportsFloat , SupportsInt , ... Protocol , ... ): ... pass >>> isinstance ( float_imp , MySupportsFloatInt ) # composition picks up override from base False >>> SupportsFloat . reset_for ( FloatImposter ) # base resets override >>> isinstance ( float_imp , SupportsFloat ) True >>> isinstance ( float_imp , MySupportsFloatInt ) # picks up base\u2019s changes True >>> MySupportsFloatInt . excludes ( FloatImposter ) # composition overrides >>> isinstance ( float_imp , MySupportsFloatInt ) False >>> SupportsFloat . includes ( FloatImposter ) # base changes >>> isinstance ( float_imp , FloatImposter ) True >>> isinstance ( float_imp , MySupportsFloatInt ) # composition remains unchanged False >>> MySupportsFloatInt . reset_for ( FloatImposter ) # removes override in composition >>> isinstance ( float_imp , MySupportsFloatInt ) # base is visible again True >>> SupportsFloat . excludes ( FloatImposter ) >>> isinstance ( float_imp , MySupportsFloatInt ) # base\u2019s changes are visible to composition again False For this to work under the current implementation, we cannot rely exclusively on the standard library\u2019s implementation of __instancecheck__ , since it flattens and inspects all properties (with some proprietary exceptions) of all classes in the inheritance tree (in order of the MRO). In practical terms, this means one can\u2019t easily delegate to an ancestor\u2019s __instancecheck__ method and a protocol\u2019s cache is effectively hidden from its progeny. In other words, leaning on the default behavior would require one to register exceptions with every inheritor. That would suck, so let\u2019s not do that. However, overriding the behavior is problematic, because the standard library uses a non-public function called _get_protocol_attrs to perform its attribute enumeration. We certainly don\u2019t want to re-implement protocol runtime checking from scratch. (At least not yet.) CachingProtocolMeta tries to work around this by importing _get_protocol_attrs and performing some set arithmetic to limit its evaluation to directly defined attributes, and then delegating isinstance evaluation to its __base__ classes. In doing so, it picks up its bases\u2019 then-cached values, but at the cost of re-implementing the attribute check as well as taking a dependency on an implementation detail of the standard library, which creates a fragility. Further, for post-inheritance updates, CachingProtocolMeta implements a simplistic publish/subscribe mechanism that dirties non-overridden caches in inheritors when member protocols caches are updated. That\u2019s completely off the beaten path and there are probably some gremlins hiding out there. One subtlety is that the implementation deviates from performing checks in MRO order (and may perform redundant checks). This is probably fine as long as runtime comparisons remain limited to crude checks whether attributes merely exist. It would likely fail if runtime checking becomes more sophisticated, at which time, this implementation will need to be revisited. Hopefully by then, we can just delete numerary as the aspirationally unnecessary hack it is and move on with our lives. (See the implementation for details.)","title":"Pass-through caching with composition is pretty sketchy"},{"location":"#license","text":"numerary is licensed under the MIT License . See the included LICENSE file for details. Source code is available on GitHub .","title":"License"},{"location":"#installation","text":"Installation can be performed via PyPI . 1 2 % pip install numerary ... Alternately, you can download the source and install manually. 1 2 3 4 5 % git clone https://github.com/posita/numerary.git ... % cd numerary % python -m pip install . # -or- python -c 'from setuptools import setup ; setup()' install . ...","title":"Installation"},{"location":"#requirements","text":"numerary requires a relatively modern version of Python: CPython (3.7+) PyPy (CPython 3.7+ compatible) It has the following runtime dependencies: typing-extensions (with Python <3.9) numerary will opportunistically use the following, if available at runtime: beartype for yummy runtime type-checking goodness (0.8+) If you use beartype for type-checking your code, but don\u2019t want numerary to use it internally, set the NUMERARY_BEARTYPE environment variable to a falsy 3 value before numerary is loaded. See the hacking quick-start for additional development and testing dependencies.","title":"Requirements"},{"location":"#customers","text":"dyce - a pure-Python library for modeling arbitrarily complex dice mechanics and mother birthing code base of numerary ! The next one could be you ! \ud83d\udc4b Do you have a project that suffers problems made slightly less annoying by numerary ? Let me know , and I\u2019ll promote it here! And don\u2019t forget to do your part in perpetuating gratuitous badge-ification! 1 2 3 4 <!-- Markdown --> As of version 0.4.1, ``dyce`` is [ ![numerary-encumbered ]( https://raw.githubusercontent.com/posita/numerary/latest/docs/numerary-encumbered.svg )][numerary-encumbered]! [ numerary-encumbered ]: https://posita.github.io/numerary/ \"numerary-encumbered\" 1 2 3 4 5 6 7 8 9 .. reStructuredText - see https://docutils.sourceforge.io/docs/ref/rst/directives.html#image As of version 0.4.1, ``dyce`` is |numerary-encumbered|! .. |numerary-encumbered| image :: https://raw.githubusercontent.com/posita/numerary/latest/docs/numerary-encumbered.svg :align: top :target: https://posita.github.io/numerary/ :alt: numerary-encumbered 1 2 3 4 5 <!-- HTML --> As of version 0.4.1, < code > dyce </ code > is < a href = \"https://posita.github.io/numerary/\" >< img src = \"https://raw.githubusercontent.com/posita/numerary/latest/docs/numerary-encumbered.svg\" alt = \"numerary-encumbered\" style = \"vertical-align: middle;\" ></ a > ! You know, super weird, off-the-wall shit, like members of the numeric tower , or standard library primitives that remain non -members for some \ud83e\udd2ced up reason , or legitimate non-members because they predate PEP 3141 and conforming would amount to breaking changes , or\u2014I don\u2019t know\u2014oodles of libraries and applications that have been around for literally decades that bring huge value to vast scientific and mathematic audiences, but whose number primitives break type-checking if one abides by the ubiquitous bum steer, \u201cI don\u2019t have any experience trying to do what you\u2019re doing, but just use float , bro.\u201d Because, hey, \ud83e\udd2c numbers! Am I right? \u21a9 I say may because I don\u2019t really understand how Sage\u2019s number registrations work. \u21a9 I.E., one of: 0 , off , f , false , and no . \u21a9","title":"Customers"},{"location":"contrib/","text":"Contributing to numerary There are many ways you can contribute. You have only but to try. Starting discussions and filing issues You can file new issues as you find them. Please try to avoid duplicating issues. \u201cWriting Effective Bug Reports\u201d by Elisabeth Hendrickson (PDF) may be helpful. For more free-flow discussions (beefs, rants, ideas, recipes, etc.), consider starting or joining a discussion . Hacking quick-start An easy way to bootstrap an isolated development environment is: 1 2 3 4 5 6 7 8 9 10 % git clone --recurse-submodules https://github.com/posita/numerary.git \u2026 % cd numerary % /path/to/python -m venv .venv \u2026 % . .venv/bin/activate % pip install --upgrade --editable '.[dev]' \u2026 % python -m pre_commit install \u2026 Substitute your preferred virtual environment process for venv . The [dev] variant includes additional dependencies necessary for development and testing. See the [options.extras_require] section in setup.cfg . Unit tests are run with pytest via Tox . 1 2 3 4 % cd \u2026/path/to/numerary % . .venv/bin/activate % tox [ TOX_ARGS... [ -- PYTEST_ARGS... ]] \u2026 Submission guidelines If you are willing and able, consider submitting a pull request with a fix. See the docs if you\u2019re not already familiar with pull requests. numerary releases from master (although not always immediately), so a lot of these workflows are helpful. There are only a few additional guidelines: If it is not already present, please add your name (and optionally your email, GitHub username, website address, or other contact information) to the LICENSE file. 1 2 3 ... * [ Matt Bogosian ]( mailto:matt@bogosian.net?Subject=numerary ); GitHub \u2013 [ **@posita** ](https://github.com/posita) ... Use Black to format your changes. Do your best to follow the source conventions as you observe them. If it\u2019s important to you, Existing comments are wrapped at 88 characters per line to match Black\u2019s default. (Don\u2019t spend too much effort on strict conformance, though. I can clean things up later if they really bother me.) Provide tests where feasible and appropriate. At the very least, existing tests should not fail. (There are exceptions, but if there is any doubt, they probably do not apply.) Unit tests live in tests . If you want feedback on a work-in-progress, consider \u201cmentioning\u201d me ( @posita ), and describe specifically how I can help. Consider prefixing your pull request\u2019s title with something like, \u201c NEED FEEDBACK \u2013 \u201d. If your pull request is still in progress, but you are not blocked on anything, consider using the draft feature . Once you are ready for a merge, resolve any conflicts, squash your commits, and provide a useful commit message. ( This and this may be helpful.) If your pull request started out as a draft, promote it by requesting a review. Consider prefixing the pull request\u2019s title to something like, \u201c READY FOR MERGE \u2013 \u201d. I will try to get to it as soon as I can.","title":"Contributing"},{"location":"contrib/#contributing-to-numerary","text":"There are many ways you can contribute. You have only but to try.","title":"Contributing to numerary"},{"location":"contrib/#starting-discussions-and-filing-issues","text":"You can file new issues as you find them. Please try to avoid duplicating issues. \u201cWriting Effective Bug Reports\u201d by Elisabeth Hendrickson (PDF) may be helpful. For more free-flow discussions (beefs, rants, ideas, recipes, etc.), consider starting or joining a discussion .","title":"Starting discussions and filing issues"},{"location":"contrib/#hacking-quick-start","text":"An easy way to bootstrap an isolated development environment is: 1 2 3 4 5 6 7 8 9 10 % git clone --recurse-submodules https://github.com/posita/numerary.git \u2026 % cd numerary % /path/to/python -m venv .venv \u2026 % . .venv/bin/activate % pip install --upgrade --editable '.[dev]' \u2026 % python -m pre_commit install \u2026 Substitute your preferred virtual environment process for venv . The [dev] variant includes additional dependencies necessary for development and testing. See the [options.extras_require] section in setup.cfg . Unit tests are run with pytest via Tox . 1 2 3 4 % cd \u2026/path/to/numerary % . .venv/bin/activate % tox [ TOX_ARGS... [ -- PYTEST_ARGS... ]] \u2026","title":"Hacking quick-start"},{"location":"contrib/#submission-guidelines","text":"If you are willing and able, consider submitting a pull request with a fix. See the docs if you\u2019re not already familiar with pull requests. numerary releases from master (although not always immediately), so a lot of these workflows are helpful. There are only a few additional guidelines: If it is not already present, please add your name (and optionally your email, GitHub username, website address, or other contact information) to the LICENSE file. 1 2 3 ... * [ Matt Bogosian ]( mailto:matt@bogosian.net?Subject=numerary ); GitHub \u2013 [ **@posita** ](https://github.com/posita) ... Use Black to format your changes. Do your best to follow the source conventions as you observe them. If it\u2019s important to you, Existing comments are wrapped at 88 characters per line to match Black\u2019s default. (Don\u2019t spend too much effort on strict conformance, though. I can clean things up later if they really bother me.) Provide tests where feasible and appropriate. At the very least, existing tests should not fail. (There are exceptions, but if there is any doubt, they probably do not apply.) Unit tests live in tests . If you want feedback on a work-in-progress, consider \u201cmentioning\u201d me ( @posita ), and describe specifically how I can help. Consider prefixing your pull request\u2019s title with something like, \u201c NEED FEEDBACK \u2013 \u201d. If your pull request is still in progress, but you are not blocked on anything, consider using the draft feature . Once you are ready for a merge, resolve any conflicts, squash your commits, and provide a useful commit message. ( This and this may be helpful.) If your pull request started out as a draft, promote it by requesting a review. Consider prefixing the pull request\u2019s title to something like, \u201c READY FOR MERGE \u2013 \u201d. I will try to get to it as soon as I can.","title":"Submission guidelines"},{"location":"license/","text":"License and credits The MIT License (MIT) Copyright \u00a9 2015-2022 Matt Bogosian ( @posita ). Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Contributors The following individuals or entities have contributed to this software: Matt Bogosian ; GitHub \u2013 @posita By adding your name to this list, you grant a nonexclusive, perpetual license to your contributions to this software under the same terms as its license, above. Further, you warrant that your contributions to this software are exclusively your own creations and no one else has any superior right or claim to them. Finally, you agree to indemnify and hold harmless this software\u2019s owner against any colorable claim of infringement by a third party for this software\u2019s owner\u2019s otherwise lawful use of your contribution, whether or not such use was contemplated by you at the time you made it.","title":"License"},{"location":"license/#license-and-credits","text":"","title":"License and credits"},{"location":"license/#the-mit-license-mit","text":"Copyright \u00a9 2015-2022 Matt Bogosian ( @posita ). Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License (MIT)"},{"location":"license/#contributors","text":"The following individuals or entities have contributed to this software: Matt Bogosian ; GitHub \u2013 @posita By adding your name to this list, you grant a nonexclusive, perpetual license to your contributions to this software under the same terms as its license, above. Further, you warrant that your contributions to this software are exclusively your own creations and no one else has any superior right or claim to them. Finally, you agree to indemnify and hold harmless this software\u2019s owner against any colorable claim of infringement by a third party for this software\u2019s owner\u2019s otherwise lawful use of your contribution, whether or not such use was contemplated by you at the time you made it.","title":"Contributors"},{"location":"notes/","text":"numerary release notes 0.3.0 Removes misleading advice that SCUs offer a performance benefit over merely using caching protocols. They could under very specific circumstances (where numerary probably isn\u2019t going to be helpful anyway), but not always, and probably aren\u2019t worth the trouble if performance is the only concern. Actually, removes SCUs altogether and documents a surgical example for those rare occasions where it might be needed. Finally removes SupportsNumeratorDenominatorProperties as promised. 0.2.1 Fixes trailing issues for sympy import issue resulting in ValueError s being thrown on import in some environments. 0.2.0 numerary goes beta! Splits SupportsRealImagAsMethod out of SupportsRealImag and provides the real and imag helper functions for better support of sympy \u2019s number primitives. Renames SupportsNumeratorDenominatorProperties to SupportsNumeratorDenominator to mirror SupportsRealImag and reflect that it captures the numeric tower interface. SupportsNumeratorDenominatorProperties and SupportsNumeratorDenominatorPropertiesSCU are maintained as aliases for limited backward compatibility and will be removed in the next version. Removes enum.Flag from testing as a non-sequitur. (It matches none of the presented protocols.) Introduces __pow__ helper function and renames trunc , floor , and ceil to __trunc__ , __floor__ , and __ceil__ , respectively. Fixes sympy import issue resulting in AttributeError s being thrown on import in some environments. 0.1.1 Removes obsoleted \u2026SCT aliases. Corrects release notes which erroneously identified version 0.1.0 as 0.0.6. Adds enum.IntEnum , enum.IntFlag , and enum.Flag to testing. Merges SupportsFloor and SupportsCeil into SupportsFloorCeil . Gets rid of MANIFEST.in nonsense since we\u2019re not distributing sources via PyPI anymore. Adds a ton of examples to protocol docs. Better identifies false positives in tests. 0.1.0 Adds CachingProtocolMeta.includes , CachingProtocolMeta.excludes , and CachingProtocolMeta.reset_for cache override functions. Retires \u2026SCT tuples as unnecessary, especially in light of cache overrides. (Runtime isinstance protocol checking is fast enough.) For limited backward compatibility, they are now merely type aliases for similarly named protocols and will be removed in the next version. Updates docs. Custom runtime comparison implementation allows composition to lean on base types\u2019 caches. (\u26a0\ufe0f WARNING: Severe jank alert! \u26a0\ufe0f) 0.0.5 Updates license to the MIT License . Gets rid of self redundancy in __isinstance__ checks. 0.0.4 numerary finally leaves the dyce nest to become its own library! It didn\u2019t quite leave before because its maintainer is a bonehead who doesn\u2019t understand setuptools\u2019 multitude of oh-so-simple packaging mechanisms. No, it stuck around most weekends to do laundry while eating all of dyce \u2019s food. Now it has officially left the nest.","title":"Release notes"},{"location":"notes/#numerary-release-notes","text":"","title":"numerary release notes"},{"location":"notes/#030","text":"Removes misleading advice that SCUs offer a performance benefit over merely using caching protocols. They could under very specific circumstances (where numerary probably isn\u2019t going to be helpful anyway), but not always, and probably aren\u2019t worth the trouble if performance is the only concern. Actually, removes SCUs altogether and documents a surgical example for those rare occasions where it might be needed. Finally removes SupportsNumeratorDenominatorProperties as promised.","title":"0.3.0"},{"location":"notes/#021","text":"Fixes trailing issues for sympy import issue resulting in ValueError s being thrown on import in some environments.","title":"0.2.1"},{"location":"notes/#020","text":"numerary goes beta! Splits SupportsRealImagAsMethod out of SupportsRealImag and provides the real and imag helper functions for better support of sympy \u2019s number primitives. Renames SupportsNumeratorDenominatorProperties to SupportsNumeratorDenominator to mirror SupportsRealImag and reflect that it captures the numeric tower interface. SupportsNumeratorDenominatorProperties and SupportsNumeratorDenominatorPropertiesSCU are maintained as aliases for limited backward compatibility and will be removed in the next version. Removes enum.Flag from testing as a non-sequitur. (It matches none of the presented protocols.) Introduces __pow__ helper function and renames trunc , floor , and ceil to __trunc__ , __floor__ , and __ceil__ , respectively. Fixes sympy import issue resulting in AttributeError s being thrown on import in some environments.","title":"0.2.0"},{"location":"notes/#011","text":"Removes obsoleted \u2026SCT aliases. Corrects release notes which erroneously identified version 0.1.0 as 0.0.6. Adds enum.IntEnum , enum.IntFlag , and enum.Flag to testing. Merges SupportsFloor and SupportsCeil into SupportsFloorCeil . Gets rid of MANIFEST.in nonsense since we\u2019re not distributing sources via PyPI anymore. Adds a ton of examples to protocol docs. Better identifies false positives in tests.","title":"0.1.1"},{"location":"notes/#010","text":"Adds CachingProtocolMeta.includes , CachingProtocolMeta.excludes , and CachingProtocolMeta.reset_for cache override functions. Retires \u2026SCT tuples as unnecessary, especially in light of cache overrides. (Runtime isinstance protocol checking is fast enough.) For limited backward compatibility, they are now merely type aliases for similarly named protocols and will be removed in the next version. Updates docs. Custom runtime comparison implementation allows composition to lean on base types\u2019 caches. (\u26a0\ufe0f WARNING: Severe jank alert! \u26a0\ufe0f)","title":"0.1.0"},{"location":"notes/#005","text":"Updates license to the MIT License . Gets rid of self redundancy in __isinstance__ checks.","title":"0.0.5"},{"location":"notes/#004","text":"numerary finally leaves the dyce nest to become its own library! It didn\u2019t quite leave before because its maintainer is a bonehead who doesn\u2019t understand setuptools\u2019 multitude of oh-so-simple packaging mechanisms. No, it stuck around most weekends to do laundry while eating all of dyce \u2019s food. Now it has officially left the nest.","title":"0.0.4"},{"location":"numerary/","text":"numerary package reference Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. These are composition protocols that should suit common use cases. IntegralLike ( SupportsAbs , SupportsFloat , SupportsIndex , SupportsInt , SupportsIntegralOps , SupportsIntegralPow , SupportsRealOps , SupportsComplexOps , Protocol ) A caching ABC that defines a core set of operations for interacting with integrals. It is a composition of: SupportsAbs SupportsFloat SupportsIndex SupportsInt SupportsIntegralOps SupportsIntegralPow SupportsRealOps SupportsComplexOps Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from typing import TypeVar from numerary.types import CachingProtocolMeta , Protocol , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class IntegralLike ( SupportsAbs [ T_co ], SupportsFloat , SupportsIndex , SupportsInt , SupportsIntegralOps [ T_co ], SupportsIntegralPow [ T_co ], SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], Protocol [ T_co ], ): pass This is intended as a practically useful, but incomplete list. To enforce equivalence to numbers . Integral , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloorCeil SupportsDivmod SupportsNumeratorDenominator Source code in numerary/types.py @runtime_checkable class IntegralLike ( SupportsAbs [ _T_co ], SupportsFloat , SupportsIndex , SupportsInt , SupportsIntegralOps [ _T_co ], SupportsIntegralPow , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], Protocol [ _T_co ], ): r \"\"\" A caching ABC that defines a core set of operations for interacting with integrals. It is a composition of: * [``SupportsAbs``][numerary.types.SupportsAbs] * [``SupportsFloat``][numerary.types.SupportsFloat] * [``SupportsIndex``][numerary.types.SupportsIndex] * [``SupportsInt``][numerary.types.SupportsInt] * [``SupportsIntegralOps``][numerary.types.SupportsIntegralOps] * [``SupportsIntegralPow``][numerary.types.SupportsIntegralPow] * [``SupportsRealOps``][numerary.types.SupportsRealOps] * [``SupportsComplexOps``][numerary.types.SupportsComplexOps] Basically: ``` python from typing import TypeVar from numerary.types import CachingProtocolMeta, Protocol, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class IntegralLike( SupportsAbs[T_co], SupportsFloat, SupportsIndex, SupportsInt, SupportsIntegralOps[T_co], SupportsIntegralPow[T_co], SupportsRealOps[T_co], SupportsComplexOps[T_co], Protocol[T_co], ): pass ``` This is intended as a practically useful, but incomplete list. To enforce equivalence to ``#!python numbers.Integral``, one would also need: * [``SupportsComplex``][numerary.types.SupportsComplex] * [``SupportsConjugate``][numerary.types.SupportsConjugate] * [``SupportsRealImag``][numerary.types.SupportsRealImag] * [``SupportsRound``][numerary.types.SupportsRound] * [``SupportsTrunc``][numerary.types.SupportsTrunc] * [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil] * [``SupportsDivmod``][numerary.types.SupportsDivmod] * [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator] \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass RealLike ( SupportsAbs , SupportsFloat , SupportsRealOps , SupportsComplexOps , SupportsComplexPow , Protocol ) A caching ABC that defines a core set of operations for interacting with reals. It is a composition of: SupportsAbs SupportsFloat SupportsRealOps SupportsComplexOps SupportsComplexPow Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 from typing import TypeVar from numerary.types import CachingProtocolMeta , Protocol , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class RealLike ( SupportsAbs [ T_co ], SupportsFloat , SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], SupportsComplexPow [ T_co ], Protocol [ T_co ], ): pass This is intended as a practically useful, but incomplete list. To enforce equivalence to numbers . Real , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloorCeil SupportsDivmod Source code in numerary/types.py @runtime_checkable class RealLike ( SupportsAbs [ _T_co ], SupportsFloat , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], SupportsComplexPow , Protocol [ _T_co ], ): r \"\"\" A caching ABC that defines a core set of operations for interacting with reals. It is a composition of: * [``SupportsAbs``][numerary.types.SupportsAbs] * [``SupportsFloat``][numerary.types.SupportsFloat] * [``SupportsRealOps``][numerary.types.SupportsRealOps] * [``SupportsComplexOps``][numerary.types.SupportsComplexOps] * [``SupportsComplexPow``][numerary.types.SupportsComplexPow] Basically: ``` python from typing import TypeVar from numerary.types import CachingProtocolMeta, Protocol, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class RealLike( SupportsAbs[T_co], SupportsFloat, SupportsRealOps[T_co], SupportsComplexOps[T_co], SupportsComplexPow[T_co], Protocol[T_co], ): pass ``` This is intended as a practically useful, but incomplete list. To enforce equivalence to ``#!python numbers.Real``, one would also need: * [``SupportsComplex``][numerary.types.SupportsComplex] * [``SupportsConjugate``][numerary.types.SupportsConjugate] * [``SupportsRealImag``][numerary.types.SupportsRealImag] * [``SupportsRound``][numerary.types.SupportsRound] * [``SupportsTrunc``][numerary.types.SupportsTrunc] * [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil] * [``SupportsDivmod``][numerary.types.SupportsDivmod] \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass","title":"<tt>numerary</tt>"},{"location":"numerary/#numerary-package-reference","text":"Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. These are composition protocols that should suit common use cases.","title":"numerary package reference"},{"location":"numerary/#numerary.types.IntegralLike","text":"A caching ABC that defines a core set of operations for interacting with integrals. It is a composition of: SupportsAbs SupportsFloat SupportsIndex SupportsInt SupportsIntegralOps SupportsIntegralPow SupportsRealOps SupportsComplexOps Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from typing import TypeVar from numerary.types import CachingProtocolMeta , Protocol , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class IntegralLike ( SupportsAbs [ T_co ], SupportsFloat , SupportsIndex , SupportsInt , SupportsIntegralOps [ T_co ], SupportsIntegralPow [ T_co ], SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], Protocol [ T_co ], ): pass This is intended as a practically useful, but incomplete list. To enforce equivalence to numbers . Integral , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloorCeil SupportsDivmod SupportsNumeratorDenominator Source code in numerary/types.py @runtime_checkable class IntegralLike ( SupportsAbs [ _T_co ], SupportsFloat , SupportsIndex , SupportsInt , SupportsIntegralOps [ _T_co ], SupportsIntegralPow , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], Protocol [ _T_co ], ): r \"\"\" A caching ABC that defines a core set of operations for interacting with integrals. It is a composition of: * [``SupportsAbs``][numerary.types.SupportsAbs] * [``SupportsFloat``][numerary.types.SupportsFloat] * [``SupportsIndex``][numerary.types.SupportsIndex] * [``SupportsInt``][numerary.types.SupportsInt] * [``SupportsIntegralOps``][numerary.types.SupportsIntegralOps] * [``SupportsIntegralPow``][numerary.types.SupportsIntegralPow] * [``SupportsRealOps``][numerary.types.SupportsRealOps] * [``SupportsComplexOps``][numerary.types.SupportsComplexOps] Basically: ``` python from typing import TypeVar from numerary.types import CachingProtocolMeta, Protocol, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class IntegralLike( SupportsAbs[T_co], SupportsFloat, SupportsIndex, SupportsInt, SupportsIntegralOps[T_co], SupportsIntegralPow[T_co], SupportsRealOps[T_co], SupportsComplexOps[T_co], Protocol[T_co], ): pass ``` This is intended as a practically useful, but incomplete list. To enforce equivalence to ``#!python numbers.Integral``, one would also need: * [``SupportsComplex``][numerary.types.SupportsComplex] * [``SupportsConjugate``][numerary.types.SupportsConjugate] * [``SupportsRealImag``][numerary.types.SupportsRealImag] * [``SupportsRound``][numerary.types.SupportsRound] * [``SupportsTrunc``][numerary.types.SupportsTrunc] * [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil] * [``SupportsDivmod``][numerary.types.SupportsDivmod] * [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator] \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass","title":"IntegralLike"},{"location":"numerary/#numerary.types.RealLike","text":"A caching ABC that defines a core set of operations for interacting with reals. It is a composition of: SupportsAbs SupportsFloat SupportsRealOps SupportsComplexOps SupportsComplexPow Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 from typing import TypeVar from numerary.types import CachingProtocolMeta , Protocol , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class RealLike ( SupportsAbs [ T_co ], SupportsFloat , SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], SupportsComplexPow [ T_co ], Protocol [ T_co ], ): pass This is intended as a practically useful, but incomplete list. To enforce equivalence to numbers . Real , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloorCeil SupportsDivmod Source code in numerary/types.py @runtime_checkable class RealLike ( SupportsAbs [ _T_co ], SupportsFloat , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], SupportsComplexPow , Protocol [ _T_co ], ): r \"\"\" A caching ABC that defines a core set of operations for interacting with reals. It is a composition of: * [``SupportsAbs``][numerary.types.SupportsAbs] * [``SupportsFloat``][numerary.types.SupportsFloat] * [``SupportsRealOps``][numerary.types.SupportsRealOps] * [``SupportsComplexOps``][numerary.types.SupportsComplexOps] * [``SupportsComplexPow``][numerary.types.SupportsComplexPow] Basically: ``` python from typing import TypeVar from numerary.types import CachingProtocolMeta, Protocol, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class RealLike( SupportsAbs[T_co], SupportsFloat, SupportsRealOps[T_co], SupportsComplexOps[T_co], SupportsComplexPow[T_co], Protocol[T_co], ): pass ``` This is intended as a practically useful, but incomplete list. To enforce equivalence to ``#!python numbers.Real``, one would also need: * [``SupportsComplex``][numerary.types.SupportsComplex] * [``SupportsConjugate``][numerary.types.SupportsConjugate] * [``SupportsRealImag``][numerary.types.SupportsRealImag] * [``SupportsRound``][numerary.types.SupportsRound] * [``SupportsTrunc``][numerary.types.SupportsTrunc] * [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil] * [``SupportsDivmod``][numerary.types.SupportsDivmod] \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass","title":"RealLike"},{"location":"numerary.types/","text":"numerary . types package reference Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. In addition to the following protocols and helper functions, numerary.types also resolves importing Annotated , Protocol , and runtime_checkable from the best available source. This can be helpful if you need to support Python versions prior to 3.9, but don\u2019t want to take a runtime dependency on typing_extensions unless needed. Instead of doing this all over the place \u2026 1 2 3 4 try : from typing import Annotated , Protocol , runtime_checkable except ImportError : from typing_extensions import Annotated , Protocol , runtime_checkable \u2026 you can do this instead \u2026 1 from numerary.types import Annotated , Protocol , runtime_checkable Bang. Done. Further, if you want to opportunistically take advantage of beartype without imposing a strict runtime dependency, you can do this: 1 from numerary.bt import beartype # will resolve to the identity decorator if beartype is unavailable at runtime Which you should totally do, because beartype is awesome . Its author is even awesomer . 1 CachingProtocolMeta ( _ProtocolMeta ) Stand-in for Protocol \u2019s base class that caches results of __instancecheck__ , (which is otherwise really \ud83e\udd2cing expensive ). (When this was introduced, it resulted in about a 5\u00d7 performance increase for dyce \u2019s unit tests, which was the only benchmark I had at the time.) The downside is that this will yield unpredictable results for objects whose methods don\u2019t stem from any type (e.g., are assembled at runtime). I don\u2019t know of any real-world case where that would be true. We\u2019ll jump off that bridge when we come to it. Note that one can make an existing protocol a caching protocol through inheritance, but in order to be @runtime_checkable , the parent protocol also has to be @runtime_checkable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 >>> from abc import abstractmethod >>> from numerary.types import Protocol , runtime_checkable >>> @runtime_checkable ... class _MyProtocol ( Protocol ): # plain vanilla protocol ... @abstractmethod ... def myfunc ( self , arg : int ) -> str : ... pass >>> @runtime_checkable # redundant, but useful for documentation ... class MyProtocol ( ... _MyProtocol , ... Protocol , ... metaclass = CachingProtocolMeta , # caching version ... ): ... pass >>> class MyImplementation : ... def myfunc ( self , arg : int ) -> str : ... return str ( arg * - 2 + 5 ) >>> my_thing : MyProtocol = MyImplementation () >>> isinstance ( my_thing , MyProtocol ) True Source code in numerary/types.py class CachingProtocolMeta ( _ProtocolMeta ): r \"\"\" Stand-in for ``#!python Protocol``\u2019s base class that caches results of ``#!python __instancecheck__``, (which is otherwise [really \ud83e\udd2cing expensive](https://github.com/python/mypy/issues/3186#issuecomment-885718629)). (When this was introduced, it resulted in about a 5\u00d7 performance increase for [``dyce``](https://github.com/posita/dyce)\u2019s unit tests, which was the only benchmark I had at the time.) The downside is that this will yield unpredictable results for objects whose methods don\u2019t stem from any type (e.g., are assembled at runtime). I don\u2019t know of any real-world case where that would be true. We\u2019ll jump off that bridge when we come to it. Note that one can make an existing protocol a caching protocol through inheritance, but in order to be ``@runtime_checkable``, the parent protocol also has to be @runtime_checkable. ``` python >>> from abc import abstractmethod >>> from numerary.types import Protocol, runtime_checkable >>> @runtime_checkable ... class _MyProtocol(Protocol): # plain vanilla protocol ... @abstractmethod ... def myfunc(self, arg: int) -> str: ... pass >>> @runtime_checkable # redundant, but useful for documentation ... class MyProtocol( ... _MyProtocol, ... Protocol, ... metaclass=CachingProtocolMeta, # caching version ... ): ... pass >>> class MyImplementation: ... def myfunc(self, arg: int) -> str: ... return str(arg * -2 + 5) >>> my_thing: MyProtocol = MyImplementation() >>> isinstance(my_thing, MyProtocol) True ``` \"\"\" _abc_inst_check_cache : Dict [ Type , bool ] _abc_inst_check_cache_overridden : Dict [ Type , bool ] _abc_inst_check_cache_listeners : Set [ CachingProtocolMeta ] def __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any , ) -> _TT : # See <https://github.com/python/mypy/issues/9282> cls = super () . __new__ ( mcls , name , bases , namespace , ** kw ) # type: ignore [misc] # Prefixing this class member with \"_abc_\" is necessary to prevent it from being # considered part of the Protocol. (See # <https://github.com/python/cpython/blob/main/Lib/typing.py>.) cls . _abc_inst_check_cache = {} cls . _abc_inst_check_cache_overridden = {} cls . _abc_inst_check_cache_listeners = set () for base in bases : if hasattr ( base , \"_abc_inst_check_cache_listeners\" ): base . _abc_inst_check_cache_listeners . add ( cls ) return cls def __instancecheck__ ( cls , inst : Any ) -> bool : try : # This has to stay *super* tight! Even adding a mere assertion can add ~50% # to the best case runtime! return cls . _abc_inst_check_cache [ type ( inst )] except KeyError : # If you're going to do *anything*, do it here. Don't touch the rest of this # method if you can avoid it. inst_t = type ( inst ) bases_pass_muster = True for base in cls . __bases__ : if base is cls or base . __name__ in ( \"Protocol\" , \"Generic\" , \"object\" ): continue if not isinstance ( inst , base ): bases_pass_muster = False break cls . _abc_inst_check_cache [ inst_t ] = bases_pass_muster and cls . _check_only_my_attrs ( inst ) cls . _abc_inst_check_cache_overridden [ inst_t ] = False return cls . _abc_inst_check_cache [ inst_t ] def includes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsSpam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def spam(self) -> str: ... pass >>> class NoSpam: ... pass >>> isinstance(NoSpam(), SupportsSpam) False >>> SupportsSpam.includes(NoSpam) >>> isinstance(NoSpam(), SupportsSpam) True ``` !!! note This does not affect static type-checking. ``` python >>> my_spam: SupportsSpam = NoSpam() # type: ignore [assignment] # still generates a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = True cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t ) def excludes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsHam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def ham(self) -> str: ... pass >>> class NoHam: ... def ham(self) -> str: ... raise NotImplementedError >>> isinstance(NoHam(), SupportsHam) True >>> SupportsHam.excludes(NoHam) >>> isinstance(NoHam(), SupportsHam) False ``` !!! note This does not affect static type-checking. ``` python >>> my_ham: SupportsHam = NoHam() # does *not* generate a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = False cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t ) def reset_for ( cls , inst_t : Type ) -> None : r \"\"\" Clears any cached instance check for *inst_t*. \"\"\" if inst_t in cls . _abc_inst_check_cache : del cls . _abc_inst_check_cache [ inst_t ] del cls . _abc_inst_check_cache_overridden [ inst_t ] cls . _dirty_for ( inst_t ) def _check_only_my_attrs ( cls , inst : Any ) -> bool : attrs = set ( cls . __dict__ ) attrs . update ( cls . __dict__ . get ( \"__annotations__\" , {})) attrs . intersection_update ( _get_protocol_attrs ( cls )) for attr in attrs : if not hasattr ( inst , attr ): return False elif callable ( getattr ( cls , attr , None )) and getattr ( inst , attr ) is None : return False return True def _dirty_for ( cls , inst_t : Type ) -> None : for inheriting_cls in cls . _abc_inst_check_cache_listeners : if ( inst_t in inheriting_cls . _abc_inst_check_cache and not inheriting_cls . _abc_inst_check_cache_overridden [ inst_t ] ): del inheriting_cls . _abc_inst_check_cache [ inst_t ] del inheriting_cls . _abc_inst_check_cache_overridden [ inst_t ] __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any ) -> _TT special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in numerary/types.py def __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any , ) -> _TT : # See <https://github.com/python/mypy/issues/9282> cls = super () . __new__ ( mcls , name , bases , namespace , ** kw ) # type: ignore [misc] # Prefixing this class member with \"_abc_\" is necessary to prevent it from being # considered part of the Protocol. (See # <https://github.com/python/cpython/blob/main/Lib/typing.py>.) cls . _abc_inst_check_cache = {} cls . _abc_inst_check_cache_overridden = {} cls . _abc_inst_check_cache_listeners = set () for base in bases : if hasattr ( base , \"_abc_inst_check_cache_listeners\" ): base . _abc_inst_check_cache_listeners . add ( cls ) return cls excludes ( cls , inst_t : Type ) -> None Registers inst_t as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsHam ( ... Protocol , ... metaclass = CachingProtocolMeta ... ): ... @abstractmethod ... def ham ( self ) -> str : ... pass >>> class NoHam : ... def ham ( self ) -> str : ... raise NotImplementedError >>> isinstance ( NoHam (), SupportsHam ) True >>> SupportsHam . excludes ( NoHam ) >>> isinstance ( NoHam (), SupportsHam ) False Note This does not affect static type-checking. 1 >>> my_ham : SupportsHam = NoHam () # does *not* generate a Mypy warning Source code in numerary/types.py def excludes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsHam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def ham(self) -> str: ... pass >>> class NoHam: ... def ham(self) -> str: ... raise NotImplementedError >>> isinstance(NoHam(), SupportsHam) True >>> SupportsHam.excludes(NoHam) >>> isinstance(NoHam(), SupportsHam) False ``` !!! note This does not affect static type-checking. ``` python >>> my_ham: SupportsHam = NoHam() # does *not* generate a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = False cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t ) includes ( cls , inst_t : Type ) -> None Registers inst_t as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsSpam ( ... Protocol , ... metaclass = CachingProtocolMeta ... ): ... @abstractmethod ... def spam ( self ) -> str : ... pass >>> class NoSpam : ... pass >>> isinstance ( NoSpam (), SupportsSpam ) False >>> SupportsSpam . includes ( NoSpam ) >>> isinstance ( NoSpam (), SupportsSpam ) True Note This does not affect static type-checking. 1 >>> my_spam : SupportsSpam = NoSpam () # type: ignore [assignment] # still generates a Mypy warning Source code in numerary/types.py def includes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsSpam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def spam(self) -> str: ... pass >>> class NoSpam: ... pass >>> isinstance(NoSpam(), SupportsSpam) False >>> SupportsSpam.includes(NoSpam) >>> isinstance(NoSpam(), SupportsSpam) True ``` !!! note This does not affect static type-checking. ``` python >>> my_spam: SupportsSpam = NoSpam() # type: ignore [assignment] # still generates a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = True cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t ) reset_for ( cls , inst_t : Type ) -> None Clears any cached instance check for inst_t . Source code in numerary/types.py def reset_for ( cls , inst_t : Type ) -> None : r \"\"\" Clears any cached instance check for *inst_t*. \"\"\" if inst_t in cls . _abc_inst_check_cache : del cls . _abc_inst_check_cache [ inst_t ] del cls . _abc_inst_check_cache_overridden [ inst_t ] cls . _dirty_for ( inst_t ) RationalLike ( SupportsAbs , SupportsFloat , SupportsNumeratorDenominator , SupportsRealOps , SupportsComplexOps , SupportsComplexPow , Protocol ) A caching ABC that defines a core set of operations for interacting with rationals. It is a composition of: SupportsAbs SupportsFloat SupportsNumeratorDenominator SupportsRealOps SupportsComplexOps SupportsComplexPow Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from typing import TypeVar from numerary.types import CachingProtocolMeta , Protocol , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class RationalLike ( SupportsAbs [ T_co ], SupportsFloat , SupportsNumeratorDenominator , SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], SupportsComplexPow [ T_co ], Protocol [ T_co ], ): pass This is intended as a practically useful, but incomplete list. To enforce equivalence to numbers . Rational , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloorCeil SupportsDivmod Source code in numerary/types.py @runtime_checkable class RationalLike ( SupportsAbs [ _T_co ], SupportsFloat , SupportsNumeratorDenominator , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], SupportsComplexPow , Protocol [ _T_co ], ): r \"\"\" A caching ABC that defines a core set of operations for interacting with rationals. It is a composition of: * [``SupportsAbs``][numerary.types.SupportsAbs] * [``SupportsFloat``][numerary.types.SupportsFloat] * [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator] * [``SupportsRealOps``][numerary.types.SupportsRealOps] * [``SupportsComplexOps``][numerary.types.SupportsComplexOps] * [``SupportsComplexPow``][numerary.types.SupportsComplexPow] Basically: ``` python from typing import TypeVar from numerary.types import CachingProtocolMeta, Protocol, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class RationalLike( SupportsAbs[T_co], SupportsFloat, SupportsNumeratorDenominator, SupportsRealOps[T_co], SupportsComplexOps[T_co], SupportsComplexPow[T_co], Protocol[T_co], ): pass ``` This is intended as a practically useful, but incomplete list. To enforce equivalence to ``#!python numbers.Rational``, one would also need: * [``SupportsComplex``][numerary.types.SupportsComplex] * [``SupportsConjugate``][numerary.types.SupportsConjugate] * [``SupportsRealImag``][numerary.types.SupportsRealImag] * [``SupportsRound``][numerary.types.SupportsRound] * [``SupportsTrunc``][numerary.types.SupportsTrunc] * [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil] * [``SupportsDivmod``][numerary.types.SupportsDivmod] \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass RationalLikeMethods ( SupportsAbs , SupportsFloat , SupportsNumeratorDenominatorMethods , SupportsRealOps , SupportsComplexOps , SupportsComplexPow , Protocol ) A caching ABC that defines a core set of operations for interacting with rationals. It is identical to RationalLike with one important exception. Instead of SupportsNumeratorDenominator , this protocol provides SupportsNumeratorDenominatorMethods . Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from typing import TypeVar from numerary.types import CachingProtocolMeta , Protocol , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class RationalLikeMethods ( SupportsAbs [ T_co ], SupportsFloat , SupportsNumeratorDenominatorMethods , SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], SupportsComplexPow [ T_co ], Protocol [ T_co ], ): pass This is probably not very useful on its own, but is important to the construction of RationalLikeMixedU and RationalLikeMixedT . See also the numerator and denominator helper functions. 1 2 RationalLikeMixedU = typing . Union [ numerary . types . RationalLike , numerary . types . RationalLikeMethods ] RationalLikeMixedT = ( RationalLike , RationalLikeMethods ) Source code in numerary/types.py @runtime_checkable class RationalLikeMethods ( SupportsAbs [ _T_co ], SupportsFloat , SupportsNumeratorDenominatorMethods , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], SupportsComplexPow , Protocol [ _T_co ], ): r \"\"\" A caching ABC that defines a core set of operations for interacting with rationals. It is identical to [``RationalLike``][numerary.types.RationalLike] with one important exception. Instead of [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator], this protocol provides [``SupportsNumeratorDenominatorMethods``][numerary.types.SupportsNumeratorDenominatorMethods]. Basically: ``` python from typing import TypeVar from numerary.types import CachingProtocolMeta, Protocol, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class RationalLikeMethods( SupportsAbs[T_co], SupportsFloat, SupportsNumeratorDenominatorMethods, SupportsRealOps[T_co], SupportsComplexOps[T_co], SupportsComplexPow[T_co], Protocol[T_co], ): pass ``` This is probably not very useful on its own, but is important to the construction of [``RationalLikeMixedU``][numerary.types.RationalLikeMixedU] and [``RationalLikeMixedT``][numerary.types.RationalLikeMixedT]. See also the [``numerator``][numerary.types.numerator] and [``denominator``][numerary.types.denominator] helper functions. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass SupportsAbs ( SupportsAbs , Protocol ) A caching version of the typing.SupportsAbs ABC defining the __abs__ method with a covariant return value. Source code in numerary/types.py @runtime_checkable class SupportsAbs ( _SupportsAbs [ _T_co ], Protocol [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching version of the [``typing.SupportsAbs``](https://docs.python.org/3/library/typing.html#typing.SupportsAbs) ABC defining the [``__abs__`` method](https://docs.python.org/3/reference/datamodel.html#object.__abs__) with a covariant return value. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsComplex ( SupportsComplex , Protocol ) A caching version of the typing.SupportsComplex ABC defining the __complex__ method . Source code in numerary/types.py @runtime_checkable class SupportsComplex ( _SupportsComplex , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching version of the [``typing.SupportsComplex``](https://docs.python.org/3/library/typing.html#typing.SupportsComplex) ABC defining the [``__complex__`` method](https://docs.python.org/3/reference/datamodel.html#object.__complex__). \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsComplexOps ( _SupportsComplexOps , Protocol ) A caching ABC defining the Complex operator methods with covariant return values. ( _SupportsComplexOps is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsComplexOps >>> MyComplexOpsT = TypeVar ( \"MyComplexOpsT\" , bound = SupportsComplexOps ) >>> def complex_ops_my_thing ( arg : MyComplexOpsT ) -> MyComplexOpsT : ... assert isinstance ( arg , SupportsComplexOps ) ... return arg * - 2 + 5 >>> complex_ops_my_thing ( 3 ) - 1 >>> from decimal import Decimal >>> complex_ops_my_thing ( Decimal ( \"2.5\" )) Decimal ( '0.0' ) >>> import sympy >>> complex_ops_my_thing ( sympy . Float ( 3.5 )) - 2.0 >>> type ( _ ) < class ' sympy . core . numbers . Float '> >>> # error: Value of type variable \"MyComplexOpsT\" of \"complex_ops_my_thing\" cannot be \"str\" >>> complex_ops_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsComplexOps ( _SupportsComplexOps [ _T_co ], Protocol [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``Complex`` operator methods](https://docs.python.org/3/library/numbers.html#numbers.Complex) with covariant return values. ([``_SupportsComplexOps``][numerary.types._SupportsComplexOps] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsComplexOps >>> MyComplexOpsT = TypeVar(\"MyComplexOpsT\", bound=SupportsComplexOps) >>> def complex_ops_my_thing(arg: MyComplexOpsT) -> MyComplexOpsT: ... assert isinstance(arg, SupportsComplexOps) ... return arg * -2 + 5 >>> complex_ops_my_thing(3) -1 >>> from decimal import Decimal >>> complex_ops_my_thing(Decimal(\"2.5\")) Decimal('0.0') >>> import sympy >>> complex_ops_my_thing(sympy.Float(3.5)) -2.0 >>> type(_) <class 'sympy.core.numbers.Float'> >>> # error: Value of type variable \"MyComplexOpsT\" of \"complex_ops_my_thing\" cannot be \"str\" >>> complex_ops_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsComplexPow ( _SupportsComplexPow , Protocol ) A caching ABC defining the Complex (i.e., non-modulo) versions of the __pow__ and __rpow__ . ( _SupportsComplexPow is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsComplexPow >>> MyComplexPowT = TypeVar ( \"MyComplexPowT\" , bound = SupportsComplexPow ) >>> def complex_pow_my_thing ( arg : MyComplexPowT ) -> MyComplexPowT : ... assert isinstance ( arg , SupportsComplexPow ) ... return arg ** - 2 >>> complex_pow_my_thing ( 3 ) 0.1111111111111111 >>> from decimal import Decimal >>> complex_pow_my_thing ( Decimal ( \"2.5\" )) Decimal ( '0.16' ) >>> import sympy >>> complex_pow_my_thing ( sympy . Float ( 3.5 )) 0.0816326530612245 >>> type ( _ ) < class ' sympy . core . numbers . Float '> >>> # error: Value of type variable \"MyComplexPowT\" of \"complex_pow_my_thing\" cannot be \"str\" >>> complex_pow_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsComplexPow ( _SupportsComplexPow , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the ``#!python Complex`` (i.e., non-modulo) versions of the [``__pow__``](https://docs.python.org/3/reference/datamodel.html#object.__pow__) and [``__rpow__``](https://docs.python.org/3/reference/datamodel.html#object.__rpow__). ([``_SupportsComplexPow``][numerary.types._SupportsComplexPow] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsComplexPow >>> MyComplexPowT = TypeVar(\"MyComplexPowT\", bound=SupportsComplexPow) >>> def complex_pow_my_thing(arg: MyComplexPowT) -> MyComplexPowT: ... assert isinstance(arg, SupportsComplexPow) ... return arg ** -2 >>> complex_pow_my_thing(3) 0.1111111111111111 >>> from decimal import Decimal >>> complex_pow_my_thing(Decimal(\"2.5\")) Decimal('0.16') >>> import sympy >>> complex_pow_my_thing(sympy.Float(3.5)) 0.0816326530612245 >>> type(_) <class 'sympy.core.numbers.Float'> >>> # error: Value of type variable \"MyComplexPowT\" of \"complex_pow_my_thing\" cannot be \"str\" >>> complex_pow_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsConjugate ( _SupportsConjugate , Protocol ) A caching ABC defining the conjugate method . ( _SupportsConjugate is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import TypeVar >>> from numerary.types import SupportsConjugate >>> MyConjugateT = TypeVar ( \"MyConjugateT\" , bound = SupportsConjugate ) >>> def conjugate_my_thing ( arg : MyConjugateT ) -> MyConjugateT : ... assert isinstance ( arg , SupportsConjugate ) ... return arg . conjugate () >>> conjugate_my_thing ( 3 ) 3 >>> from decimal import Decimal >>> conjugate_my_thing ( Decimal ( 2.5 )) Decimal ( '2.5' ) >>> import sympy >>> conjugate_my_thing ( sympy . Float ( 3.5 )) 3.5 >>> type ( _ ) < class ' sympy . core . numbers . Float '> >>> # error: Value of type variable \"MyConjugateT\" of \"conjugate_my_thing\" cannot be \"str\" >>> conjugate_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsConjugate ( _SupportsConjugate , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``conjugate`` method](https://docs.python.org/3/library/numbers.html#numbers.Complex.conjugate). ([``_SupportsConjugate``][numerary.types._SupportsConjugate] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import TypeVar >>> from numerary.types import SupportsConjugate >>> MyConjugateT = TypeVar(\"MyConjugateT\", bound=SupportsConjugate) >>> def conjugate_my_thing(arg: MyConjugateT) -> MyConjugateT: ... assert isinstance(arg, SupportsConjugate) ... return arg.conjugate() >>> conjugate_my_thing(3) 3 >>> from decimal import Decimal >>> conjugate_my_thing(Decimal(2.5)) Decimal('2.5') >>> import sympy >>> conjugate_my_thing(sympy.Float(3.5)) 3.5 >>> type(_) <class 'sympy.core.numbers.Float'> >>> # error: Value of type variable \"MyConjugateT\" of \"conjugate_my_thing\" cannot be \"str\" >>> conjugate_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsDivmod ( _SupportsDivmod , Protocol ) A caching ABC defining the __divmod__ and __rdivmod__ methods. Each returns a 2-tuple of covariants. ( _SupportsDivmod is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsDivmod >>> MyDivmodT = TypeVar ( \"MyDivmodT\" , bound = SupportsDivmod ) >>> def divmod_my_thing ( arg : MyDivmodT , other : Any ) -> Tuple [ MyDivmodT , MyDivmodT ]: ... assert isinstance ( arg , SupportsDivmod ) ... return divmod ( arg , other ) >>> divmod_my_thing ( 2 , 1 ) ( 2 , 0 ) >>> from decimal import Decimal >>> divmod_my_thing ( Decimal ( 2.5 ), Decimal ( 1.5 )) ( Decimal ( '1' ), Decimal ( '1.0' )) >>> import sympy >>> divmod_my_thing ( sympy . Float ( 3.5 ), sympy . Float ( 1.5 )) ( 2 , 0.5 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' sympy . core . numbers . Integer '>, <class ' sympy . core . numbers . Float '>) >>> # error: Value of type variable \"MyDivmodT\" of \"divmod_my_thing\" cannot be \"str\" >>> divmod_my_thing ( \"not-a-number\" , \"still-not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsDivmod ( _SupportsDivmod [ _T_co ], Protocol [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``__divmod__``](https://docs.python.org/3/reference/datamodel.html#object.__divmod__) and [``__rdivmod__``](https://docs.python.org/3/reference/datamodel.html#object.__rdivmod__) methods. Each returns a 2-tuple of covariants. ([``_SupportsDivmod``][numerary.types._SupportsDivmod] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsDivmod >>> MyDivmodT = TypeVar(\"MyDivmodT\", bound=SupportsDivmod) >>> def divmod_my_thing(arg: MyDivmodT, other: Any) -> Tuple[MyDivmodT, MyDivmodT]: ... assert isinstance(arg, SupportsDivmod) ... return divmod(arg, other) >>> divmod_my_thing(2, 1) (2, 0) >>> from decimal import Decimal >>> divmod_my_thing(Decimal(2.5), Decimal(1.5)) (Decimal('1'), Decimal('1.0')) >>> import sympy >>> divmod_my_thing(sympy.Float(3.5), sympy.Float(1.5)) (2, 0.5) >>> tuple(type(i) for i in _) (<class 'sympy.core.numbers.Integer'>, <class 'sympy.core.numbers.Float'>) >>> # error: Value of type variable \"MyDivmodT\" of \"divmod_my_thing\" cannot be \"str\" >>> divmod_my_thing(\"not-a-number\", \"still-not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsFloat ( SupportsFloat , Protocol ) A caching version of the typing.SupportsFloat ABC defining the __float__ method . Source code in numerary/types.py @runtime_checkable class SupportsFloat ( _SupportsFloat , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching version of the [``typing.SupportsFloat``](https://docs.python.org/3/library/typing.html#typing.SupportsFloat) ABC defining the [``__float__`` method](https://docs.python.org/3/reference/datamodel.html#object.__float__). \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsFloorCeil ( _SupportsFloorCeil , Protocol ) A caching ABC defining the __floor__ . and __ceil__ methods. ( _SupportsFloorCeil is the raw, non-caching version that defines the actual methods.) Note This is of limited value for Python versions prior to 3.9, since float . __floor__ and float . __ceil__ were not defined. If support for those environments is important, consider using SupportsFloat instead. See also the __floor__ and __ceil__ helper functions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsFloorCeil , __ceil__ , __floor__ >>> MyFloorCeilT = TypeVar ( \"MyFloorCeilT\" , bound = SupportsFloorCeil ) >>> def floor_ceil_my_thing ( arg : MyFloorCeilT ) -> Tuple [ int , int ]: ... assert isinstance ( arg , SupportsFloorCeil ) ... return __floor__ ( arg ), __ceil__ ( arg ) >>> floor_ceil_my_thing ( 3 ) ( 3 , 3 ) >>> from decimal import Decimal >>> floor_ceil_my_thing ( Decimal ( 2.5 )) ( 2 , 3 ) >>> import sympy >>> floor_ceil_my_thing ( sympy . Float ( 3.5 )) ( 3 , 4 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' sympy . core . numbers . Integer '>, <class ' sympy . core . numbers . Integer '>) >>> # error: Value of type variable \"MyFloorCeilT\" of \"floor_ceil_my_thing\" cannot be \"str\" >>> floor_ceil_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsFloorCeil ( _SupportsFloorCeil , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``__floor__``](https://docs.python.org/3/reference/datamodel.html#object.__floor__). and [``__ceil__``](https://docs.python.org/3/reference/datamodel.html#object.__ceil__) methods. ([``_SupportsFloorCeil``][numerary.types._SupportsFloorCeil] is the raw, non-caching version that defines the actual methods.) !!! note This is of limited value for Python versions prior to 3.9, since ``#!python float.__floor__`` and ``#!python float.__ceil__`` were not defined. If support for those environments is important, consider using [``SupportsFloat``][numerary.types.SupportsFloat] instead. See also the [``__floor__``][numerary.types.__floor__] and [``__ceil__``][numerary.types.__ceil__] helper functions. ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsFloorCeil, __ceil__, __floor__ >>> MyFloorCeilT = TypeVar(\"MyFloorCeilT\", bound=SupportsFloorCeil) >>> def floor_ceil_my_thing(arg: MyFloorCeilT) -> Tuple[int, int]: ... assert isinstance(arg, SupportsFloorCeil) ... return __floor__(arg), __ceil__(arg) >>> floor_ceil_my_thing(3) (3, 3) >>> from decimal import Decimal >>> floor_ceil_my_thing(Decimal(2.5)) (2, 3) >>> import sympy >>> floor_ceil_my_thing(sympy.Float(3.5)) (3, 4) >>> tuple(type(i) for i in _) (<class 'sympy.core.numbers.Integer'>, <class 'sympy.core.numbers.Integer'>) >>> # error: Value of type variable \"MyFloorCeilT\" of \"floor_ceil_my_thing\" cannot be \"str\" >>> floor_ceil_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsIndex ( SupportsIndex , Protocol ) A caching version of the typing.SupportsIndex ABC defining the __index__ method . Source code in numerary/types.py @runtime_checkable class SupportsIndex ( _SupportsIndex , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching version of the [``typing.SupportsIndex``](https://docs.python.org/3/library/typing.html#typing.SupportsIndex) ABC defining the [``__index__`` method](https://docs.python.org/3/reference/datamodel.html#object.__index__). \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsInt ( SupportsInt , Protocol ) A caching version of the typing.SupportsInt ABC defining the __int__ method . Source code in numerary/types.py @runtime_checkable class SupportsInt ( _SupportsInt , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching version of the [``typing.SupportsInt``](https://docs.python.org/3/library/typing.html#typing.SupportsInt) ABC defining the [``__int__`` method](https://docs.python.org/3/reference/datamodel.html#object.__int__). \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsIntegralOps ( _SupportsIntegralOps , Protocol ) A caching ABC defining the Integral operator methods with covariant return values. ( _SupportsIntegralOps is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsIntegralOps >>> MyIntegralOpsT = TypeVar ( \"MyIntegralOpsT\" , bound = SupportsIntegralOps ) >>> def integral_ops_my_thing ( arg : MyIntegralOpsT ) -> MyIntegralOpsT : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg << 1 >>> integral_ops_my_thing ( 3 ) 6 >>> import sympy >>> integral_ops_my_thing ( sympy . Integer ( 3 )) 6 >>> type ( _ ) < class ' sympy . core . numbers . Integer '> >>> # error: Value of type variable \"MyIntegralOpsT\" of \"integral_ops_my_thing\" cannot be \"str\" >>> integral_ops_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsIntegralOps ( _SupportsIntegralOps [ _T_co ], Protocol [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``Integral`` operator methods](https://docs.python.org/3/library/numbers.html#numbers.Integral) with covariant return values. ([``_SupportsIntegralOps``][numerary.types._SupportsIntegralOps] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsIntegralOps >>> MyIntegralOpsT = TypeVar(\"MyIntegralOpsT\", bound=SupportsIntegralOps) >>> def integral_ops_my_thing(arg: MyIntegralOpsT) -> MyIntegralOpsT: ... assert isinstance(arg, SupportsIntegralOps) ... return arg << 1 >>> integral_ops_my_thing(3) 6 >>> import sympy >>> integral_ops_my_thing(sympy.Integer(3)) 6 >>> type(_) <class 'sympy.core.numbers.Integer'> >>> # error: Value of type variable \"MyIntegralOpsT\" of \"integral_ops_my_thing\" cannot be \"str\" >>> integral_ops_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsIntegralPow ( _SupportsIntegralPow , Protocol ) A caching ABC defining the Integral (i.e., modulo) versions of the __pow__ and __rpow__ methods. ( _SupportsIntegralPow is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsIntegralPow >>> MyIntegralPowT = TypeVar ( \"MyIntegralPowT\" , bound = SupportsIntegralPow ) >>> def integral_pow_my_thing ( arg : MyIntegralPowT ) -> MyIntegralPowT : ... assert isinstance ( arg , SupportsIntegralPow ) ... return pow ( arg , 2 , 2 ) >>> integral_pow_my_thing ( 3 ) 1 >>> import sympy >>> integral_pow_my_thing ( sympy . Integer ( 3 )) 1 >>> type ( _ ) < class ' int '> >>> # error: Value of type variable \"MyIntegralPowT\" of \"integral_pow_my_thing\" cannot be \"str\" >>> integral_pow_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsIntegralPow ( _SupportsIntegralPow , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the ``#!python Integral`` (i.e., modulo) versions of the [``__pow__``](https://docs.python.org/3/reference/datamodel.html#object.__pow__) and [``__rpow__``](https://docs.python.org/3/reference/datamodel.html#object.__rpow__) methods. ([``_SupportsIntegralPow``][numerary.types._SupportsIntegralPow] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsIntegralPow >>> MyIntegralPowT = TypeVar(\"MyIntegralPowT\", bound=SupportsIntegralPow) >>> def integral_pow_my_thing(arg: MyIntegralPowT) -> MyIntegralPowT: ... assert isinstance(arg, SupportsIntegralPow) ... return pow(arg, 2, 2) >>> integral_pow_my_thing(3) 1 >>> import sympy >>> integral_pow_my_thing(sympy.Integer(3)) 1 >>> type(_) <class 'int'> >>> # error: Value of type variable \"MyIntegralPowT\" of \"integral_pow_my_thing\" cannot be \"str\" >>> integral_pow_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsNumeratorDenominator ( _SupportsNumeratorDenominator , Protocol ) A caching ABC defining the numerator and denominator properties. ( _SupportsNumeratorDenominator is the raw, non-caching version that defines the actual properties.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsNumeratorDenominator , denominator , numerator >>> MyNumDenomT = TypeVar ( \"MyNumDenomT\" , bound = SupportsNumeratorDenominator ) >>> def num_denom_my_thing ( arg : MyNumDenomT ) -> Tuple [ int , int ]: ... assert isinstance ( arg , SupportsNumeratorDenominator ) ... return numerator ( arg ), denominator ( arg ) >>> num_denom_my_thing ( 3 ) ( 3 , 1 ) >>> from fractions import Fraction >>> num_denom_my_thing ( Fraction ( 2 , 3 )) ( 2 , 3 ) >>> import sympy >>> num_denom_my_thing ( sympy . Rational ( 3 , 4 )) ( 3 , 4 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' int '>, <class ' int '>) >>> # error: Value of type variable \"MyNumDenomT\" of \"num_denom_my_thing\" cannot be \"str\" >>> num_denom_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsNumeratorDenominator ( _SupportsNumeratorDenominator , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``numerator``](https://docs.python.org/3/library/numbers.html#numbers.Rational.numerator) and [``denominator``](https://docs.python.org/3/library/numbers.html#numbers.Rational.denominator) properties. ([``_SupportsNumeratorDenominator``][numerary.types._SupportsNumeratorDenominator] is the raw, non-caching version that defines the actual properties.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsNumeratorDenominator, denominator, numerator >>> MyNumDenomT = TypeVar(\"MyNumDenomT\", bound=SupportsNumeratorDenominator) >>> def num_denom_my_thing(arg: MyNumDenomT) -> Tuple[int, int]: ... assert isinstance(arg, SupportsNumeratorDenominator) ... return numerator(arg), denominator(arg) >>> num_denom_my_thing(3) (3, 1) >>> from fractions import Fraction >>> num_denom_my_thing(Fraction(2, 3)) (2, 3) >>> import sympy >>> num_denom_my_thing(sympy.Rational(3, 4)) (3, 4) >>> tuple(type(i) for i in _) (<class 'int'>, <class 'int'>) >>> # error: Value of type variable \"MyNumDenomT\" of \"num_denom_my_thing\" cannot be \"str\" >>> num_denom_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsNumeratorDenominatorMethods ( _SupportsNumeratorDenominatorMethods , Protocol ) A caching ABC defining numerator and denominator methods. Each returns a SupportsInt . ( _SupportsNumeratorDenominatorMethods is the raw, non-caching version that defines the actual methods.) See also the numerator and denominator helper functions. Source code in numerary/types.py @runtime_checkable class SupportsNumeratorDenominatorMethods ( _SupportsNumeratorDenominatorMethods , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining ``#!python numerator`` and ``#!python denominator`` methods. Each returns a [``SupportsInt``][numerary.types.SupportsInt]. ([``_SupportsNumeratorDenominatorMethods``][numerary.types._SupportsNumeratorDenominatorMethods] is the raw, non-caching version that defines the actual methods.) See also the [``numerator``][numerary.types.numerator] and [``denominator``][numerary.types.denominator] helper functions. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsRealImag ( _SupportsRealImag , Protocol ) A caching ABC defining the real and imag properties. ( _SupportsRealImag is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsRealImag , real , imag >>> MyRealImagT = TypeVar ( \"MyRealImagT\" , bound = SupportsRealImag ) >>> def real_imag_my_thing ( arg : MyRealImagT ) -> Tuple [ Any , Any ]: ... assert isinstance ( arg , SupportsRealImag ) ... return ( real ( arg ), imag ( arg )) >>> real_imag_my_thing ( 3 ) ( 3 , 0 ) >>> from decimal import Decimal >>> real_imag_my_thing ( Decimal ( 2.5 )) ( Decimal ( '2.5' ), Decimal ( '0' )) >>> # error: Value of type variable \"MyRealImagT\" of \"real_imag_my_thing\" cannot be \"str\" >>> real_imag_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsRealImag ( _SupportsRealImag , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``real``](https://docs.python.org/3/library/numbers.html#numbers.Complex.real) and [``imag``](https://docs.python.org/3/library/numbers.html#numbers.Complex.imag) properties. ([``_SupportsRealImag``][numerary.types._SupportsRealImag] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsRealImag, real, imag >>> MyRealImagT = TypeVar(\"MyRealImagT\", bound=SupportsRealImag) >>> def real_imag_my_thing(arg: MyRealImagT) -> Tuple[Any, Any]: ... assert isinstance(arg, SupportsRealImag) ... return (real(arg), imag(arg)) >>> real_imag_my_thing(3) (3, 0) >>> from decimal import Decimal >>> real_imag_my_thing(Decimal(2.5)) (Decimal('2.5'), Decimal('0')) >>> # error: Value of type variable \"MyRealImagT\" of \"real_imag_my_thing\" cannot be \"str\" >>> real_imag_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsRealImagAsMethod ( _SupportsRealImagAsMethod , Protocol ) A caching ABC defining the as_real_imag method that returns a 2-tuple. ( _SupportsRealImagAsMethod is the raw, non-caching version that defines the actual methods.) See also the real and imag helper functions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsRealImagAsMethod , real , imag >>> MyRealImagAsMethodT = TypeVar ( \"MyRealImagAsMethodT\" , bound = SupportsRealImagAsMethod ) >>> def as_real_imag_my_thing ( arg : MyRealImagAsMethodT ) -> Tuple [ Any , Any ]: ... assert isinstance ( arg , SupportsRealImagAsMethod ) ... return ( real ( arg ), imag ( arg )) >>> as_real_imag_my_thing ( sympy . Float ( 3.5 )) ( 3.5 , 0 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' sympy . core . numbers . Float '>, <class ' sympy . core . numbers . Zero '>) >>> # error: Value of type variable \"MyRealImagAsMethodT\" of \"as_real_imag_my_thing\" cannot be \"str\" >>> as_real_imag_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsRealImagAsMethod ( _SupportsRealImagAsMethod , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the ``#!python as_real_imag`` method that returns a 2-tuple. ([``_SupportsRealImagAsMethod``][numerary.types._SupportsRealImagAsMethod] is the raw, non-caching version that defines the actual methods.) See also the [``real``][numerary.types.real] and [``imag``][numerary.types.imag] helper functions. ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsRealImagAsMethod, real, imag >>> MyRealImagAsMethodT = TypeVar(\"MyRealImagAsMethodT\", bound=SupportsRealImagAsMethod) >>> def as_real_imag_my_thing(arg: MyRealImagAsMethodT) -> Tuple[Any, Any]: ... assert isinstance(arg, SupportsRealImagAsMethod) ... return (real(arg), imag(arg)) >>> as_real_imag_my_thing(sympy.Float(3.5)) (3.5, 0) >>> tuple(type(i) for i in _) (<class 'sympy.core.numbers.Float'>, <class 'sympy.core.numbers.Zero'>) >>> # error: Value of type variable \"MyRealImagAsMethodT\" of \"as_real_imag_my_thing\" cannot be \"str\" >>> as_real_imag_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsRealOps ( _SupportsRealOps , Protocol ) A caching ABC defining the Real operator methods with covariant return values. ( _SupportsRealOps is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsRealOps >>> MyRealOpsT = TypeVar ( \"MyRealOpsT\" , bound = SupportsRealOps ) >>> def real_ops_my_thing ( arg : MyRealOpsT ) -> Any : ... assert isinstance ( arg , SupportsRealOps ) ... return arg // - 2 >>> real_ops_my_thing ( 3 ) - 2 >>> from decimal import Decimal >>> real_ops_my_thing ( Decimal ( \"2.5\" )) Decimal ( '-1' ) >>> import sympy >>> real_ops_my_thing ( sympy . Float ( 3.5 )) - 2 >>> type ( _ ) < class ' sympy . core . numbers . Integer '> >>> # error: Value of type variable \"MyRealOpsT\" of \"real_ops_my_thing\" cannot be \"str\" >>> real_ops_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsRealOps ( _SupportsRealOps [ _T_co ], Protocol [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``Real`` operator methods](https://docs.python.org/3/library/numbers.html#numbers.Real) with covariant return values. ([``_SupportsRealOps``][numerary.types._SupportsRealOps] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsRealOps >>> MyRealOpsT = TypeVar(\"MyRealOpsT\", bound=SupportsRealOps) >>> def real_ops_my_thing(arg: MyRealOpsT) -> Any: ... assert isinstance(arg, SupportsRealOps) ... return arg // -2 >>> real_ops_my_thing(3) -2 >>> from decimal import Decimal >>> real_ops_my_thing(Decimal(\"2.5\")) Decimal('-1') >>> import sympy >>> real_ops_my_thing(sympy.Float(3.5)) -2 >>> type(_) <class 'sympy.core.numbers.Integer'> >>> # error: Value of type variable \"MyRealOpsT\" of \"real_ops_my_thing\" cannot be \"str\" >>> real_ops_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsRound ( SupportsRound , Protocol ) A caching version of the typing.SupportsRound ABC defining the __round__ method with a covariant return value. Source code in numerary/types.py @runtime_checkable class SupportsRound ( _SupportsRound [ _T_co ], Protocol [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching version of the [``typing.SupportsRound``](https://docs.python.org/3/library/typing.html#typing.SupportsRound) ABC defining the [``__round__`` method](https://docs.python.org/3/reference/datamodel.html#object.__round__) with a covariant return value. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () SupportsTrunc ( _SupportsTrunc , Protocol ) A caching ABC defining the __trunc__ method . See also the __trunc__ helper function . ( _SupportsTrunc is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsTrunc , __trunc__ >>> MyTruncT = TypeVar ( \"MyTruncT\" , bound = SupportsTrunc ) >>> def trunc_my_thing ( arg : MyTruncT ) -> Tuple [ Any , Any ]: ... assert isinstance ( arg , SupportsTrunc ) ... return __trunc__ ( arg ) >>> trunc_my_thing ( 3 ) 3 >>> from decimal import Decimal >>> trunc_my_thing ( Decimal ( 2.5 )) 2 >>> import sympy >>> trunc_my_thing ( sympy . Float ( 3.5 )) 3 >>> type ( _ ) < class ' sympy . core . numbers . Integer '> >>> # error: Value of type variable \"MyTruncT\" of \"trunc_my_thing\" cannot be \"str\" >>> trunc_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsTrunc ( _SupportsTrunc , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``__trunc__`` method](https://docs.python.org/3/reference/datamodel.html#object.__trunc__). See also the [``__trunc__`` helper function][numerary.types.__trunc__]. ([``_SupportsTrunc``][numerary.types._SupportsTrunc] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsTrunc, __trunc__ >>> MyTruncT = TypeVar(\"MyTruncT\", bound=SupportsTrunc) >>> def trunc_my_thing(arg: MyTruncT) -> Tuple[Any, Any]: ... assert isinstance(arg, SupportsTrunc) ... return __trunc__(arg) >>> trunc_my_thing(3) 3 >>> from decimal import Decimal >>> trunc_my_thing(Decimal(2.5)) 2 >>> import sympy >>> trunc_my_thing(sympy.Float(3.5)) 3 >>> type(_) <class 'sympy.core.numbers.Integer'> >>> # error: Value of type variable \"MyTruncT\" of \"trunc_my_thing\" cannot be \"str\" >>> trunc_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () __ceil__ ( operand : Union [ SupportsFloat , SupportsFloorCeil ]) Helper function that wraps math.ceil . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsFloorCeil , __ceil__ >>> my_ceil : SupportsFloorCeil >>> my_ceil = 1 >>> __ceil__ ( my_ceil ) 1 >>> from fractions import Fraction >>> my_ceil = Fraction ( 1 , 2 ) >>> __ceil__ ( my_ceil ) 1 >>> my_ceil_float : SupportsFloat = 1.2 >>> __ceil__ ( my_ceil_float ) 2 Source code in numerary/types.py @beartype def __ceil__ ( operand : Union [ SupportsFloat , SupportsFloorCeil ]): r \"\"\" Helper function that wraps ``math.ceil``. ``` python >>> from numerary.types import SupportsFloat, SupportsFloorCeil, __ceil__ >>> my_ceil: SupportsFloorCeil >>> my_ceil = 1 >>> __ceil__(my_ceil) 1 >>> from fractions import Fraction >>> my_ceil = Fraction(1, 2) >>> __ceil__(my_ceil) 1 >>> my_ceil_float: SupportsFloat = 1.2 >>> __ceil__(my_ceil_float) 2 ``` \"\"\" return math . ceil ( operand ) # type: ignore [arg-type] __floor__ ( operand : Union [ SupportsFloat , SupportsFloorCeil ]) Helper function that wraps math.floor . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsFloorCeil , __floor__ >>> my_floor : SupportsFloorCeil >>> my_floor = 1 >>> __floor__ ( my_floor ) 1 >>> from fractions import Fraction >>> my_floor = Fraction ( 1 , 2 ) >>> __floor__ ( my_floor ) 0 >>> my_floor_float : SupportsFloat = 1.2 >>> __floor__ ( my_floor_float ) 1 Source code in numerary/types.py @beartype def __floor__ ( operand : Union [ SupportsFloat , SupportsFloorCeil ]): r \"\"\" Helper function that wraps ``math.floor``. ``` python >>> from numerary.types import SupportsFloat, SupportsFloorCeil, __floor__ >>> my_floor: SupportsFloorCeil >>> my_floor = 1 >>> __floor__(my_floor) 1 >>> from fractions import Fraction >>> my_floor = Fraction(1, 2) >>> __floor__(my_floor) 0 >>> my_floor_float: SupportsFloat = 1.2 >>> __floor__(my_floor_float) 1 ``` \"\"\" return math . floor ( operand ) # type: ignore [arg-type] __pow__ ( arg : Union [ SupportsComplexPow , SupportsIntegralPow ], exponent : Any , modulus : Optional [ Any ] = None ) -> Any Helper function that wraps pow to work with SupportsComplexPow , SupportsIntegralPow . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 >>> from numerary.types import SupportsComplexPow , SupportsIntegralPow , __pow__ >>> my_complex_pow : SupportsComplexPow = complex ( 2 ) >>> __pow__ ( my_complex_pow , 1 ) ( 2 + 0 j ) >>> __pow__ ( my_complex_pow , 1 , None ) ( 2 + 0 j ) >>> __pow__ ( my_complex_pow , 1 , 1 ) # type: ignore [operator] # properly caught by Mypy Traceback ( most recent call last ): ... ValueError : complex modulo >>> my_complex_pow = 1.2 >>> __pow__ ( my_complex_pow , 1 ) 1.2 >>> __pow__ ( my_complex_pow , 1 , None ) 1.2 >>> __pow__ ( my_complex_pow , 1 , 1 ) # ugh; *not* caught by Mypy because it treats floats as equivalent to ints? Traceback ( most recent call last ): ... TypeError : pow () 3 rd argument not allowed unless all arguments are integers >>> from fractions import Fraction >>> my_complex_pow = Fraction ( 1 , 2 ) >>> __pow__ ( my_complex_pow , 1 ) Fraction ( 1 , 2 ) >>> __pow__ ( my_complex_pow , 1 , None ) Fraction ( 1 , 2 ) >>> __pow__ ( my_complex_pow , 1 , 1 ) # type: ignore [operator] # properly caught by Mypy Traceback ( most recent call last ): ... TypeError : __pow__ () takes 2 positional arguments but 3 were given >>> from decimal import Decimal >>> my_integral_pow : SupportsIntegralPow = Decimal ( \"2\" ) >>> __pow__ ( my_integral_pow , 1 ) Decimal ( '2' ) >>> __pow__ ( my_integral_pow , 1 , None ) Decimal ( '2' ) >>> __pow__ ( my_integral_pow , 1 , 2 ) Decimal ( '0' ) >>> my_integral_pow = Decimal ( \"1.2\" ) # ruh-roh >>> __pow__ ( my_integral_pow , 1 ) Decimal ( '1.2' ) >>> __pow__ ( my_integral_pow , 1 , None ) Decimal ( '1.2' ) >>> __pow__ ( my_integral_pow , 1 , 2 ) # not catchable by Mypy, since it works *some* of the time Traceback ( most recent call last ): ... decimal . InvalidOperation : [ < class ' decimal . InvalidOperation '>] >>> my_integral_pow = 2 >>> __pow__ ( my_integral_pow , 1 ) 2 >>> __pow__ ( my_integral_pow , 1 , None ) 2 >>> __pow__ ( my_integral_pow , 1 , 2 ) 0 Source code in numerary/types.py @beartype def __pow__ ( arg : Union [ SupportsComplexPow , SupportsIntegralPow ], exponent : Any , modulus : Optional [ Any ] = None , ) -> Any : r \"\"\" Helper function that wraps ``pow`` to work with [``SupportsComplexPow``][numerary.types.SupportsComplexPow], [``SupportsIntegralPow``][numerary.types.SupportsIntegralPow]. ``` python >>> from numerary.types import SupportsComplexPow, SupportsIntegralPow, __pow__ >>> my_complex_pow: SupportsComplexPow = complex(2) >>> __pow__(my_complex_pow, 1) (2+0j) >>> __pow__(my_complex_pow, 1, None) (2+0j) >>> __pow__(my_complex_pow, 1, 1) # type: ignore [operator] # properly caught by Mypy Traceback (most recent call last): ... ValueError: complex modulo >>> my_complex_pow = 1.2 >>> __pow__(my_complex_pow, 1) 1.2 >>> __pow__(my_complex_pow, 1, None) 1.2 >>> __pow__(my_complex_pow, 1, 1) # ugh; *not* caught by Mypy because it treats floats as equivalent to ints? Traceback (most recent call last): ... TypeError: pow() 3rd argument not allowed unless all arguments are integers >>> from fractions import Fraction >>> my_complex_pow = Fraction(1, 2) >>> __pow__(my_complex_pow, 1) Fraction(1, 2) >>> __pow__(my_complex_pow, 1, None) Fraction(1, 2) >>> __pow__(my_complex_pow, 1, 1) # type: ignore [operator] # properly caught by Mypy Traceback (most recent call last): ... TypeError: __pow__() takes 2 positional arguments but 3 were given >>> from decimal import Decimal >>> my_integral_pow: SupportsIntegralPow = Decimal(\"2\") >>> __pow__(my_integral_pow, 1) Decimal('2') >>> __pow__(my_integral_pow, 1, None) Decimal('2') >>> __pow__(my_integral_pow, 1, 2) Decimal('0') >>> my_integral_pow = Decimal(\"1.2\") # ruh-roh >>> __pow__(my_integral_pow, 1) Decimal('1.2') >>> __pow__(my_integral_pow, 1, None) Decimal('1.2') >>> __pow__(my_integral_pow, 1, 2) # not catchable by Mypy, since it works *some* of the time Traceback (most recent call last): ... decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>] >>> my_integral_pow = 2 >>> __pow__(my_integral_pow, 1) 2 >>> __pow__(my_integral_pow, 1, None) 2 >>> __pow__(my_integral_pow, 1, 2) 0 ``` \"\"\" return pow ( arg , exponent , modulus ) __trunc__ ( operand : Union [ SupportsFloat , SupportsTrunc ]) Helper function that wraps math.trunc . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsTrunc , __trunc__ >>> my_trunc : SupportsTrunc >>> my_trunc = 1 >>> __trunc__ ( my_trunc ) 1 >>> from fractions import Fraction >>> my_trunc = Fraction ( 1 , 2 ) >>> __trunc__ ( my_trunc ) 0 >>> my_trunc_float : SupportsFloat = 1.2 >>> __trunc__ ( my_trunc_float ) 1 Source code in numerary/types.py @beartype def __trunc__ ( operand : Union [ SupportsFloat , SupportsTrunc ]): r \"\"\" Helper function that wraps ``math.trunc``. ``` python >>> from numerary.types import SupportsFloat, SupportsTrunc, __trunc__ >>> my_trunc: SupportsTrunc >>> my_trunc = 1 >>> __trunc__(my_trunc) 1 >>> from fractions import Fraction >>> my_trunc = Fraction(1, 2) >>> __trunc__(my_trunc) 0 >>> my_trunc_float: SupportsFloat = 1.2 >>> __trunc__(my_trunc_float) 1 ``` \"\"\" return math . trunc ( operand ) # type: ignore [arg-type] denominator ( operand : SupportsNumeratorDenominatorMixedU ) Helper function that extracts the denominator from operand including resolving non-compliant rational implementations that implement denominator as a method rather than a property. 1 2 3 4 >>> from fractions import Fraction >>> from numerary.types import denominator >>> denominator ( Fraction ( 22 , 7 )) 7 See SupportsNumeratorDenominator and SupportsNumeratorDenominatorMethods . Source code in numerary/types.py @beartype def denominator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" Helper function that extracts the denominator from *operand* including resolving non-compliant rational implementations that implement ``denominator`` as a method rather than a property. ``` python >>> from fractions import Fraction >>> from numerary.types import denominator >>> denominator(Fraction(22, 7)) 7 ``` See [SupportsNumeratorDenominator][numerary.types.SupportsNumeratorDenominator] and [SupportsNumeratorDenominatorMethods][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" if hasattr ( operand , \"denominator\" ): if callable ( operand . denominator ): return operand . denominator () else : return operand . denominator else : raise TypeError ( f \" { operand !r} has no denominator\" ) imag ( operand : SupportsRealImagMixedU ) Helper function that extracts the imaginary part from operand including resolving non-compliant implementations that implement such extraction via a as_real_imag method rather than as properties. 1 2 3 4 >>> import sympy >>> from numerary.types import real >>> imag ( sympy . Float ( 3.5 )) 0 See SupportsRealImag and SupportsRealImagAsMethod . Source code in numerary/types.py @beartype def imag ( operand : SupportsRealImagMixedU ): r \"\"\" Helper function that extracts the imaginary part from *operand* including resolving non-compliant implementations that implement such extraction via a ``as_real_imag`` method rather than as properties. ``` python >>> import sympy >>> from numerary.types import real >>> imag(sympy.Float(3.5)) 0 ``` See [SupportsRealImag][numerary.types.SupportsRealImag] and [SupportsRealImagAsMethod][numerary.types.SupportsRealImagAsMethod]. \"\"\" if callable ( getattr ( operand , \"as_real_imag\" , None )): _ , imag_part = operand . as_real_imag () # type: ignore [union-attr] return imag_part elif hasattr ( operand , \"imag\" ): return operand . imag # type: ignore [union-attr] else : raise TypeError ( f \" { operand !r} has no real or as_real_imag\" ) numerator ( operand : SupportsNumeratorDenominatorMixedU ) Helper function that extracts the numerator from operand including resolving non-compliant rational implementations that implement numerator as a method rather than a property. 1 2 3 4 >>> from fractions import Fraction >>> from numerary.types import numerator >>> numerator ( Fraction ( 22 , 7 )) 22 See SupportsNumeratorDenominator and SupportsNumeratorDenominatorMethods . Source code in numerary/types.py @beartype def numerator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" Helper function that extracts the numerator from *operand* including resolving non-compliant rational implementations that implement ``numerator`` as a method rather than a property. ``` python >>> from fractions import Fraction >>> from numerary.types import numerator >>> numerator(Fraction(22, 7)) 22 ``` See [SupportsNumeratorDenominator][numerary.types.SupportsNumeratorDenominator] and [SupportsNumeratorDenominatorMethods][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" if hasattr ( operand , \"numerator\" ): if callable ( operand . numerator ): return operand . numerator () else : return operand . numerator else : raise TypeError ( f \" { operand !r} has no numerator\" ) real ( operand : SupportsRealImagMixedU ) Helper function that extracts the real part from operand including resolving non-compliant implementations that implement such extraction via a as_real_imag method rather than as properties. 1 2 3 4 >>> import sympy >>> from numerary.types import real >>> real ( sympy . Float ( 3.5 )) 3.5 See SupportsRealImag and SupportsRealImagAsMethod . Source code in numerary/types.py @beartype def real ( operand : SupportsRealImagMixedU ): r \"\"\" Helper function that extracts the real part from *operand* including resolving non-compliant implementations that implement such extraction via a ``as_real_imag`` method rather than as properties. ``` python >>> import sympy >>> from numerary.types import real >>> real(sympy.Float(3.5)) 3.5 ``` See [SupportsRealImag][numerary.types.SupportsRealImag] and [SupportsRealImagAsMethod][numerary.types.SupportsRealImagAsMethod]. \"\"\" if callable ( getattr ( operand , \"as_real_imag\" , None )): real_part , _ = operand . as_real_imag () # type: ignore [union-attr] return real_part elif hasattr ( operand , \"real\" ): return operand . real # type: ignore [union-attr] else : raise TypeError ( f \" { operand !r} has no real or as_real_imag\" ) RationalLikeMixedT RationalLikeMixedU SupportsNumeratorDenominatorMixedT SupportsNumeratorDenominatorMixedU SupportsRealImagMixedT SupportsRealImagMixedU _SupportsComplexOps ( Protocol ) private The raw, non-caching version of SupportsComplexOps . Source code in numerary/types.py @runtime_checkable class _SupportsComplexOps ( Protocol [ _T_co ]): r \"\"\" The raw, non-caching version of [``SupportsComplexOps``][numerary.types.SupportsComplexOps]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __add__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __radd__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __sub__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rsub__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __mul__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rmul__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __truediv__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rtruediv__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __neg__ ( self ) -> _T_co : pass @abstractmethod def __pos__ ( self ) -> _T_co : pass __slots__ : Union [ str , Iterable [ str ]] special __add__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __add__ ( self , other : Any ) -> _T_co : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __mul__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __mul__ ( self , other : Any ) -> _T_co : pass __neg__ ( self ) -> _T_co special Source code in numerary/types.py @abstractmethod def __neg__ ( self ) -> _T_co : pass __pos__ ( self ) -> _T_co special Source code in numerary/types.py @abstractmethod def __pos__ ( self ) -> _T_co : pass __radd__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __radd__ ( self , other : Any ) -> _T_co : pass __rmul__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rmul__ ( self , other : Any ) -> _T_co : pass __rsub__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rsub__ ( self , other : Any ) -> _T_co : pass __rtruediv__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rtruediv__ ( self , other : Any ) -> _T_co : pass __sub__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __sub__ ( self , other : Any ) -> _T_co : pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True __truediv__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __truediv__ ( self , other : Any ) -> _T_co : pass _SupportsComplexPow ( Protocol ) private The raw, non-caching version of SupportsComplexPow . Source code in numerary/types.py @runtime_checkable class _SupportsComplexPow ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsComplexPow``][numerary.types.SupportsComplexPow]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __pow__ ( self , exponent : Any ) -> Any : pass @abstractmethod def __rpow__ ( self , exponent : Any ) -> Any : pass __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __pow__ ( self , exponent : Any ) -> Any special Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any ) -> Any : pass __rpow__ ( self , exponent : Any ) -> Any special Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any ) -> Any : pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True _SupportsConjugate ( Protocol ) private The raw, non-caching version of SupportsConjugate . Source code in numerary/types.py @runtime_checkable class _SupportsConjugate ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsConjugate``][numerary.types.SupportsConjugate]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def conjugate ( self ) -> Any : pass __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True conjugate ( self ) -> Any Source code in numerary/types.py @abstractmethod def conjugate ( self ) -> Any : pass _SupportsDivmod ( Protocol ) private The raw, non-caching version of SupportsDivmod . Source code in numerary/types.py @runtime_checkable class _SupportsDivmod ( Protocol [ _T_co ]): r \"\"\" The raw, non-caching version of [``SupportsDivmod``][numerary.types.SupportsDivmod]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass @abstractmethod def __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass __slots__ : Union [ str , Iterable [ str ]] special __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ] special Source code in numerary/types.py @abstractmethod def __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ] special Source code in numerary/types.py @abstractmethod def __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True _SupportsFloorCeil ( Protocol ) private The raw, non-caching version of SupportsFloorCeil . Source code in numerary/types.py @runtime_checkable class _SupportsFloorCeil ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __floor__ ( self ) -> int : pass @abstractmethod def __ceil__ ( self ) -> int : pass __slots__ : Union [ str , Iterable [ str ]] special __ceil__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __ceil__ ( self ) -> int : pass __floor__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __floor__ ( self ) -> int : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True _SupportsIntegralOps ( Protocol ) private The raw, non-caching version of SupportsIntegralOps . Source code in numerary/types.py @runtime_checkable class _SupportsIntegralOps ( Protocol [ _T_co ]): r \"\"\" The raw, non-caching version of [``SupportsIntegralOps``][numerary.types.SupportsIntegralOps]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __lshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rlshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rrshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __and__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rand__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __xor__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rxor__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __or__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __ror__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __invert__ ( self ) -> _T_co : pass __slots__ : Union [ str , Iterable [ str ]] special __and__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __and__ ( self , other : Any ) -> _T_co : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __invert__ ( self ) -> _T_co special Source code in numerary/types.py @abstractmethod def __invert__ ( self ) -> _T_co : pass __lshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __lshift__ ( self , other : Any ) -> _T_co : pass __or__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __or__ ( self , other : Any ) -> _T_co : pass __rand__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rand__ ( self , other : Any ) -> _T_co : pass __rlshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rlshift__ ( self , other : Any ) -> _T_co : pass __ror__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __ror__ ( self , other : Any ) -> _T_co : pass __rrshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rrshift__ ( self , other : Any ) -> _T_co : pass __rshift__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rshift__ ( self , other : Any ) -> _T_co : pass __rxor__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rxor__ ( self , other : Any ) -> _T_co : pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True __xor__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __xor__ ( self , other : Any ) -> _T_co : pass _SupportsIntegralPow ( Protocol ) private The raw, non-caching version of SupportsIntegralPow . Source code in numerary/types.py @runtime_checkable class _SupportsIntegralPow ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsIntegralPow``][numerary.types.SupportsIntegralPow]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass @abstractmethod def __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any special Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any special Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True _SupportsNumeratorDenominator ( Protocol ) private The raw, non-caching version of SupportsNumeratorDenominator . Source code in numerary/types.py @runtime_checkable class _SupportsNumeratorDenominator ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass __slots__ : Union [ str , Iterable [ str ]] special denominator : int property readonly numerator : int property readonly __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True _SupportsNumeratorDenominatorMethods ( Protocol ) private The raw, non-caching version of SupportsNumeratorDenominatorMethods . Source code in numerary/types.py @runtime_checkable class _SupportsNumeratorDenominatorMethods ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsNumeratorDenominatorMethods``][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def numerator ( self ) -> SupportsInt : pass @abstractmethod def denominator ( self ) -> SupportsInt : pass __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True denominator ( self ) -> SupportsInt Source code in numerary/types.py @abstractmethod def denominator ( self ) -> SupportsInt : pass numerator ( self ) -> SupportsInt Source code in numerary/types.py @abstractmethod def numerator ( self ) -> SupportsInt : pass _SupportsRealImag ( Protocol ) private The raw, non-caching version of SupportsRealImag . Source code in numerary/types.py @runtime_checkable class _SupportsRealImag ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsRealImag``][numerary.types.SupportsRealImag]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @property def real ( self ) -> Any : pass @property def imag ( self ) -> Any : pass __slots__ : Union [ str , Iterable [ str ]] special imag : Any property readonly real : Any property readonly __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True _SupportsRealImagAsMethod ( Protocol ) private The raw, non-caching version of SupportsRealImagAsMethod . Source code in numerary/types.py @runtime_checkable class _SupportsRealImagAsMethod ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsRealImagAsMethod``][numerary.types.SupportsRealImagAsMethod]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def as_real_imag ( self ) -> Tuple [ Any , Any ]: pass __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True as_real_imag ( self ) -> Tuple [ Any , Any ] Source code in numerary/types.py @abstractmethod def as_real_imag ( self ) -> Tuple [ Any , Any ]: pass _SupportsRealOps ( Protocol ) private The raw, non-caching version of SupportsRealOps . Source code in numerary/types.py @runtime_checkable class _SupportsRealOps ( Protocol [ _T_co ]): r \"\"\" The raw, non-caching version of [``SupportsRealOps``][numerary.types.SupportsRealOps]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __lt__ ( self , other : Any ) -> bool : pass @abstractmethod def __le__ ( self , other : Any ) -> bool : pass @abstractmethod def __ge__ ( self , other : Any ) -> bool : pass @abstractmethod def __gt__ ( self , other : Any ) -> bool : pass @abstractmethod def __floordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass @abstractmethod def __rfloordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass @abstractmethod def __mod__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rmod__ ( self , other : Any ) -> _T_co : pass __slots__ : Union [ str , Iterable [ str ]] special __floordiv__ ( self , other : Any ) -> Any special Source code in numerary/types.py @abstractmethod def __floordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass __ge__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __ge__ ( self , other : Any ) -> bool : pass __gt__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __gt__ ( self , other : Any ) -> bool : pass __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __le__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __le__ ( self , other : Any ) -> bool : pass __lt__ ( self , other : Any ) -> bool special Source code in numerary/types.py @abstractmethod def __lt__ ( self , other : Any ) -> bool : pass __mod__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __mod__ ( self , other : Any ) -> _T_co : pass __rfloordiv__ ( self , other : Any ) -> Any special Source code in numerary/types.py @abstractmethod def __rfloordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass __rmod__ ( self , other : Any ) -> _T_co special Source code in numerary/types.py @abstractmethod def __rmod__ ( self , other : Any ) -> _T_co : pass __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True _SupportsTrunc ( Protocol ) private The raw, non-caching version of SupportsTrunc . Source code in numerary/types.py @runtime_checkable class _SupportsTrunc ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsTrunc``][numerary.types.SupportsTrunc]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __trunc__ ( self ) -> int : pass __slots__ : Union [ str , Iterable [ str ]] special __init__ ( self , * args , ** kwargs ) special Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' ) __subclasshook__ ( other ) special Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True __trunc__ ( self ) -> int special Source code in numerary/types.py @abstractmethod def __trunc__ ( self ) -> int : pass I acknowledge that the subject of who is awesomer, beartype or the man who made it, is hotly contested . \u21a9","title":"<tt>numerary.types</tt>"},{"location":"numerary.types/#numerarytypes-package-reference","text":"Experimental This package is an attempt to ease compatibility between Python\u2019s numbers and types. If that sounds like it shouldn\u2019t be a thing, you won\u2019t get any argument out of me. Anyhoo, this package should be considered experimental. I am working toward stability as quickly as possible, but be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are desperately appreciated. In addition to the following protocols and helper functions, numerary.types also resolves importing Annotated , Protocol , and runtime_checkable from the best available source. This can be helpful if you need to support Python versions prior to 3.9, but don\u2019t want to take a runtime dependency on typing_extensions unless needed. Instead of doing this all over the place \u2026 1 2 3 4 try : from typing import Annotated , Protocol , runtime_checkable except ImportError : from typing_extensions import Annotated , Protocol , runtime_checkable \u2026 you can do this instead \u2026 1 from numerary.types import Annotated , Protocol , runtime_checkable Bang. Done. Further, if you want to opportunistically take advantage of beartype without imposing a strict runtime dependency, you can do this: 1 from numerary.bt import beartype # will resolve to the identity decorator if beartype is unavailable at runtime Which you should totally do, because beartype is awesome . Its author is even awesomer . 1","title":"numerary.types package reference"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta","text":"Stand-in for Protocol \u2019s base class that caches results of __instancecheck__ , (which is otherwise really \ud83e\udd2cing expensive ). (When this was introduced, it resulted in about a 5\u00d7 performance increase for dyce \u2019s unit tests, which was the only benchmark I had at the time.) The downside is that this will yield unpredictable results for objects whose methods don\u2019t stem from any type (e.g., are assembled at runtime). I don\u2019t know of any real-world case where that would be true. We\u2019ll jump off that bridge when we come to it. Note that one can make an existing protocol a caching protocol through inheritance, but in order to be @runtime_checkable , the parent protocol also has to be @runtime_checkable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 >>> from abc import abstractmethod >>> from numerary.types import Protocol , runtime_checkable >>> @runtime_checkable ... class _MyProtocol ( Protocol ): # plain vanilla protocol ... @abstractmethod ... def myfunc ( self , arg : int ) -> str : ... pass >>> @runtime_checkable # redundant, but useful for documentation ... class MyProtocol ( ... _MyProtocol , ... Protocol , ... metaclass = CachingProtocolMeta , # caching version ... ): ... pass >>> class MyImplementation : ... def myfunc ( self , arg : int ) -> str : ... return str ( arg * - 2 + 5 ) >>> my_thing : MyProtocol = MyImplementation () >>> isinstance ( my_thing , MyProtocol ) True Source code in numerary/types.py class CachingProtocolMeta ( _ProtocolMeta ): r \"\"\" Stand-in for ``#!python Protocol``\u2019s base class that caches results of ``#!python __instancecheck__``, (which is otherwise [really \ud83e\udd2cing expensive](https://github.com/python/mypy/issues/3186#issuecomment-885718629)). (When this was introduced, it resulted in about a 5\u00d7 performance increase for [``dyce``](https://github.com/posita/dyce)\u2019s unit tests, which was the only benchmark I had at the time.) The downside is that this will yield unpredictable results for objects whose methods don\u2019t stem from any type (e.g., are assembled at runtime). I don\u2019t know of any real-world case where that would be true. We\u2019ll jump off that bridge when we come to it. Note that one can make an existing protocol a caching protocol through inheritance, but in order to be ``@runtime_checkable``, the parent protocol also has to be @runtime_checkable. ``` python >>> from abc import abstractmethod >>> from numerary.types import Protocol, runtime_checkable >>> @runtime_checkable ... class _MyProtocol(Protocol): # plain vanilla protocol ... @abstractmethod ... def myfunc(self, arg: int) -> str: ... pass >>> @runtime_checkable # redundant, but useful for documentation ... class MyProtocol( ... _MyProtocol, ... Protocol, ... metaclass=CachingProtocolMeta, # caching version ... ): ... pass >>> class MyImplementation: ... def myfunc(self, arg: int) -> str: ... return str(arg * -2 + 5) >>> my_thing: MyProtocol = MyImplementation() >>> isinstance(my_thing, MyProtocol) True ``` \"\"\" _abc_inst_check_cache : Dict [ Type , bool ] _abc_inst_check_cache_overridden : Dict [ Type , bool ] _abc_inst_check_cache_listeners : Set [ CachingProtocolMeta ] def __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any , ) -> _TT : # See <https://github.com/python/mypy/issues/9282> cls = super () . __new__ ( mcls , name , bases , namespace , ** kw ) # type: ignore [misc] # Prefixing this class member with \"_abc_\" is necessary to prevent it from being # considered part of the Protocol. (See # <https://github.com/python/cpython/blob/main/Lib/typing.py>.) cls . _abc_inst_check_cache = {} cls . _abc_inst_check_cache_overridden = {} cls . _abc_inst_check_cache_listeners = set () for base in bases : if hasattr ( base , \"_abc_inst_check_cache_listeners\" ): base . _abc_inst_check_cache_listeners . add ( cls ) return cls def __instancecheck__ ( cls , inst : Any ) -> bool : try : # This has to stay *super* tight! Even adding a mere assertion can add ~50% # to the best case runtime! return cls . _abc_inst_check_cache [ type ( inst )] except KeyError : # If you're going to do *anything*, do it here. Don't touch the rest of this # method if you can avoid it. inst_t = type ( inst ) bases_pass_muster = True for base in cls . __bases__ : if base is cls or base . __name__ in ( \"Protocol\" , \"Generic\" , \"object\" ): continue if not isinstance ( inst , base ): bases_pass_muster = False break cls . _abc_inst_check_cache [ inst_t ] = bases_pass_muster and cls . _check_only_my_attrs ( inst ) cls . _abc_inst_check_cache_overridden [ inst_t ] = False return cls . _abc_inst_check_cache [ inst_t ] def includes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsSpam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def spam(self) -> str: ... pass >>> class NoSpam: ... pass >>> isinstance(NoSpam(), SupportsSpam) False >>> SupportsSpam.includes(NoSpam) >>> isinstance(NoSpam(), SupportsSpam) True ``` !!! note This does not affect static type-checking. ``` python >>> my_spam: SupportsSpam = NoSpam() # type: ignore [assignment] # still generates a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = True cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t ) def excludes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsHam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def ham(self) -> str: ... pass >>> class NoHam: ... def ham(self) -> str: ... raise NotImplementedError >>> isinstance(NoHam(), SupportsHam) True >>> SupportsHam.excludes(NoHam) >>> isinstance(NoHam(), SupportsHam) False ``` !!! note This does not affect static type-checking. ``` python >>> my_ham: SupportsHam = NoHam() # does *not* generate a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = False cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t ) def reset_for ( cls , inst_t : Type ) -> None : r \"\"\" Clears any cached instance check for *inst_t*. \"\"\" if inst_t in cls . _abc_inst_check_cache : del cls . _abc_inst_check_cache [ inst_t ] del cls . _abc_inst_check_cache_overridden [ inst_t ] cls . _dirty_for ( inst_t ) def _check_only_my_attrs ( cls , inst : Any ) -> bool : attrs = set ( cls . __dict__ ) attrs . update ( cls . __dict__ . get ( \"__annotations__\" , {})) attrs . intersection_update ( _get_protocol_attrs ( cls )) for attr in attrs : if not hasattr ( inst , attr ): return False elif callable ( getattr ( cls , attr , None )) and getattr ( inst , attr ) is None : return False return True def _dirty_for ( cls , inst_t : Type ) -> None : for inheriting_cls in cls . _abc_inst_check_cache_listeners : if ( inst_t in inheriting_cls . _abc_inst_check_cache and not inheriting_cls . _abc_inst_check_cache_overridden [ inst_t ] ): del inheriting_cls . _abc_inst_check_cache [ inst_t ] del inheriting_cls . _abc_inst_check_cache_overridden [ inst_t ]","title":"CachingProtocolMeta"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in numerary/types.py def __new__ ( mcls : Type [ _TT ], name : str , bases : Tuple [ Type , ... ], namespace : Dict [ str , Any ], ** kw : Any , ) -> _TT : # See <https://github.com/python/mypy/issues/9282> cls = super () . __new__ ( mcls , name , bases , namespace , ** kw ) # type: ignore [misc] # Prefixing this class member with \"_abc_\" is necessary to prevent it from being # considered part of the Protocol. (See # <https://github.com/python/cpython/blob/main/Lib/typing.py>.) cls . _abc_inst_check_cache = {} cls . _abc_inst_check_cache_overridden = {} cls . _abc_inst_check_cache_listeners = set () for base in bases : if hasattr ( base , \"_abc_inst_check_cache_listeners\" ): base . _abc_inst_check_cache_listeners . add ( cls ) return cls","title":"__new__()"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta.excludes","text":"Registers inst_t as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsHam ( ... Protocol , ... metaclass = CachingProtocolMeta ... ): ... @abstractmethod ... def ham ( self ) -> str : ... pass >>> class NoHam : ... def ham ( self ) -> str : ... raise NotImplementedError >>> isinstance ( NoHam (), SupportsHam ) True >>> SupportsHam . excludes ( NoHam ) >>> isinstance ( NoHam (), SupportsHam ) False Note This does not affect static type-checking. 1 >>> my_ham : SupportsHam = NoHam () # does *not* generate a Mypy warning Source code in numerary/types.py def excludes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsHam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def ham(self) -> str: ... pass >>> class NoHam: ... def ham(self) -> str: ... raise NotImplementedError >>> isinstance(NoHam(), SupportsHam) True >>> SupportsHam.excludes(NoHam) >>> isinstance(NoHam(), SupportsHam) False ``` !!! note This does not affect static type-checking. ``` python >>> my_ham: SupportsHam = NoHam() # does *not* generate a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = False cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t )","title":"excludes()"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta.includes","text":"Registers inst_t as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta , Protocol , runtime_checkable >>> @runtime_checkable ... class SupportsSpam ( ... Protocol , ... metaclass = CachingProtocolMeta ... ): ... @abstractmethod ... def spam ( self ) -> str : ... pass >>> class NoSpam : ... pass >>> isinstance ( NoSpam (), SupportsSpam ) False >>> SupportsSpam . includes ( NoSpam ) >>> isinstance ( NoSpam (), SupportsSpam ) True Note This does not affect static type-checking. 1 >>> my_spam : SupportsSpam = NoSpam () # type: ignore [assignment] # still generates a Mypy warning Source code in numerary/types.py def includes ( cls , inst_t : Type ) -> None : r \"\"\" Registers *inst_t* as supporting the interface in the runtime type-checking cache. This overrides any prior cached value. ``` python >>> from abc import abstractmethod >>> from numerary.types import CachingProtocolMeta, Protocol, runtime_checkable >>> @runtime_checkable ... class SupportsSpam( ... Protocol, ... metaclass=CachingProtocolMeta ... ): ... @abstractmethod ... def spam(self) -> str: ... pass >>> class NoSpam: ... pass >>> isinstance(NoSpam(), SupportsSpam) False >>> SupportsSpam.includes(NoSpam) >>> isinstance(NoSpam(), SupportsSpam) True ``` !!! note This does not affect static type-checking. ``` python >>> my_spam: SupportsSpam = NoSpam() # type: ignore [assignment] # still generates a Mypy warning ``` \"\"\" cls . _abc_inst_check_cache [ inst_t ] = True cls . _abc_inst_check_cache_overridden [ inst_t ] = True cls . _dirty_for ( inst_t )","title":"includes()"},{"location":"numerary.types/#numerary.types.CachingProtocolMeta.reset_for","text":"Clears any cached instance check for inst_t . Source code in numerary/types.py def reset_for ( cls , inst_t : Type ) -> None : r \"\"\" Clears any cached instance check for *inst_t*. \"\"\" if inst_t in cls . _abc_inst_check_cache : del cls . _abc_inst_check_cache [ inst_t ] del cls . _abc_inst_check_cache_overridden [ inst_t ] cls . _dirty_for ( inst_t )","title":"reset_for()"},{"location":"numerary.types/#numerary.types.RationalLike","text":"A caching ABC that defines a core set of operations for interacting with rationals. It is a composition of: SupportsAbs SupportsFloat SupportsNumeratorDenominator SupportsRealOps SupportsComplexOps SupportsComplexPow Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from typing import TypeVar from numerary.types import CachingProtocolMeta , Protocol , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class RationalLike ( SupportsAbs [ T_co ], SupportsFloat , SupportsNumeratorDenominator , SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], SupportsComplexPow [ T_co ], Protocol [ T_co ], ): pass This is intended as a practically useful, but incomplete list. To enforce equivalence to numbers . Rational , one would also need: SupportsComplex SupportsConjugate SupportsRealImag SupportsRound SupportsTrunc SupportsFloorCeil SupportsDivmod Source code in numerary/types.py @runtime_checkable class RationalLike ( SupportsAbs [ _T_co ], SupportsFloat , SupportsNumeratorDenominator , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], SupportsComplexPow , Protocol [ _T_co ], ): r \"\"\" A caching ABC that defines a core set of operations for interacting with rationals. It is a composition of: * [``SupportsAbs``][numerary.types.SupportsAbs] * [``SupportsFloat``][numerary.types.SupportsFloat] * [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator] * [``SupportsRealOps``][numerary.types.SupportsRealOps] * [``SupportsComplexOps``][numerary.types.SupportsComplexOps] * [``SupportsComplexPow``][numerary.types.SupportsComplexPow] Basically: ``` python from typing import TypeVar from numerary.types import CachingProtocolMeta, Protocol, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class RationalLike( SupportsAbs[T_co], SupportsFloat, SupportsNumeratorDenominator, SupportsRealOps[T_co], SupportsComplexOps[T_co], SupportsComplexPow[T_co], Protocol[T_co], ): pass ``` This is intended as a practically useful, but incomplete list. To enforce equivalence to ``#!python numbers.Rational``, one would also need: * [``SupportsComplex``][numerary.types.SupportsComplex] * [``SupportsConjugate``][numerary.types.SupportsConjugate] * [``SupportsRealImag``][numerary.types.SupportsRealImag] * [``SupportsRound``][numerary.types.SupportsRound] * [``SupportsTrunc``][numerary.types.SupportsTrunc] * [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil] * [``SupportsDivmod``][numerary.types.SupportsDivmod] \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass","title":"RationalLike"},{"location":"numerary.types/#numerary.types.RationalLikeMethods","text":"A caching ABC that defines a core set of operations for interacting with rationals. It is identical to RationalLike with one important exception. Instead of SupportsNumeratorDenominator , this protocol provides SupportsNumeratorDenominatorMethods . Basically: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from typing import TypeVar from numerary.types import CachingProtocolMeta , Protocol , Supports \u2026 T_co = TypeVar ( \"T_co\" , covariant = True ) class RationalLikeMethods ( SupportsAbs [ T_co ], SupportsFloat , SupportsNumeratorDenominatorMethods , SupportsRealOps [ T_co ], SupportsComplexOps [ T_co ], SupportsComplexPow [ T_co ], Protocol [ T_co ], ): pass This is probably not very useful on its own, but is important to the construction of RationalLikeMixedU and RationalLikeMixedT . See also the numerator and denominator helper functions. 1 2 RationalLikeMixedU = typing . Union [ numerary . types . RationalLike , numerary . types . RationalLikeMethods ] RationalLikeMixedT = ( RationalLike , RationalLikeMethods ) Source code in numerary/types.py @runtime_checkable class RationalLikeMethods ( SupportsAbs [ _T_co ], SupportsFloat , SupportsNumeratorDenominatorMethods , SupportsRealOps [ _T_co ], SupportsComplexOps [ _T_co ], SupportsComplexPow , Protocol [ _T_co ], ): r \"\"\" A caching ABC that defines a core set of operations for interacting with rationals. It is identical to [``RationalLike``][numerary.types.RationalLike] with one important exception. Instead of [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator], this protocol provides [``SupportsNumeratorDenominatorMethods``][numerary.types.SupportsNumeratorDenominatorMethods]. Basically: ``` python from typing import TypeVar from numerary.types import CachingProtocolMeta, Protocol, Supports\u2026 T_co = TypeVar(\"T_co\", covariant=True) class RationalLikeMethods( SupportsAbs[T_co], SupportsFloat, SupportsNumeratorDenominatorMethods, SupportsRealOps[T_co], SupportsComplexOps[T_co], SupportsComplexPow[T_co], Protocol[T_co], ): pass ``` This is probably not very useful on its own, but is important to the construction of [``RationalLikeMixedU``][numerary.types.RationalLikeMixedU] and [``RationalLikeMixedT``][numerary.types.RationalLikeMixedT]. See also the [``numerator``][numerary.types.numerator] and [``denominator``][numerary.types.denominator] helper functions. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () # Must be able to instantiate it @abstractmethod def __init__ ( self , * args : Any , ** kw : Any ): pass @abstractmethod def __hash__ ( self ) -> int : pass","title":"RationalLikeMethods"},{"location":"numerary.types/#numerary.types.SupportsAbs","text":"A caching version of the typing.SupportsAbs ABC defining the __abs__ method with a covariant return value. Source code in numerary/types.py @runtime_checkable class SupportsAbs ( _SupportsAbs [ _T_co ], Protocol [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching version of the [``typing.SupportsAbs``](https://docs.python.org/3/library/typing.html#typing.SupportsAbs) ABC defining the [``__abs__`` method](https://docs.python.org/3/reference/datamodel.html#object.__abs__) with a covariant return value. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsAbs"},{"location":"numerary.types/#numerary.types.SupportsComplex","text":"A caching version of the typing.SupportsComplex ABC defining the __complex__ method . Source code in numerary/types.py @runtime_checkable class SupportsComplex ( _SupportsComplex , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching version of the [``typing.SupportsComplex``](https://docs.python.org/3/library/typing.html#typing.SupportsComplex) ABC defining the [``__complex__`` method](https://docs.python.org/3/reference/datamodel.html#object.__complex__). \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsComplex"},{"location":"numerary.types/#numerary.types.SupportsComplexOps","text":"A caching ABC defining the Complex operator methods with covariant return values. ( _SupportsComplexOps is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsComplexOps >>> MyComplexOpsT = TypeVar ( \"MyComplexOpsT\" , bound = SupportsComplexOps ) >>> def complex_ops_my_thing ( arg : MyComplexOpsT ) -> MyComplexOpsT : ... assert isinstance ( arg , SupportsComplexOps ) ... return arg * - 2 + 5 >>> complex_ops_my_thing ( 3 ) - 1 >>> from decimal import Decimal >>> complex_ops_my_thing ( Decimal ( \"2.5\" )) Decimal ( '0.0' ) >>> import sympy >>> complex_ops_my_thing ( sympy . Float ( 3.5 )) - 2.0 >>> type ( _ ) < class ' sympy . core . numbers . Float '> >>> # error: Value of type variable \"MyComplexOpsT\" of \"complex_ops_my_thing\" cannot be \"str\" >>> complex_ops_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsComplexOps ( _SupportsComplexOps [ _T_co ], Protocol [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``Complex`` operator methods](https://docs.python.org/3/library/numbers.html#numbers.Complex) with covariant return values. ([``_SupportsComplexOps``][numerary.types._SupportsComplexOps] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsComplexOps >>> MyComplexOpsT = TypeVar(\"MyComplexOpsT\", bound=SupportsComplexOps) >>> def complex_ops_my_thing(arg: MyComplexOpsT) -> MyComplexOpsT: ... assert isinstance(arg, SupportsComplexOps) ... return arg * -2 + 5 >>> complex_ops_my_thing(3) -1 >>> from decimal import Decimal >>> complex_ops_my_thing(Decimal(\"2.5\")) Decimal('0.0') >>> import sympy >>> complex_ops_my_thing(sympy.Float(3.5)) -2.0 >>> type(_) <class 'sympy.core.numbers.Float'> >>> # error: Value of type variable \"MyComplexOpsT\" of \"complex_ops_my_thing\" cannot be \"str\" >>> complex_ops_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsComplexOps"},{"location":"numerary.types/#numerary.types.SupportsComplexPow","text":"A caching ABC defining the Complex (i.e., non-modulo) versions of the __pow__ and __rpow__ . ( _SupportsComplexPow is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsComplexPow >>> MyComplexPowT = TypeVar ( \"MyComplexPowT\" , bound = SupportsComplexPow ) >>> def complex_pow_my_thing ( arg : MyComplexPowT ) -> MyComplexPowT : ... assert isinstance ( arg , SupportsComplexPow ) ... return arg ** - 2 >>> complex_pow_my_thing ( 3 ) 0.1111111111111111 >>> from decimal import Decimal >>> complex_pow_my_thing ( Decimal ( \"2.5\" )) Decimal ( '0.16' ) >>> import sympy >>> complex_pow_my_thing ( sympy . Float ( 3.5 )) 0.0816326530612245 >>> type ( _ ) < class ' sympy . core . numbers . Float '> >>> # error: Value of type variable \"MyComplexPowT\" of \"complex_pow_my_thing\" cannot be \"str\" >>> complex_pow_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsComplexPow ( _SupportsComplexPow , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the ``#!python Complex`` (i.e., non-modulo) versions of the [``__pow__``](https://docs.python.org/3/reference/datamodel.html#object.__pow__) and [``__rpow__``](https://docs.python.org/3/reference/datamodel.html#object.__rpow__). ([``_SupportsComplexPow``][numerary.types._SupportsComplexPow] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsComplexPow >>> MyComplexPowT = TypeVar(\"MyComplexPowT\", bound=SupportsComplexPow) >>> def complex_pow_my_thing(arg: MyComplexPowT) -> MyComplexPowT: ... assert isinstance(arg, SupportsComplexPow) ... return arg ** -2 >>> complex_pow_my_thing(3) 0.1111111111111111 >>> from decimal import Decimal >>> complex_pow_my_thing(Decimal(\"2.5\")) Decimal('0.16') >>> import sympy >>> complex_pow_my_thing(sympy.Float(3.5)) 0.0816326530612245 >>> type(_) <class 'sympy.core.numbers.Float'> >>> # error: Value of type variable \"MyComplexPowT\" of \"complex_pow_my_thing\" cannot be \"str\" >>> complex_pow_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsComplexPow"},{"location":"numerary.types/#numerary.types.SupportsConjugate","text":"A caching ABC defining the conjugate method . ( _SupportsConjugate is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import TypeVar >>> from numerary.types import SupportsConjugate >>> MyConjugateT = TypeVar ( \"MyConjugateT\" , bound = SupportsConjugate ) >>> def conjugate_my_thing ( arg : MyConjugateT ) -> MyConjugateT : ... assert isinstance ( arg , SupportsConjugate ) ... return arg . conjugate () >>> conjugate_my_thing ( 3 ) 3 >>> from decimal import Decimal >>> conjugate_my_thing ( Decimal ( 2.5 )) Decimal ( '2.5' ) >>> import sympy >>> conjugate_my_thing ( sympy . Float ( 3.5 )) 3.5 >>> type ( _ ) < class ' sympy . core . numbers . Float '> >>> # error: Value of type variable \"MyConjugateT\" of \"conjugate_my_thing\" cannot be \"str\" >>> conjugate_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsConjugate ( _SupportsConjugate , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``conjugate`` method](https://docs.python.org/3/library/numbers.html#numbers.Complex.conjugate). ([``_SupportsConjugate``][numerary.types._SupportsConjugate] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import TypeVar >>> from numerary.types import SupportsConjugate >>> MyConjugateT = TypeVar(\"MyConjugateT\", bound=SupportsConjugate) >>> def conjugate_my_thing(arg: MyConjugateT) -> MyConjugateT: ... assert isinstance(arg, SupportsConjugate) ... return arg.conjugate() >>> conjugate_my_thing(3) 3 >>> from decimal import Decimal >>> conjugate_my_thing(Decimal(2.5)) Decimal('2.5') >>> import sympy >>> conjugate_my_thing(sympy.Float(3.5)) 3.5 >>> type(_) <class 'sympy.core.numbers.Float'> >>> # error: Value of type variable \"MyConjugateT\" of \"conjugate_my_thing\" cannot be \"str\" >>> conjugate_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsConjugate"},{"location":"numerary.types/#numerary.types.SupportsDivmod","text":"A caching ABC defining the __divmod__ and __rdivmod__ methods. Each returns a 2-tuple of covariants. ( _SupportsDivmod is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsDivmod >>> MyDivmodT = TypeVar ( \"MyDivmodT\" , bound = SupportsDivmod ) >>> def divmod_my_thing ( arg : MyDivmodT , other : Any ) -> Tuple [ MyDivmodT , MyDivmodT ]: ... assert isinstance ( arg , SupportsDivmod ) ... return divmod ( arg , other ) >>> divmod_my_thing ( 2 , 1 ) ( 2 , 0 ) >>> from decimal import Decimal >>> divmod_my_thing ( Decimal ( 2.5 ), Decimal ( 1.5 )) ( Decimal ( '1' ), Decimal ( '1.0' )) >>> import sympy >>> divmod_my_thing ( sympy . Float ( 3.5 ), sympy . Float ( 1.5 )) ( 2 , 0.5 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' sympy . core . numbers . Integer '>, <class ' sympy . core . numbers . Float '>) >>> # error: Value of type variable \"MyDivmodT\" of \"divmod_my_thing\" cannot be \"str\" >>> divmod_my_thing ( \"not-a-number\" , \"still-not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsDivmod ( _SupportsDivmod [ _T_co ], Protocol [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``__divmod__``](https://docs.python.org/3/reference/datamodel.html#object.__divmod__) and [``__rdivmod__``](https://docs.python.org/3/reference/datamodel.html#object.__rdivmod__) methods. Each returns a 2-tuple of covariants. ([``_SupportsDivmod``][numerary.types._SupportsDivmod] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsDivmod >>> MyDivmodT = TypeVar(\"MyDivmodT\", bound=SupportsDivmod) >>> def divmod_my_thing(arg: MyDivmodT, other: Any) -> Tuple[MyDivmodT, MyDivmodT]: ... assert isinstance(arg, SupportsDivmod) ... return divmod(arg, other) >>> divmod_my_thing(2, 1) (2, 0) >>> from decimal import Decimal >>> divmod_my_thing(Decimal(2.5), Decimal(1.5)) (Decimal('1'), Decimal('1.0')) >>> import sympy >>> divmod_my_thing(sympy.Float(3.5), sympy.Float(1.5)) (2, 0.5) >>> tuple(type(i) for i in _) (<class 'sympy.core.numbers.Integer'>, <class 'sympy.core.numbers.Float'>) >>> # error: Value of type variable \"MyDivmodT\" of \"divmod_my_thing\" cannot be \"str\" >>> divmod_my_thing(\"not-a-number\", \"still-not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsDivmod"},{"location":"numerary.types/#numerary.types.SupportsFloat","text":"A caching version of the typing.SupportsFloat ABC defining the __float__ method . Source code in numerary/types.py @runtime_checkable class SupportsFloat ( _SupportsFloat , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching version of the [``typing.SupportsFloat``](https://docs.python.org/3/library/typing.html#typing.SupportsFloat) ABC defining the [``__float__`` method](https://docs.python.org/3/reference/datamodel.html#object.__float__). \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsFloat"},{"location":"numerary.types/#numerary.types.SupportsFloorCeil","text":"A caching ABC defining the __floor__ . and __ceil__ methods. ( _SupportsFloorCeil is the raw, non-caching version that defines the actual methods.) Note This is of limited value for Python versions prior to 3.9, since float . __floor__ and float . __ceil__ were not defined. If support for those environments is important, consider using SupportsFloat instead. See also the __floor__ and __ceil__ helper functions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsFloorCeil , __ceil__ , __floor__ >>> MyFloorCeilT = TypeVar ( \"MyFloorCeilT\" , bound = SupportsFloorCeil ) >>> def floor_ceil_my_thing ( arg : MyFloorCeilT ) -> Tuple [ int , int ]: ... assert isinstance ( arg , SupportsFloorCeil ) ... return __floor__ ( arg ), __ceil__ ( arg ) >>> floor_ceil_my_thing ( 3 ) ( 3 , 3 ) >>> from decimal import Decimal >>> floor_ceil_my_thing ( Decimal ( 2.5 )) ( 2 , 3 ) >>> import sympy >>> floor_ceil_my_thing ( sympy . Float ( 3.5 )) ( 3 , 4 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' sympy . core . numbers . Integer '>, <class ' sympy . core . numbers . Integer '>) >>> # error: Value of type variable \"MyFloorCeilT\" of \"floor_ceil_my_thing\" cannot be \"str\" >>> floor_ceil_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsFloorCeil ( _SupportsFloorCeil , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``__floor__``](https://docs.python.org/3/reference/datamodel.html#object.__floor__). and [``__ceil__``](https://docs.python.org/3/reference/datamodel.html#object.__ceil__) methods. ([``_SupportsFloorCeil``][numerary.types._SupportsFloorCeil] is the raw, non-caching version that defines the actual methods.) !!! note This is of limited value for Python versions prior to 3.9, since ``#!python float.__floor__`` and ``#!python float.__ceil__`` were not defined. If support for those environments is important, consider using [``SupportsFloat``][numerary.types.SupportsFloat] instead. See also the [``__floor__``][numerary.types.__floor__] and [``__ceil__``][numerary.types.__ceil__] helper functions. ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsFloorCeil, __ceil__, __floor__ >>> MyFloorCeilT = TypeVar(\"MyFloorCeilT\", bound=SupportsFloorCeil) >>> def floor_ceil_my_thing(arg: MyFloorCeilT) -> Tuple[int, int]: ... assert isinstance(arg, SupportsFloorCeil) ... return __floor__(arg), __ceil__(arg) >>> floor_ceil_my_thing(3) (3, 3) >>> from decimal import Decimal >>> floor_ceil_my_thing(Decimal(2.5)) (2, 3) >>> import sympy >>> floor_ceil_my_thing(sympy.Float(3.5)) (3, 4) >>> tuple(type(i) for i in _) (<class 'sympy.core.numbers.Integer'>, <class 'sympy.core.numbers.Integer'>) >>> # error: Value of type variable \"MyFloorCeilT\" of \"floor_ceil_my_thing\" cannot be \"str\" >>> floor_ceil_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsFloorCeil"},{"location":"numerary.types/#numerary.types.SupportsIndex","text":"A caching version of the typing.SupportsIndex ABC defining the __index__ method . Source code in numerary/types.py @runtime_checkable class SupportsIndex ( _SupportsIndex , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching version of the [``typing.SupportsIndex``](https://docs.python.org/3/library/typing.html#typing.SupportsIndex) ABC defining the [``__index__`` method](https://docs.python.org/3/reference/datamodel.html#object.__index__). \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsIndex"},{"location":"numerary.types/#numerary.types.SupportsInt","text":"A caching version of the typing.SupportsInt ABC defining the __int__ method . Source code in numerary/types.py @runtime_checkable class SupportsInt ( _SupportsInt , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching version of the [``typing.SupportsInt``](https://docs.python.org/3/library/typing.html#typing.SupportsInt) ABC defining the [``__int__`` method](https://docs.python.org/3/reference/datamodel.html#object.__int__). \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsInt"},{"location":"numerary.types/#numerary.types.SupportsIntegralOps","text":"A caching ABC defining the Integral operator methods with covariant return values. ( _SupportsIntegralOps is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsIntegralOps >>> MyIntegralOpsT = TypeVar ( \"MyIntegralOpsT\" , bound = SupportsIntegralOps ) >>> def integral_ops_my_thing ( arg : MyIntegralOpsT ) -> MyIntegralOpsT : ... assert isinstance ( arg , SupportsIntegralOps ) ... return arg << 1 >>> integral_ops_my_thing ( 3 ) 6 >>> import sympy >>> integral_ops_my_thing ( sympy . Integer ( 3 )) 6 >>> type ( _ ) < class ' sympy . core . numbers . Integer '> >>> # error: Value of type variable \"MyIntegralOpsT\" of \"integral_ops_my_thing\" cannot be \"str\" >>> integral_ops_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsIntegralOps ( _SupportsIntegralOps [ _T_co ], Protocol [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``Integral`` operator methods](https://docs.python.org/3/library/numbers.html#numbers.Integral) with covariant return values. ([``_SupportsIntegralOps``][numerary.types._SupportsIntegralOps] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsIntegralOps >>> MyIntegralOpsT = TypeVar(\"MyIntegralOpsT\", bound=SupportsIntegralOps) >>> def integral_ops_my_thing(arg: MyIntegralOpsT) -> MyIntegralOpsT: ... assert isinstance(arg, SupportsIntegralOps) ... return arg << 1 >>> integral_ops_my_thing(3) 6 >>> import sympy >>> integral_ops_my_thing(sympy.Integer(3)) 6 >>> type(_) <class 'sympy.core.numbers.Integer'> >>> # error: Value of type variable \"MyIntegralOpsT\" of \"integral_ops_my_thing\" cannot be \"str\" >>> integral_ops_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsIntegralOps"},{"location":"numerary.types/#numerary.types.SupportsIntegralPow","text":"A caching ABC defining the Integral (i.e., modulo) versions of the __pow__ and __rpow__ methods. ( _SupportsIntegralPow is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsIntegralPow >>> MyIntegralPowT = TypeVar ( \"MyIntegralPowT\" , bound = SupportsIntegralPow ) >>> def integral_pow_my_thing ( arg : MyIntegralPowT ) -> MyIntegralPowT : ... assert isinstance ( arg , SupportsIntegralPow ) ... return pow ( arg , 2 , 2 ) >>> integral_pow_my_thing ( 3 ) 1 >>> import sympy >>> integral_pow_my_thing ( sympy . Integer ( 3 )) 1 >>> type ( _ ) < class ' int '> >>> # error: Value of type variable \"MyIntegralPowT\" of \"integral_pow_my_thing\" cannot be \"str\" >>> integral_pow_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsIntegralPow ( _SupportsIntegralPow , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the ``#!python Integral`` (i.e., modulo) versions of the [``__pow__``](https://docs.python.org/3/reference/datamodel.html#object.__pow__) and [``__rpow__``](https://docs.python.org/3/reference/datamodel.html#object.__rpow__) methods. ([``_SupportsIntegralPow``][numerary.types._SupportsIntegralPow] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsIntegralPow >>> MyIntegralPowT = TypeVar(\"MyIntegralPowT\", bound=SupportsIntegralPow) >>> def integral_pow_my_thing(arg: MyIntegralPowT) -> MyIntegralPowT: ... assert isinstance(arg, SupportsIntegralPow) ... return pow(arg, 2, 2) >>> integral_pow_my_thing(3) 1 >>> import sympy >>> integral_pow_my_thing(sympy.Integer(3)) 1 >>> type(_) <class 'int'> >>> # error: Value of type variable \"MyIntegralPowT\" of \"integral_pow_my_thing\" cannot be \"str\" >>> integral_pow_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsIntegralPow"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominator","text":"A caching ABC defining the numerator and denominator properties. ( _SupportsNumeratorDenominator is the raw, non-caching version that defines the actual properties.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsNumeratorDenominator , denominator , numerator >>> MyNumDenomT = TypeVar ( \"MyNumDenomT\" , bound = SupportsNumeratorDenominator ) >>> def num_denom_my_thing ( arg : MyNumDenomT ) -> Tuple [ int , int ]: ... assert isinstance ( arg , SupportsNumeratorDenominator ) ... return numerator ( arg ), denominator ( arg ) >>> num_denom_my_thing ( 3 ) ( 3 , 1 ) >>> from fractions import Fraction >>> num_denom_my_thing ( Fraction ( 2 , 3 )) ( 2 , 3 ) >>> import sympy >>> num_denom_my_thing ( sympy . Rational ( 3 , 4 )) ( 3 , 4 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' int '>, <class ' int '>) >>> # error: Value of type variable \"MyNumDenomT\" of \"num_denom_my_thing\" cannot be \"str\" >>> num_denom_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsNumeratorDenominator ( _SupportsNumeratorDenominator , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``numerator``](https://docs.python.org/3/library/numbers.html#numbers.Rational.numerator) and [``denominator``](https://docs.python.org/3/library/numbers.html#numbers.Rational.denominator) properties. ([``_SupportsNumeratorDenominator``][numerary.types._SupportsNumeratorDenominator] is the raw, non-caching version that defines the actual properties.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsNumeratorDenominator, denominator, numerator >>> MyNumDenomT = TypeVar(\"MyNumDenomT\", bound=SupportsNumeratorDenominator) >>> def num_denom_my_thing(arg: MyNumDenomT) -> Tuple[int, int]: ... assert isinstance(arg, SupportsNumeratorDenominator) ... return numerator(arg), denominator(arg) >>> num_denom_my_thing(3) (3, 1) >>> from fractions import Fraction >>> num_denom_my_thing(Fraction(2, 3)) (2, 3) >>> import sympy >>> num_denom_my_thing(sympy.Rational(3, 4)) (3, 4) >>> tuple(type(i) for i in _) (<class 'int'>, <class 'int'>) >>> # error: Value of type variable \"MyNumDenomT\" of \"num_denom_my_thing\" cannot be \"str\" >>> num_denom_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsNumeratorDenominator"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMethods","text":"A caching ABC defining numerator and denominator methods. Each returns a SupportsInt . ( _SupportsNumeratorDenominatorMethods is the raw, non-caching version that defines the actual methods.) See also the numerator and denominator helper functions. Source code in numerary/types.py @runtime_checkable class SupportsNumeratorDenominatorMethods ( _SupportsNumeratorDenominatorMethods , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining ``#!python numerator`` and ``#!python denominator`` methods. Each returns a [``SupportsInt``][numerary.types.SupportsInt]. ([``_SupportsNumeratorDenominatorMethods``][numerary.types._SupportsNumeratorDenominatorMethods] is the raw, non-caching version that defines the actual methods.) See also the [``numerator``][numerary.types.numerator] and [``denominator``][numerary.types.denominator] helper functions. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsNumeratorDenominatorMethods"},{"location":"numerary.types/#numerary.types.SupportsRealImag","text":"A caching ABC defining the real and imag properties. ( _SupportsRealImag is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsRealImag , real , imag >>> MyRealImagT = TypeVar ( \"MyRealImagT\" , bound = SupportsRealImag ) >>> def real_imag_my_thing ( arg : MyRealImagT ) -> Tuple [ Any , Any ]: ... assert isinstance ( arg , SupportsRealImag ) ... return ( real ( arg ), imag ( arg )) >>> real_imag_my_thing ( 3 ) ( 3 , 0 ) >>> from decimal import Decimal >>> real_imag_my_thing ( Decimal ( 2.5 )) ( Decimal ( '2.5' ), Decimal ( '0' )) >>> # error: Value of type variable \"MyRealImagT\" of \"real_imag_my_thing\" cannot be \"str\" >>> real_imag_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsRealImag ( _SupportsRealImag , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``real``](https://docs.python.org/3/library/numbers.html#numbers.Complex.real) and [``imag``](https://docs.python.org/3/library/numbers.html#numbers.Complex.imag) properties. ([``_SupportsRealImag``][numerary.types._SupportsRealImag] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsRealImag, real, imag >>> MyRealImagT = TypeVar(\"MyRealImagT\", bound=SupportsRealImag) >>> def real_imag_my_thing(arg: MyRealImagT) -> Tuple[Any, Any]: ... assert isinstance(arg, SupportsRealImag) ... return (real(arg), imag(arg)) >>> real_imag_my_thing(3) (3, 0) >>> from decimal import Decimal >>> real_imag_my_thing(Decimal(2.5)) (Decimal('2.5'), Decimal('0')) >>> # error: Value of type variable \"MyRealImagT\" of \"real_imag_my_thing\" cannot be \"str\" >>> real_imag_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsRealImag"},{"location":"numerary.types/#numerary.types.SupportsRealImagAsMethod","text":"A caching ABC defining the as_real_imag method that returns a 2-tuple. ( _SupportsRealImagAsMethod is the raw, non-caching version that defines the actual methods.) See also the real and imag helper functions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsRealImagAsMethod , real , imag >>> MyRealImagAsMethodT = TypeVar ( \"MyRealImagAsMethodT\" , bound = SupportsRealImagAsMethod ) >>> def as_real_imag_my_thing ( arg : MyRealImagAsMethodT ) -> Tuple [ Any , Any ]: ... assert isinstance ( arg , SupportsRealImagAsMethod ) ... return ( real ( arg ), imag ( arg )) >>> as_real_imag_my_thing ( sympy . Float ( 3.5 )) ( 3.5 , 0 ) >>> tuple ( type ( i ) for i in _ ) ( < class ' sympy . core . numbers . Float '>, <class ' sympy . core . numbers . Zero '>) >>> # error: Value of type variable \"MyRealImagAsMethodT\" of \"as_real_imag_my_thing\" cannot be \"str\" >>> as_real_imag_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsRealImagAsMethod ( _SupportsRealImagAsMethod , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the ``#!python as_real_imag`` method that returns a 2-tuple. ([``_SupportsRealImagAsMethod``][numerary.types._SupportsRealImagAsMethod] is the raw, non-caching version that defines the actual methods.) See also the [``real``][numerary.types.real] and [``imag``][numerary.types.imag] helper functions. ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsRealImagAsMethod, real, imag >>> MyRealImagAsMethodT = TypeVar(\"MyRealImagAsMethodT\", bound=SupportsRealImagAsMethod) >>> def as_real_imag_my_thing(arg: MyRealImagAsMethodT) -> Tuple[Any, Any]: ... assert isinstance(arg, SupportsRealImagAsMethod) ... return (real(arg), imag(arg)) >>> as_real_imag_my_thing(sympy.Float(3.5)) (3.5, 0) >>> tuple(type(i) for i in _) (<class 'sympy.core.numbers.Float'>, <class 'sympy.core.numbers.Zero'>) >>> # error: Value of type variable \"MyRealImagAsMethodT\" of \"as_real_imag_my_thing\" cannot be \"str\" >>> as_real_imag_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsRealImagAsMethod"},{"location":"numerary.types/#numerary.types.SupportsRealOps","text":"A caching ABC defining the Real operator methods with covariant return values. ( _SupportsRealOps is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsRealOps >>> MyRealOpsT = TypeVar ( \"MyRealOpsT\" , bound = SupportsRealOps ) >>> def real_ops_my_thing ( arg : MyRealOpsT ) -> Any : ... assert isinstance ( arg , SupportsRealOps ) ... return arg // - 2 >>> real_ops_my_thing ( 3 ) - 2 >>> from decimal import Decimal >>> real_ops_my_thing ( Decimal ( \"2.5\" )) Decimal ( '-1' ) >>> import sympy >>> real_ops_my_thing ( sympy . Float ( 3.5 )) - 2 >>> type ( _ ) < class ' sympy . core . numbers . Integer '> >>> # error: Value of type variable \"MyRealOpsT\" of \"real_ops_my_thing\" cannot be \"str\" >>> real_ops_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsRealOps ( _SupportsRealOps [ _T_co ], Protocol [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``Real`` operator methods](https://docs.python.org/3/library/numbers.html#numbers.Real) with covariant return values. ([``_SupportsRealOps``][numerary.types._SupportsRealOps] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsRealOps >>> MyRealOpsT = TypeVar(\"MyRealOpsT\", bound=SupportsRealOps) >>> def real_ops_my_thing(arg: MyRealOpsT) -> Any: ... assert isinstance(arg, SupportsRealOps) ... return arg // -2 >>> real_ops_my_thing(3) -2 >>> from decimal import Decimal >>> real_ops_my_thing(Decimal(\"2.5\")) Decimal('-1') >>> import sympy >>> real_ops_my_thing(sympy.Float(3.5)) -2 >>> type(_) <class 'sympy.core.numbers.Integer'> >>> # error: Value of type variable \"MyRealOpsT\" of \"real_ops_my_thing\" cannot be \"str\" >>> real_ops_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsRealOps"},{"location":"numerary.types/#numerary.types.SupportsRound","text":"A caching version of the typing.SupportsRound ABC defining the __round__ method with a covariant return value. Source code in numerary/types.py @runtime_checkable class SupportsRound ( _SupportsRound [ _T_co ], Protocol [ _T_co ], metaclass = CachingProtocolMeta , ): r \"\"\" A caching version of the [``typing.SupportsRound``](https://docs.python.org/3/library/typing.html#typing.SupportsRound) ABC defining the [``__round__`` method](https://docs.python.org/3/reference/datamodel.html#object.__round__) with a covariant return value. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsRound"},{"location":"numerary.types/#numerary.types.SupportsTrunc","text":"A caching ABC defining the __trunc__ method . See also the __trunc__ helper function . ( _SupportsTrunc is the raw, non-caching version that defines the actual methods.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 >>> from typing import Any , Tuple , TypeVar >>> from numerary.types import SupportsTrunc , __trunc__ >>> MyTruncT = TypeVar ( \"MyTruncT\" , bound = SupportsTrunc ) >>> def trunc_my_thing ( arg : MyTruncT ) -> Tuple [ Any , Any ]: ... assert isinstance ( arg , SupportsTrunc ) ... return __trunc__ ( arg ) >>> trunc_my_thing ( 3 ) 3 >>> from decimal import Decimal >>> trunc_my_thing ( Decimal ( 2.5 )) 2 >>> import sympy >>> trunc_my_thing ( sympy . Float ( 3.5 )) 3 >>> type ( _ ) < class ' sympy . core . numbers . Integer '> >>> # error: Value of type variable \"MyTruncT\" of \"trunc_my_thing\" cannot be \"str\" >>> trunc_my_thing ( \"not-a-number\" ) # type: ignore [type-var] Traceback ( most recent call last ): ... AssertionError Source code in numerary/types.py @runtime_checkable class SupportsTrunc ( _SupportsTrunc , Protocol , metaclass = CachingProtocolMeta , ): r \"\"\" A caching ABC defining the [``__trunc__`` method](https://docs.python.org/3/reference/datamodel.html#object.__trunc__). See also the [``__trunc__`` helper function][numerary.types.__trunc__]. ([``_SupportsTrunc``][numerary.types._SupportsTrunc] is the raw, non-caching version that defines the actual methods.) ``` python >>> from typing import Any, Tuple, TypeVar >>> from numerary.types import SupportsTrunc, __trunc__ >>> MyTruncT = TypeVar(\"MyTruncT\", bound=SupportsTrunc) >>> def trunc_my_thing(arg: MyTruncT) -> Tuple[Any, Any]: ... assert isinstance(arg, SupportsTrunc) ... return __trunc__(arg) >>> trunc_my_thing(3) 3 >>> from decimal import Decimal >>> trunc_my_thing(Decimal(2.5)) 2 >>> import sympy >>> trunc_my_thing(sympy.Float(3.5)) 3 >>> type(_) <class 'sympy.core.numbers.Integer'> >>> # error: Value of type variable \"MyTruncT\" of \"trunc_my_thing\" cannot be \"str\" >>> trunc_my_thing(\"not-a-number\") # type: ignore [type-var] Traceback (most recent call last): ... AssertionError ``` \"\"\" __slots__ : Union [ str , Iterable [ str ]] = ()","title":"SupportsTrunc"},{"location":"numerary.types/#numerary.types.__ceil__","text":"Helper function that wraps math.ceil . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsFloorCeil , __ceil__ >>> my_ceil : SupportsFloorCeil >>> my_ceil = 1 >>> __ceil__ ( my_ceil ) 1 >>> from fractions import Fraction >>> my_ceil = Fraction ( 1 , 2 ) >>> __ceil__ ( my_ceil ) 1 >>> my_ceil_float : SupportsFloat = 1.2 >>> __ceil__ ( my_ceil_float ) 2 Source code in numerary/types.py @beartype def __ceil__ ( operand : Union [ SupportsFloat , SupportsFloorCeil ]): r \"\"\" Helper function that wraps ``math.ceil``. ``` python >>> from numerary.types import SupportsFloat, SupportsFloorCeil, __ceil__ >>> my_ceil: SupportsFloorCeil >>> my_ceil = 1 >>> __ceil__(my_ceil) 1 >>> from fractions import Fraction >>> my_ceil = Fraction(1, 2) >>> __ceil__(my_ceil) 1 >>> my_ceil_float: SupportsFloat = 1.2 >>> __ceil__(my_ceil_float) 2 ``` \"\"\" return math . ceil ( operand ) # type: ignore [arg-type]","title":"__ceil__()"},{"location":"numerary.types/#numerary.types.__floor__","text":"Helper function that wraps math.floor . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsFloorCeil , __floor__ >>> my_floor : SupportsFloorCeil >>> my_floor = 1 >>> __floor__ ( my_floor ) 1 >>> from fractions import Fraction >>> my_floor = Fraction ( 1 , 2 ) >>> __floor__ ( my_floor ) 0 >>> my_floor_float : SupportsFloat = 1.2 >>> __floor__ ( my_floor_float ) 1 Source code in numerary/types.py @beartype def __floor__ ( operand : Union [ SupportsFloat , SupportsFloorCeil ]): r \"\"\" Helper function that wraps ``math.floor``. ``` python >>> from numerary.types import SupportsFloat, SupportsFloorCeil, __floor__ >>> my_floor: SupportsFloorCeil >>> my_floor = 1 >>> __floor__(my_floor) 1 >>> from fractions import Fraction >>> my_floor = Fraction(1, 2) >>> __floor__(my_floor) 0 >>> my_floor_float: SupportsFloat = 1.2 >>> __floor__(my_floor_float) 1 ``` \"\"\" return math . floor ( operand ) # type: ignore [arg-type]","title":"__floor__()"},{"location":"numerary.types/#numerary.types.__pow__","text":"Helper function that wraps pow to work with SupportsComplexPow , SupportsIntegralPow . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 >>> from numerary.types import SupportsComplexPow , SupportsIntegralPow , __pow__ >>> my_complex_pow : SupportsComplexPow = complex ( 2 ) >>> __pow__ ( my_complex_pow , 1 ) ( 2 + 0 j ) >>> __pow__ ( my_complex_pow , 1 , None ) ( 2 + 0 j ) >>> __pow__ ( my_complex_pow , 1 , 1 ) # type: ignore [operator] # properly caught by Mypy Traceback ( most recent call last ): ... ValueError : complex modulo >>> my_complex_pow = 1.2 >>> __pow__ ( my_complex_pow , 1 ) 1.2 >>> __pow__ ( my_complex_pow , 1 , None ) 1.2 >>> __pow__ ( my_complex_pow , 1 , 1 ) # ugh; *not* caught by Mypy because it treats floats as equivalent to ints? Traceback ( most recent call last ): ... TypeError : pow () 3 rd argument not allowed unless all arguments are integers >>> from fractions import Fraction >>> my_complex_pow = Fraction ( 1 , 2 ) >>> __pow__ ( my_complex_pow , 1 ) Fraction ( 1 , 2 ) >>> __pow__ ( my_complex_pow , 1 , None ) Fraction ( 1 , 2 ) >>> __pow__ ( my_complex_pow , 1 , 1 ) # type: ignore [operator] # properly caught by Mypy Traceback ( most recent call last ): ... TypeError : __pow__ () takes 2 positional arguments but 3 were given >>> from decimal import Decimal >>> my_integral_pow : SupportsIntegralPow = Decimal ( \"2\" ) >>> __pow__ ( my_integral_pow , 1 ) Decimal ( '2' ) >>> __pow__ ( my_integral_pow , 1 , None ) Decimal ( '2' ) >>> __pow__ ( my_integral_pow , 1 , 2 ) Decimal ( '0' ) >>> my_integral_pow = Decimal ( \"1.2\" ) # ruh-roh >>> __pow__ ( my_integral_pow , 1 ) Decimal ( '1.2' ) >>> __pow__ ( my_integral_pow , 1 , None ) Decimal ( '1.2' ) >>> __pow__ ( my_integral_pow , 1 , 2 ) # not catchable by Mypy, since it works *some* of the time Traceback ( most recent call last ): ... decimal . InvalidOperation : [ < class ' decimal . InvalidOperation '>] >>> my_integral_pow = 2 >>> __pow__ ( my_integral_pow , 1 ) 2 >>> __pow__ ( my_integral_pow , 1 , None ) 2 >>> __pow__ ( my_integral_pow , 1 , 2 ) 0 Source code in numerary/types.py @beartype def __pow__ ( arg : Union [ SupportsComplexPow , SupportsIntegralPow ], exponent : Any , modulus : Optional [ Any ] = None , ) -> Any : r \"\"\" Helper function that wraps ``pow`` to work with [``SupportsComplexPow``][numerary.types.SupportsComplexPow], [``SupportsIntegralPow``][numerary.types.SupportsIntegralPow]. ``` python >>> from numerary.types import SupportsComplexPow, SupportsIntegralPow, __pow__ >>> my_complex_pow: SupportsComplexPow = complex(2) >>> __pow__(my_complex_pow, 1) (2+0j) >>> __pow__(my_complex_pow, 1, None) (2+0j) >>> __pow__(my_complex_pow, 1, 1) # type: ignore [operator] # properly caught by Mypy Traceback (most recent call last): ... ValueError: complex modulo >>> my_complex_pow = 1.2 >>> __pow__(my_complex_pow, 1) 1.2 >>> __pow__(my_complex_pow, 1, None) 1.2 >>> __pow__(my_complex_pow, 1, 1) # ugh; *not* caught by Mypy because it treats floats as equivalent to ints? Traceback (most recent call last): ... TypeError: pow() 3rd argument not allowed unless all arguments are integers >>> from fractions import Fraction >>> my_complex_pow = Fraction(1, 2) >>> __pow__(my_complex_pow, 1) Fraction(1, 2) >>> __pow__(my_complex_pow, 1, None) Fraction(1, 2) >>> __pow__(my_complex_pow, 1, 1) # type: ignore [operator] # properly caught by Mypy Traceback (most recent call last): ... TypeError: __pow__() takes 2 positional arguments but 3 were given >>> from decimal import Decimal >>> my_integral_pow: SupportsIntegralPow = Decimal(\"2\") >>> __pow__(my_integral_pow, 1) Decimal('2') >>> __pow__(my_integral_pow, 1, None) Decimal('2') >>> __pow__(my_integral_pow, 1, 2) Decimal('0') >>> my_integral_pow = Decimal(\"1.2\") # ruh-roh >>> __pow__(my_integral_pow, 1) Decimal('1.2') >>> __pow__(my_integral_pow, 1, None) Decimal('1.2') >>> __pow__(my_integral_pow, 1, 2) # not catchable by Mypy, since it works *some* of the time Traceback (most recent call last): ... decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>] >>> my_integral_pow = 2 >>> __pow__(my_integral_pow, 1) 2 >>> __pow__(my_integral_pow, 1, None) 2 >>> __pow__(my_integral_pow, 1, 2) 0 ``` \"\"\" return pow ( arg , exponent , modulus )","title":"__pow__()"},{"location":"numerary.types/#numerary.types.__trunc__","text":"Helper function that wraps math.trunc . 1 2 3 4 5 6 7 8 9 10 11 12 >>> from numerary.types import SupportsFloat , SupportsTrunc , __trunc__ >>> my_trunc : SupportsTrunc >>> my_trunc = 1 >>> __trunc__ ( my_trunc ) 1 >>> from fractions import Fraction >>> my_trunc = Fraction ( 1 , 2 ) >>> __trunc__ ( my_trunc ) 0 >>> my_trunc_float : SupportsFloat = 1.2 >>> __trunc__ ( my_trunc_float ) 1 Source code in numerary/types.py @beartype def __trunc__ ( operand : Union [ SupportsFloat , SupportsTrunc ]): r \"\"\" Helper function that wraps ``math.trunc``. ``` python >>> from numerary.types import SupportsFloat, SupportsTrunc, __trunc__ >>> my_trunc: SupportsTrunc >>> my_trunc = 1 >>> __trunc__(my_trunc) 1 >>> from fractions import Fraction >>> my_trunc = Fraction(1, 2) >>> __trunc__(my_trunc) 0 >>> my_trunc_float: SupportsFloat = 1.2 >>> __trunc__(my_trunc_float) 1 ``` \"\"\" return math . trunc ( operand ) # type: ignore [arg-type]","title":"__trunc__()"},{"location":"numerary.types/#numerary.types.denominator","text":"Helper function that extracts the denominator from operand including resolving non-compliant rational implementations that implement denominator as a method rather than a property. 1 2 3 4 >>> from fractions import Fraction >>> from numerary.types import denominator >>> denominator ( Fraction ( 22 , 7 )) 7 See SupportsNumeratorDenominator and SupportsNumeratorDenominatorMethods . Source code in numerary/types.py @beartype def denominator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" Helper function that extracts the denominator from *operand* including resolving non-compliant rational implementations that implement ``denominator`` as a method rather than a property. ``` python >>> from fractions import Fraction >>> from numerary.types import denominator >>> denominator(Fraction(22, 7)) 7 ``` See [SupportsNumeratorDenominator][numerary.types.SupportsNumeratorDenominator] and [SupportsNumeratorDenominatorMethods][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" if hasattr ( operand , \"denominator\" ): if callable ( operand . denominator ): return operand . denominator () else : return operand . denominator else : raise TypeError ( f \" { operand !r} has no denominator\" )","title":"denominator()"},{"location":"numerary.types/#numerary.types.imag","text":"Helper function that extracts the imaginary part from operand including resolving non-compliant implementations that implement such extraction via a as_real_imag method rather than as properties. 1 2 3 4 >>> import sympy >>> from numerary.types import real >>> imag ( sympy . Float ( 3.5 )) 0 See SupportsRealImag and SupportsRealImagAsMethod . Source code in numerary/types.py @beartype def imag ( operand : SupportsRealImagMixedU ): r \"\"\" Helper function that extracts the imaginary part from *operand* including resolving non-compliant implementations that implement such extraction via a ``as_real_imag`` method rather than as properties. ``` python >>> import sympy >>> from numerary.types import real >>> imag(sympy.Float(3.5)) 0 ``` See [SupportsRealImag][numerary.types.SupportsRealImag] and [SupportsRealImagAsMethod][numerary.types.SupportsRealImagAsMethod]. \"\"\" if callable ( getattr ( operand , \"as_real_imag\" , None )): _ , imag_part = operand . as_real_imag () # type: ignore [union-attr] return imag_part elif hasattr ( operand , \"imag\" ): return operand . imag # type: ignore [union-attr] else : raise TypeError ( f \" { operand !r} has no real or as_real_imag\" )","title":"imag()"},{"location":"numerary.types/#numerary.types.numerator","text":"Helper function that extracts the numerator from operand including resolving non-compliant rational implementations that implement numerator as a method rather than a property. 1 2 3 4 >>> from fractions import Fraction >>> from numerary.types import numerator >>> numerator ( Fraction ( 22 , 7 )) 22 See SupportsNumeratorDenominator and SupportsNumeratorDenominatorMethods . Source code in numerary/types.py @beartype def numerator ( operand : SupportsNumeratorDenominatorMixedU ): r \"\"\" Helper function that extracts the numerator from *operand* including resolving non-compliant rational implementations that implement ``numerator`` as a method rather than a property. ``` python >>> from fractions import Fraction >>> from numerary.types import numerator >>> numerator(Fraction(22, 7)) 22 ``` See [SupportsNumeratorDenominator][numerary.types.SupportsNumeratorDenominator] and [SupportsNumeratorDenominatorMethods][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" if hasattr ( operand , \"numerator\" ): if callable ( operand . numerator ): return operand . numerator () else : return operand . numerator else : raise TypeError ( f \" { operand !r} has no numerator\" )","title":"numerator()"},{"location":"numerary.types/#numerary.types.real","text":"Helper function that extracts the real part from operand including resolving non-compliant implementations that implement such extraction via a as_real_imag method rather than as properties. 1 2 3 4 >>> import sympy >>> from numerary.types import real >>> real ( sympy . Float ( 3.5 )) 3.5 See SupportsRealImag and SupportsRealImagAsMethod . Source code in numerary/types.py @beartype def real ( operand : SupportsRealImagMixedU ): r \"\"\" Helper function that extracts the real part from *operand* including resolving non-compliant implementations that implement such extraction via a ``as_real_imag`` method rather than as properties. ``` python >>> import sympy >>> from numerary.types import real >>> real(sympy.Float(3.5)) 3.5 ``` See [SupportsRealImag][numerary.types.SupportsRealImag] and [SupportsRealImagAsMethod][numerary.types.SupportsRealImagAsMethod]. \"\"\" if callable ( getattr ( operand , \"as_real_imag\" , None )): real_part , _ = operand . as_real_imag () # type: ignore [union-attr] return real_part elif hasattr ( operand , \"real\" ): return operand . real # type: ignore [union-attr] else : raise TypeError ( f \" { operand !r} has no real or as_real_imag\" )","title":"real()"},{"location":"numerary.types/#numerary.types.RationalLikeMixedT","text":"","title":"RationalLikeMixedT"},{"location":"numerary.types/#numerary.types.RationalLikeMixedU","text":"","title":"RationalLikeMixedU"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMixedT","text":"","title":"SupportsNumeratorDenominatorMixedT"},{"location":"numerary.types/#numerary.types.SupportsNumeratorDenominatorMixedU","text":"","title":"SupportsNumeratorDenominatorMixedU"},{"location":"numerary.types/#numerary.types.SupportsRealImagMixedT","text":"","title":"SupportsRealImagMixedT"},{"location":"numerary.types/#numerary.types.SupportsRealImagMixedU","text":"","title":"SupportsRealImagMixedU"},{"location":"numerary.types/#numerary.types._SupportsComplexOps","text":"The raw, non-caching version of SupportsComplexOps . Source code in numerary/types.py @runtime_checkable class _SupportsComplexOps ( Protocol [ _T_co ]): r \"\"\" The raw, non-caching version of [``SupportsComplexOps``][numerary.types.SupportsComplexOps]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __add__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __radd__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __sub__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rsub__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __mul__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rmul__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __truediv__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rtruediv__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __neg__ ( self ) -> _T_co : pass @abstractmethod def __pos__ ( self ) -> _T_co : pass","title":"_SupportsComplexOps"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__add__","text":"Source code in numerary/types.py @abstractmethod def __add__ ( self , other : Any ) -> _T_co : pass","title":"__add__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__mul__","text":"Source code in numerary/types.py @abstractmethod def __mul__ ( self , other : Any ) -> _T_co : pass","title":"__mul__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__neg__","text":"Source code in numerary/types.py @abstractmethod def __neg__ ( self ) -> _T_co : pass","title":"__neg__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__pos__","text":"Source code in numerary/types.py @abstractmethod def __pos__ ( self ) -> _T_co : pass","title":"__pos__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__radd__","text":"Source code in numerary/types.py @abstractmethod def __radd__ ( self , other : Any ) -> _T_co : pass","title":"__radd__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__rmul__","text":"Source code in numerary/types.py @abstractmethod def __rmul__ ( self , other : Any ) -> _T_co : pass","title":"__rmul__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__rsub__","text":"Source code in numerary/types.py @abstractmethod def __rsub__ ( self , other : Any ) -> _T_co : pass","title":"__rsub__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__rtruediv__","text":"Source code in numerary/types.py @abstractmethod def __rtruediv__ ( self , other : Any ) -> _T_co : pass","title":"__rtruediv__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__sub__","text":"Source code in numerary/types.py @abstractmethod def __sub__ ( self , other : Any ) -> _T_co : pass","title":"__sub__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsComplexOps.__truediv__","text":"Source code in numerary/types.py @abstractmethod def __truediv__ ( self , other : Any ) -> _T_co : pass","title":"__truediv__()"},{"location":"numerary.types/#numerary.types._SupportsComplexPow","text":"The raw, non-caching version of SupportsComplexPow . Source code in numerary/types.py @runtime_checkable class _SupportsComplexPow ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsComplexPow``][numerary.types.SupportsComplexPow]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __pow__ ( self , exponent : Any ) -> Any : pass @abstractmethod def __rpow__ ( self , exponent : Any ) -> Any : pass","title":"_SupportsComplexPow"},{"location":"numerary.types/#numerary.types._SupportsComplexPow.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsComplexPow.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsComplexPow.__pow__","text":"Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any ) -> Any : pass","title":"__pow__()"},{"location":"numerary.types/#numerary.types._SupportsComplexPow.__rpow__","text":"Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any ) -> Any : pass","title":"__rpow__()"},{"location":"numerary.types/#numerary.types._SupportsComplexPow.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsConjugate","text":"The raw, non-caching version of SupportsConjugate . Source code in numerary/types.py @runtime_checkable class _SupportsConjugate ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsConjugate``][numerary.types.SupportsConjugate]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def conjugate ( self ) -> Any : pass","title":"_SupportsConjugate"},{"location":"numerary.types/#numerary.types._SupportsConjugate.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsConjugate.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsConjugate.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsConjugate.conjugate","text":"Source code in numerary/types.py @abstractmethod def conjugate ( self ) -> Any : pass","title":"conjugate()"},{"location":"numerary.types/#numerary.types._SupportsDivmod","text":"The raw, non-caching version of SupportsDivmod . Source code in numerary/types.py @runtime_checkable class _SupportsDivmod ( Protocol [ _T_co ]): r \"\"\" The raw, non-caching version of [``SupportsDivmod``][numerary.types.SupportsDivmod]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass @abstractmethod def __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass","title":"_SupportsDivmod"},{"location":"numerary.types/#numerary.types._SupportsDivmod.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsDivmod.__divmod__","text":"Source code in numerary/types.py @abstractmethod def __divmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass","title":"__divmod__()"},{"location":"numerary.types/#numerary.types._SupportsDivmod.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsDivmod.__rdivmod__","text":"Source code in numerary/types.py @abstractmethod def __rdivmod__ ( self , other : Any ) -> Tuple [ _T_co , _T_co ]: pass","title":"__rdivmod__()"},{"location":"numerary.types/#numerary.types._SupportsDivmod.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsFloorCeil","text":"The raw, non-caching version of SupportsFloorCeil . Source code in numerary/types.py @runtime_checkable class _SupportsFloorCeil ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsFloorCeil``][numerary.types.SupportsFloorCeil]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __floor__ ( self ) -> int : pass @abstractmethod def __ceil__ ( self ) -> int : pass","title":"_SupportsFloorCeil"},{"location":"numerary.types/#numerary.types._SupportsFloorCeil.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsFloorCeil.__ceil__","text":"Source code in numerary/types.py @abstractmethod def __ceil__ ( self ) -> int : pass","title":"__ceil__()"},{"location":"numerary.types/#numerary.types._SupportsFloorCeil.__floor__","text":"Source code in numerary/types.py @abstractmethod def __floor__ ( self ) -> int : pass","title":"__floor__()"},{"location":"numerary.types/#numerary.types._SupportsFloorCeil.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsFloorCeil.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps","text":"The raw, non-caching version of SupportsIntegralOps . Source code in numerary/types.py @runtime_checkable class _SupportsIntegralOps ( Protocol [ _T_co ]): r \"\"\" The raw, non-caching version of [``SupportsIntegralOps``][numerary.types.SupportsIntegralOps]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __lshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rlshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rrshift__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __and__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rand__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __xor__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rxor__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __or__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __ror__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __invert__ ( self ) -> _T_co : pass","title":"_SupportsIntegralOps"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__and__","text":"Source code in numerary/types.py @abstractmethod def __and__ ( self , other : Any ) -> _T_co : pass","title":"__and__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__invert__","text":"Source code in numerary/types.py @abstractmethod def __invert__ ( self ) -> _T_co : pass","title":"__invert__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__lshift__","text":"Source code in numerary/types.py @abstractmethod def __lshift__ ( self , other : Any ) -> _T_co : pass","title":"__lshift__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__or__","text":"Source code in numerary/types.py @abstractmethod def __or__ ( self , other : Any ) -> _T_co : pass","title":"__or__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rand__","text":"Source code in numerary/types.py @abstractmethod def __rand__ ( self , other : Any ) -> _T_co : pass","title":"__rand__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rlshift__","text":"Source code in numerary/types.py @abstractmethod def __rlshift__ ( self , other : Any ) -> _T_co : pass","title":"__rlshift__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__ror__","text":"Source code in numerary/types.py @abstractmethod def __ror__ ( self , other : Any ) -> _T_co : pass","title":"__ror__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rrshift__","text":"Source code in numerary/types.py @abstractmethod def __rrshift__ ( self , other : Any ) -> _T_co : pass","title":"__rrshift__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rshift__","text":"Source code in numerary/types.py @abstractmethod def __rshift__ ( self , other : Any ) -> _T_co : pass","title":"__rshift__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__rxor__","text":"Source code in numerary/types.py @abstractmethod def __rxor__ ( self , other : Any ) -> _T_co : pass","title":"__rxor__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralOps.__xor__","text":"Source code in numerary/types.py @abstractmethod def __xor__ ( self , other : Any ) -> _T_co : pass","title":"__xor__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow","text":"The raw, non-caching version of SupportsIntegralPow . Source code in numerary/types.py @runtime_checkable class _SupportsIntegralPow ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsIntegralPow``][numerary.types.SupportsIntegralPow]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass @abstractmethod def __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass","title":"_SupportsIntegralPow"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow.__pow__","text":"Source code in numerary/types.py @abstractmethod def __pow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass","title":"__pow__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow.__rpow__","text":"Source code in numerary/types.py @abstractmethod def __rpow__ ( self , exponent : Any , modulus : Optional [ Any ] = None ) -> Any : pass","title":"__rpow__()"},{"location":"numerary.types/#numerary.types._SupportsIntegralPow.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominator","text":"The raw, non-caching version of SupportsNumeratorDenominator . Source code in numerary/types.py @runtime_checkable class _SupportsNumeratorDenominator ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsNumeratorDenominator``][numerary.types.SupportsNumeratorDenominator]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass","title":"_SupportsNumeratorDenominator"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominator.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominator.denominator","text":"","title":"denominator"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominator.numerator","text":"","title":"numerator"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominator.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominator.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods","text":"The raw, non-caching version of SupportsNumeratorDenominatorMethods . Source code in numerary/types.py @runtime_checkable class _SupportsNumeratorDenominatorMethods ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsNumeratorDenominatorMethods``][numerary.types.SupportsNumeratorDenominatorMethods]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def numerator ( self ) -> SupportsInt : pass @abstractmethod def denominator ( self ) -> SupportsInt : pass","title":"_SupportsNumeratorDenominatorMethods"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods.denominator","text":"Source code in numerary/types.py @abstractmethod def denominator ( self ) -> SupportsInt : pass","title":"denominator()"},{"location":"numerary.types/#numerary.types._SupportsNumeratorDenominatorMethods.numerator","text":"Source code in numerary/types.py @abstractmethod def numerator ( self ) -> SupportsInt : pass","title":"numerator()"},{"location":"numerary.types/#numerary.types._SupportsRealImag","text":"The raw, non-caching version of SupportsRealImag . Source code in numerary/types.py @runtime_checkable class _SupportsRealImag ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsRealImag``][numerary.types.SupportsRealImag]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @property def real ( self ) -> Any : pass @property def imag ( self ) -> Any : pass","title":"_SupportsRealImag"},{"location":"numerary.types/#numerary.types._SupportsRealImag.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsRealImag.imag","text":"","title":"imag"},{"location":"numerary.types/#numerary.types._SupportsRealImag.real","text":"","title":"real"},{"location":"numerary.types/#numerary.types._SupportsRealImag.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsRealImag.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsRealImagAsMethod","text":"The raw, non-caching version of SupportsRealImagAsMethod . Source code in numerary/types.py @runtime_checkable class _SupportsRealImagAsMethod ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsRealImagAsMethod``][numerary.types.SupportsRealImagAsMethod]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def as_real_imag ( self ) -> Tuple [ Any , Any ]: pass","title":"_SupportsRealImagAsMethod"},{"location":"numerary.types/#numerary.types._SupportsRealImagAsMethod.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsRealImagAsMethod.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsRealImagAsMethod.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsRealImagAsMethod.as_real_imag","text":"Source code in numerary/types.py @abstractmethod def as_real_imag ( self ) -> Tuple [ Any , Any ]: pass","title":"as_real_imag()"},{"location":"numerary.types/#numerary.types._SupportsRealOps","text":"The raw, non-caching version of SupportsRealOps . Source code in numerary/types.py @runtime_checkable class _SupportsRealOps ( Protocol [ _T_co ]): r \"\"\" The raw, non-caching version of [``SupportsRealOps``][numerary.types.SupportsRealOps]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __lt__ ( self , other : Any ) -> bool : pass @abstractmethod def __le__ ( self , other : Any ) -> bool : pass @abstractmethod def __ge__ ( self , other : Any ) -> bool : pass @abstractmethod def __gt__ ( self , other : Any ) -> bool : pass @abstractmethod def __floordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass @abstractmethod def __rfloordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass @abstractmethod def __mod__ ( self , other : Any ) -> _T_co : pass @abstractmethod def __rmod__ ( self , other : Any ) -> _T_co : pass","title":"_SupportsRealOps"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__floordiv__","text":"Source code in numerary/types.py @abstractmethod def __floordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass","title":"__floordiv__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__ge__","text":"Source code in numerary/types.py @abstractmethod def __ge__ ( self , other : Any ) -> bool : pass","title":"__ge__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__gt__","text":"Source code in numerary/types.py @abstractmethod def __gt__ ( self , other : Any ) -> bool : pass","title":"__gt__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__le__","text":"Source code in numerary/types.py @abstractmethod def __le__ ( self , other : Any ) -> bool : pass","title":"__le__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__lt__","text":"Source code in numerary/types.py @abstractmethod def __lt__ ( self , other : Any ) -> bool : pass","title":"__lt__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__mod__","text":"Source code in numerary/types.py @abstractmethod def __mod__ ( self , other : Any ) -> _T_co : pass","title":"__mod__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__rfloordiv__","text":"Source code in numerary/types.py @abstractmethod def __rfloordiv__ ( self , other : Any ) -> Any : # TODO(posita): should be int pass","title":"__rfloordiv__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__rmod__","text":"Source code in numerary/types.py @abstractmethod def __rmod__ ( self , other : Any ) -> _T_co : pass","title":"__rmod__()"},{"location":"numerary.types/#numerary.types._SupportsRealOps.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsTrunc","text":"The raw, non-caching version of SupportsTrunc . Source code in numerary/types.py @runtime_checkable class _SupportsTrunc ( Protocol ): r \"\"\" The raw, non-caching version of [``SupportsTrunc``][numerary.types.SupportsTrunc]. \"\"\" __slots__ : Union [ str , Iterable [ str ]] = () @abstractmethod def __trunc__ ( self ) -> int : pass","title":"_SupportsTrunc"},{"location":"numerary.types/#numerary.types._SupportsTrunc.__slots__","text":"","title":"__slots__"},{"location":"numerary.types/#numerary.types._SupportsTrunc.__init__","text":"Source code in numerary/types.py def _no_init ( self , * args , ** kwargs ): raise TypeError ( 'Protocols cannot be instantiated' )","title":"__init__()"},{"location":"numerary.types/#numerary.types._SupportsTrunc.__subclasshook__","text":"Source code in numerary/types.py def _proto_hook ( other ): if not cls . __dict__ . get ( '_is_protocol' , False ): return NotImplemented # First, perform various sanity checks. if not getattr ( cls , '_is_runtime_protocol' , False ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Instance and class checks can only be used with\" \" @runtime_checkable protocols\" ) if not _is_callable_members_only ( cls ): if _allow_reckless_class_cheks (): return NotImplemented raise TypeError ( \"Protocols with non-method members\" \" don't support issubclass()\" ) if not isinstance ( other , type ): # Same error message as for issubclass(1, int). raise TypeError ( 'issubclass() arg 1 must be a class' ) # Second, perform the actual structural compatibility check. for attr in _get_protocol_attrs ( cls ): for base in other . __mro__ : # Check if the members appears in the class dictionary... if attr in base . __dict__ : if base . __dict__ [ attr ] is None : return NotImplemented break # ...or in annotations, if it is a sub-protocol. annotations = getattr ( base , '__annotations__' , {}) if ( isinstance ( annotations , collections . abc . Mapping ) and attr in annotations and issubclass ( other , Generic ) and other . _is_protocol ): break else : return NotImplemented return True","title":"__subclasshook__()"},{"location":"numerary.types/#numerary.types._SupportsTrunc.__trunc__","text":"Source code in numerary/types.py @abstractmethod def __trunc__ ( self ) -> int : pass I acknowledge that the subject of who is awesomer, beartype or the man who made it, is hotly contested . \u21a9","title":"__trunc__()"},{"location":"whytho/","text":"This story may feel familiar. If it does, you are in good company. Your pain is my pain. May it motivate us to grow and adapt. The calculation function\u2014An allegory We have a simple vision. We want to define an API that works with reals (not just float s), performs a calculation, and returns integers (not just int s). 1 2 3 4 5 >>> def deep_thought ( arg ): ... from time import sleep ... sleep ( 7_500_000 * 365.24219265 * 24 * 60 * 60 ) # doctest: +SKIP ... assert arg != 0 and arg ** 0 == 1 ... return 42 Native primitives We want to tell the world how to call it and what to expect in return, so we annotate it according to the standard advice to just use native types: 1 2 3 >>> def deep_thought_typed ( arg : float ) -> int : ... assert arg != 0 and arg ** 0 == 1 ... return 42 So simple! We\u2019re done, right? Not quite. We find that the runtime works well, but there are Mypy errors. 1 2 3 4 5 >>> deep_thought_typed ( 1.0 ) # this is fine ... 42 >>> from fractions import Fraction >>> deep_thought_typed ( Fraction ( 1 , 2 )) # type: ignore [arg-type] # ... but this fails 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_typed\" has incompatible type \"Fraction\"; expected \"float\" Numeric tower With a little research, we learn about the numeric tower [cue angelic singing] . Surely, it has the answer! Both float and Fraction are Real s. Let\u2019s test that to make sure. 1 2 3 4 5 6 7 >>> from numbers import Integral , Real >>> isinstance ( 42 , Integral ) True >>> isinstance ( 1.0 , Real ) True >>> isinstance ( Fraction ( 1 , 2 ), Real ) True Huzzah! What could be simpler? It appears a small tweak is all that is required! 1 2 3 >>> def deep_thought_towered ( arg : Real ) -> Integral : ... assert arg != 0 and arg ** 0 == 1 ... return 42 # type: ignore [return-value] # now this fails Without the # type: ignore , we get: 1 \u2026: error: Incompatible return value type (got \"int\", expected \"Integral\") Hold the phone. isinstance(42, Integral) was True , was it not? This is starting to get confusing. Erm \u2026 we mean native primitives or the numeric tower? 1 2 3 4 5 6 7 >>> from typing import Union >>> IntegralT = Union [ int , Integral ] >>> RealT = Union [ float , Real ] >>> def deep_thought_crumbling ( arg : RealT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 Well, that was odd , but such warts are a small price to pay. All is right in the world again! 1 2 3 4 5 6 7 >>> deep_thought_crumbling ( 1.0 ) 42 >>> deep_thought_crumbling ( Fraction ( 1 , 2 )) 42 >>> from decimal import Decimal >>> deep_thought_crumbling ( Decimal ( \"0.123\" )) # type: ignore [arg-type] # fail 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_crumbling\" has incompatible type \"Decimal\"; expected \"Union[float, Real]\" Oh, come on ! Native primitives, the numeric tower, or other things that define all the methods, but didn\u2019t (or couldn\u2019t) register in the numeric tower for some reason \ud83e\udd2c me. Do we just tack this onto the list? 1 2 3 4 5 6 7 >>> RealAndDecimalT = Union [ float , Real , Decimal ] >>> def deep_thought_toppled ( arg : RealAndDecimalT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 >>> deep_thought_toppled ( Decimal ( \"0.123\" )) 42 If we have to engage in these kinds of gymnastics just to reach escape velocity from the standard library, how the heck are we supposed to survive contact with numeric implementations we haven\u2019t even heard of yet?! We can\u2019t enumerate them all ! For many years, the numeric tower was declared a \u201cdead end\u201d by maintainers. Unsurprisingly, many longstanding library authors didn\u2019t see much benefit to conforming to its API. Adoption has grown, but we can\u2019t rely on it. What should we rely on, then? Surely the exalted few who have steered us away from one thing are prepared to steer us toward something else, no? Sadly, the apparent attitude of many seems to be, \u201cSomething, something, protocols? Meh. I don\u2019t know. We\u2019ll figure it out later.\u201d Protocols! Can we fix this with protocols? The standard library picked the low hanging fruit provides some simple precedents . Can we imitate those? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore [misc] >>> from typing import Iterable , Union >>> @runtime_checkable ... class SupportsNumeratorDenominator ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @property ... def numerator ( self ) -> int : ... pass ... @property ... def denominator ( self ) -> int : ... pass >>> def require_rational ( arg : SupportsNumeratorDenominator ) -> None : ... assert isinstance ( arg , SupportsNumeratorDenominator ) >>> require_rational ( 1 ) # yup >>> require_rational ( Fraction ( 1 , 2 )) # nice >>> require_rational ( 1.0 ) # type: ignore [arg-type] # floats don't have numerator/denominator properties Traceback ( most recent call last ): ... AssertionError Without the # type: ignore , we get: 1 2 3 \u2026: error: Argument 1 to \"require_rational\" has incompatible type \"float\"; expected \"SupportsNumeratorDenominator\" \u2026: note: \"float\" is missing following \"SupportsNumeratorDenominator\" protocol members: \u2026: note: denominator, numerator Oh. My. Godetia. Could this be it? Have we stumbled into the promised land? Puh \u2026 ROH \u2026 tih \u2026 caaahhhlllz \u2026 ! Let\u2019s see how they perform. First, let\u2019s get a baseline. 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), Rational ) 356 ns \u00b1 15.2 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), Rational ) 350 ns \u00b1 14.9 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), Rational ) 359 ns \u00b1 3.21 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) Source: perf_rational_baseline.ipy 1 2 3 4 5 6 7 8 9 10 11 12 from fractions import Fraction from numbers import Rational one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) t = Rational for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) Now let\u2019s compare that with our two-property protocol. 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), SupportsNumeratorDenominator ) 13 \u00b5s \u00b1 270 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), SupportsNumeratorDenominator ) 14 \u00b5s \u00b1 761 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), SupportsNumeratorDenominator ) 15.4 \u00b5s \u00b1 323 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) Source: perf_rational_protocol.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from fractions import Fraction from numbers import Rational from typing import Iterable , Protocol , Union , runtime_checkable one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) @runtime_checkable class SupportsNumeratorDenominator ( Protocol ): __slots__ : Union [ str , Iterable [ str ]] = () @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass t = SupportsNumeratorDenominator for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) That\u2019s forty times slower. \ud83d\ude36 And that\u2019s just with a two-property protocol. How much worse would it be if we had enumerated all the dunder methods? \ud83d\ude30 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), SupportsLotsOfNumberStuff ) 136 \u00b5s \u00b1 3.3 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 10000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), SupportsLotsOfNumberStuff ) 154 \u00b5s \u00b1 5.94 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 10000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), SupportsLotsOfNumberStuff ) 149 \u00b5s \u00b1 8.33 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 10000 loops each ) Source: perf_rational_big_protocol.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 from fractions import Fraction from numbers import Rational from numerary.types import ( # \"raw\" (non-caching) versions _SupportsComplexOps , _SupportsConjugate , _SupportsFloorCeil , _SupportsDivmod , _SupportsRealImag , _SupportsRealOps , _SupportsTrunc , ) from typing import ( Iterable , Protocol , SupportsAbs , SupportsFloat , SupportsComplex , SupportsRound , Union , runtime_checkable , ) one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) @runtime_checkable class SupportsLotsOfNumberStuff ( _SupportsRealOps , _SupportsComplexOps , _SupportsDivmod , _SupportsTrunc , _SupportsFloorCeil , _SupportsConjugate , _SupportsRealImag , SupportsAbs , SupportsFloat , SupportsComplex , SupportsRound , Protocol , ): __slots__ : Union [ str , Iterable [ str ]] = () @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass t = SupportsLotsOfNumberStuff for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) Over. Four. Hundred. Times. Slower. And that\u2019s not even all the methods! You know what? Never mind that. Where there\u2019s a will, there\u2019s a way. Note to self: Self, solve the performance problems with protocols later. But we\u2019re definitely onto something! Lies! Upon lies! Upon lies! All the way down! Let\u2019s do another one. Real numbers have comparisons that complex ones don\u2019t. That seems as good a place as any to tackle next. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore [misc] >>> from abc import abstractmethod >>> from typing import Any , Iterable , Union >>> @runtime_checkable ... class SupportsRealComparisons ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @abstractmethod ... def __lt__ ( self , other : Any ) -> bool : ... pass ... @abstractmethod ... def __le__ ( self , other : Any ) -> bool : ... pass ... @abstractmethod ... def __ge__ ( self , other : Any ) -> bool : ... pass ... @abstractmethod ... def __gt__ ( self , other : Any ) -> bool : ... pass >>> def require_real ( arg : SupportsRealComparisons ) -> None : ... assert isinstance ( arg , SupportsRealComparisons ) >>> require_real ( 1 ) >>> require_real ( Fraction ( 1 , 2 )) >>> require_real ( 1.0 ) >>> require_real ( complex ( 0 )) # type: ignore [arg-type] # should go ka-boom! Where was the ka-boom? There was supposed to be an earth-shattering ka-boom! Mypy spotted the error. Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"require_real\" has incompatible type \"complex\"; expected \"SupportsRealComparisons\" So what gives? Why does our protocol think a complex has comparisons at runtime? It\u2019s a complex number and complex numbers don\u2019t have those. The standard library says so ! 1 2 3 4 5 6 7 >>> from numbers import Complex >>> isinstance ( complex ( 0 ), Complex ) True >>> hasattr ( Complex , \"__le__\" ) True >>> complex ( 0 ) . __le__ # type: ignore [operator] <... method ... complex ...> What the shit? Do they work? 1 2 3 4 >>> complex ( 0 ) <= complex ( 0 ) # type: ignore [operator] Traceback ( most recent call last ): ... TypeError : '<=' not supported between instances of 'complex' and 'complex' Wait. Complex numbers implement comparisons in complete contradiction to the documentation just to return NotImplemented ?! \ud83e\udd2c off ! How does Mypy know? Because the type definitions for complex and Complex are lies that conveniently omit mention of those methods. Quote \u201cWhen it becomes serious, you have to lie.\u201d \u2014Jean-Claude Juncker Do you see?! Do you see now why we can\u2019t have nice things?! I mean, I get casting as a rare case, but who builds sophisticated deception tooling into the very fabric a type definition mechanism to claim that non-compliant native primitives comply? How can you trust anything anymore?! Shouldn\u2019t that be a pretty strong hint that maybe you should step back and rethink your approach? Astute readers may note beartype could help restore Truth for us. 1 2 3 4 5 6 7 8 9 10 from beartype import beartype from beartype.vale import Is from typing import Annotated SupportsRealComparisonsNotComplexLies = Annotated [ SupportsRealComparisons , Is [ lambda arg : not isinstance ( arg , complex )] ] @beartype def require_real ( arg : SupportsRealComparisonsNotComplexLies ) -> None : assert isinstance ( arg , SupportsRealComparisonsNotComplexLies ) That\u2019s because Bear is hip to the scene. Bear is down . Bear knows what\u2019s what. If you have a typing problem, if no one else can help, and if you can find them 1 , maybe you can hire the Bear-Team. I digress. What do we do?! Okay. Can we still work with any of this shit and have type-checking? Let\u2019s try. Because somebody \ud83e\udd2cing has to. That should be easy I just gave you the link . Twice . \u21a9","title":"Why would you do this?"},{"location":"whytho/#the-calculation-functionan-allegory","text":"We have a simple vision. We want to define an API that works with reals (not just float s), performs a calculation, and returns integers (not just int s). 1 2 3 4 5 >>> def deep_thought ( arg ): ... from time import sleep ... sleep ( 7_500_000 * 365.24219265 * 24 * 60 * 60 ) # doctest: +SKIP ... assert arg != 0 and arg ** 0 == 1 ... return 42","title":"The calculation function\u2014An allegory"},{"location":"whytho/#native-primitives","text":"We want to tell the world how to call it and what to expect in return, so we annotate it according to the standard advice to just use native types: 1 2 3 >>> def deep_thought_typed ( arg : float ) -> int : ... assert arg != 0 and arg ** 0 == 1 ... return 42 So simple! We\u2019re done, right? Not quite. We find that the runtime works well, but there are Mypy errors. 1 2 3 4 5 >>> deep_thought_typed ( 1.0 ) # this is fine ... 42 >>> from fractions import Fraction >>> deep_thought_typed ( Fraction ( 1 , 2 )) # type: ignore [arg-type] # ... but this fails 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_typed\" has incompatible type \"Fraction\"; expected \"float\"","title":"Native primitives"},{"location":"whytho/#numeric-tower","text":"With a little research, we learn about the numeric tower [cue angelic singing] . Surely, it has the answer! Both float and Fraction are Real s. Let\u2019s test that to make sure. 1 2 3 4 5 6 7 >>> from numbers import Integral , Real >>> isinstance ( 42 , Integral ) True >>> isinstance ( 1.0 , Real ) True >>> isinstance ( Fraction ( 1 , 2 ), Real ) True Huzzah! What could be simpler? It appears a small tweak is all that is required! 1 2 3 >>> def deep_thought_towered ( arg : Real ) -> Integral : ... assert arg != 0 and arg ** 0 == 1 ... return 42 # type: ignore [return-value] # now this fails Without the # type: ignore , we get: 1 \u2026: error: Incompatible return value type (got \"int\", expected \"Integral\") Hold the phone. isinstance(42, Integral) was True , was it not? This is starting to get confusing.","title":"Numeric tower"},{"location":"whytho/#erm-we-mean-native-primitives-or-the-numeric-tower","text":"1 2 3 4 5 6 7 >>> from typing import Union >>> IntegralT = Union [ int , Integral ] >>> RealT = Union [ float , Real ] >>> def deep_thought_crumbling ( arg : RealT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 Well, that was odd , but such warts are a small price to pay. All is right in the world again! 1 2 3 4 5 6 7 >>> deep_thought_crumbling ( 1.0 ) 42 >>> deep_thought_crumbling ( Fraction ( 1 , 2 )) 42 >>> from decimal import Decimal >>> deep_thought_crumbling ( Decimal ( \"0.123\" )) # type: ignore [arg-type] # fail 42 Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"deep_thought_crumbling\" has incompatible type \"Decimal\"; expected \"Union[float, Real]\" Oh, come on !","title":"Erm \u2026 we mean native primitives or the numeric tower?"},{"location":"whytho/#native-primitives-the-numeric-tower-or-other-things-that-define-all-the-methods-but-didnt-or-couldnt-register-in-the-numeric-tower-for-some-reason","text":"\ud83e\udd2c me. Do we just tack this onto the list? 1 2 3 4 5 6 7 >>> RealAndDecimalT = Union [ float , Real , Decimal ] >>> def deep_thought_toppled ( arg : RealAndDecimalT ) -> IntegralT : ... assert arg != 0 and arg ** 0 == 1 ... return 42 >>> deep_thought_toppled ( Decimal ( \"0.123\" )) 42 If we have to engage in these kinds of gymnastics just to reach escape velocity from the standard library, how the heck are we supposed to survive contact with numeric implementations we haven\u2019t even heard of yet?! We can\u2019t enumerate them all ! For many years, the numeric tower was declared a \u201cdead end\u201d by maintainers. Unsurprisingly, many longstanding library authors didn\u2019t see much benefit to conforming to its API. Adoption has grown, but we can\u2019t rely on it. What should we rely on, then? Surely the exalted few who have steered us away from one thing are prepared to steer us toward something else, no? Sadly, the apparent attitude of many seems to be, \u201cSomething, something, protocols? Meh. I don\u2019t know. We\u2019ll figure it out later.\u201d","title":"Native primitives, the numeric tower, or other things that define all the methods, but didn\u2019t (or couldn\u2019t) register in the numeric tower for some reason"},{"location":"whytho/#protocols","text":"Can we fix this with protocols? The standard library picked the low hanging fruit provides some simple precedents . Can we imitate those? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore [misc] >>> from typing import Iterable , Union >>> @runtime_checkable ... class SupportsNumeratorDenominator ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @property ... def numerator ( self ) -> int : ... pass ... @property ... def denominator ( self ) -> int : ... pass >>> def require_rational ( arg : SupportsNumeratorDenominator ) -> None : ... assert isinstance ( arg , SupportsNumeratorDenominator ) >>> require_rational ( 1 ) # yup >>> require_rational ( Fraction ( 1 , 2 )) # nice >>> require_rational ( 1.0 ) # type: ignore [arg-type] # floats don't have numerator/denominator properties Traceback ( most recent call last ): ... AssertionError Without the # type: ignore , we get: 1 2 3 \u2026: error: Argument 1 to \"require_rational\" has incompatible type \"float\"; expected \"SupportsNumeratorDenominator\" \u2026: note: \"float\" is missing following \"SupportsNumeratorDenominator\" protocol members: \u2026: note: denominator, numerator Oh. My. Godetia. Could this be it? Have we stumbled into the promised land?","title":"Protocols!"},{"location":"whytho/#puh-roh-tih-caaahhhlllz","text":"Let\u2019s see how they perform. First, let\u2019s get a baseline. 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), Rational ) 356 ns \u00b1 15.2 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), Rational ) 350 ns \u00b1 14.9 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), Rational ) 359 ns \u00b1 3.21 ns per loop ( mean \u00b1 std . dev . of 7 runs , 1000000 loops each ) Source: perf_rational_baseline.ipy 1 2 3 4 5 6 7 8 9 10 11 12 from fractions import Fraction from numbers import Rational one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) t = Rational for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) Now let\u2019s compare that with our two-property protocol. 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), SupportsNumeratorDenominator ) 13 \u00b5s \u00b1 270 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), SupportsNumeratorDenominator ) 14 \u00b5s \u00b1 761 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), SupportsNumeratorDenominator ) 15.4 \u00b5s \u00b1 323 ns per loop ( mean \u00b1 std . dev . of 7 runs , 100000 loops each ) Source: perf_rational_protocol.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from fractions import Fraction from numbers import Rational from typing import Iterable , Protocol , Union , runtime_checkable one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) @runtime_checkable class SupportsNumeratorDenominator ( Protocol ): __slots__ : Union [ str , Iterable [ str ]] = () @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass t = SupportsNumeratorDenominator for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) That\u2019s forty times slower. \ud83d\ude36 And that\u2019s just with a two-property protocol. How much worse would it be if we had enumerated all the dunder methods? \ud83d\ude30 1 2 3 4 5 6 % timeit isinstance ( builtins . int ( 1 ), SupportsLotsOfNumberStuff ) 136 \u00b5s \u00b1 3.3 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 10000 loops each ) % timeit isinstance ( fractions . Fraction ( 2 ), SupportsLotsOfNumberStuff ) 154 \u00b5s \u00b1 5.94 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 10000 loops each ) % timeit isinstance ( builtins . float ( 3.0 ), SupportsLotsOfNumberStuff ) 149 \u00b5s \u00b1 8.33 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 10000 loops each ) Source: perf_rational_big_protocol.ipy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 from fractions import Fraction from numbers import Rational from numerary.types import ( # \"raw\" (non-caching) versions _SupportsComplexOps , _SupportsConjugate , _SupportsFloorCeil , _SupportsDivmod , _SupportsRealImag , _SupportsRealOps , _SupportsTrunc , ) from typing import ( Iterable , Protocol , SupportsAbs , SupportsFloat , SupportsComplex , SupportsRound , Union , runtime_checkable , ) one_int = 1 two_frac = Fraction ( 2 ) three_float = 3.0 vals = ( one_int , two_frac , three_float ) @runtime_checkable class SupportsLotsOfNumberStuff ( _SupportsRealOps , _SupportsComplexOps , _SupportsDivmod , _SupportsTrunc , _SupportsFloorCeil , _SupportsConjugate , _SupportsRealImag , SupportsAbs , SupportsFloat , SupportsComplex , SupportsRound , Protocol , ): __slots__ : Union [ str , Iterable [ str ]] = () @property def numerator ( self ) -> int : pass @property def denominator ( self ) -> int : pass t = SupportsLotsOfNumberStuff for v in vals : print ( f \"%timeit isinstance( { type ( v ) . __module__ } . { type ( v ) . __name__ } ( { v } ), { t . __name__ } )\" ) % timeit isinstance ( v , t ) Over. Four. Hundred. Times. Slower. And that\u2019s not even all the methods! You know what? Never mind that. Where there\u2019s a will, there\u2019s a way. Note to self: Self, solve the performance problems with protocols later. But we\u2019re definitely onto something!","title":"Puh \u2026 ROH \u2026 tih \u2026 caaahhhlllz \u2026 !"},{"location":"whytho/#lies-upon-lies-upon-lies-all-the-way-down","text":"Let\u2019s do another one. Real numbers have comparisons that complex ones don\u2019t. That seems as good a place as any to tackle next. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 >>> try : ... from typing import Protocol , runtime_checkable ... except ImportError : ... from typing_extensions import Protocol , runtime_checkable # type: ignore [misc] >>> from abc import abstractmethod >>> from typing import Any , Iterable , Union >>> @runtime_checkable ... class SupportsRealComparisons ( Protocol ): ... __slots__ : Union [ str , Iterable [ str ]] = () ... @abstractmethod ... def __lt__ ( self , other : Any ) -> bool : ... pass ... @abstractmethod ... def __le__ ( self , other : Any ) -> bool : ... pass ... @abstractmethod ... def __ge__ ( self , other : Any ) -> bool : ... pass ... @abstractmethod ... def __gt__ ( self , other : Any ) -> bool : ... pass >>> def require_real ( arg : SupportsRealComparisons ) -> None : ... assert isinstance ( arg , SupportsRealComparisons ) >>> require_real ( 1 ) >>> require_real ( Fraction ( 1 , 2 )) >>> require_real ( 1.0 ) >>> require_real ( complex ( 0 )) # type: ignore [arg-type] # should go ka-boom! Where was the ka-boom? There was supposed to be an earth-shattering ka-boom! Mypy spotted the error. Without the # type: ignore , we get: 1 \u2026: error: Argument 1 to \"require_real\" has incompatible type \"complex\"; expected \"SupportsRealComparisons\" So what gives? Why does our protocol think a complex has comparisons at runtime? It\u2019s a complex number and complex numbers don\u2019t have those. The standard library says so ! 1 2 3 4 5 6 7 >>> from numbers import Complex >>> isinstance ( complex ( 0 ), Complex ) True >>> hasattr ( Complex , \"__le__\" ) True >>> complex ( 0 ) . __le__ # type: ignore [operator] <... method ... complex ...> What the shit? Do they work? 1 2 3 4 >>> complex ( 0 ) <= complex ( 0 ) # type: ignore [operator] Traceback ( most recent call last ): ... TypeError : '<=' not supported between instances of 'complex' and 'complex' Wait. Complex numbers implement comparisons in complete contradiction to the documentation just to return NotImplemented ?! \ud83e\udd2c off ! How does Mypy know? Because the type definitions for complex and Complex are lies that conveniently omit mention of those methods. Quote \u201cWhen it becomes serious, you have to lie.\u201d \u2014Jean-Claude Juncker Do you see?! Do you see now why we can\u2019t have nice things?! I mean, I get casting as a rare case, but who builds sophisticated deception tooling into the very fabric a type definition mechanism to claim that non-compliant native primitives comply? How can you trust anything anymore?! Shouldn\u2019t that be a pretty strong hint that maybe you should step back and rethink your approach? Astute readers may note beartype could help restore Truth for us. 1 2 3 4 5 6 7 8 9 10 from beartype import beartype from beartype.vale import Is from typing import Annotated SupportsRealComparisonsNotComplexLies = Annotated [ SupportsRealComparisons , Is [ lambda arg : not isinstance ( arg , complex )] ] @beartype def require_real ( arg : SupportsRealComparisonsNotComplexLies ) -> None : assert isinstance ( arg , SupportsRealComparisonsNotComplexLies ) That\u2019s because Bear is hip to the scene. Bear is down . Bear knows what\u2019s what. If you have a typing problem, if no one else can help, and if you can find them 1 , maybe you can hire the Bear-Team. I digress.","title":"Lies! Upon lies! Upon lies! All the way down!"},{"location":"whytho/#what-do-we-do","text":"Okay. Can we still work with any of this shit and have type-checking? Let\u2019s try. Because somebody \ud83e\udd2cing has to. That should be easy I just gave you the link . Twice . \u21a9","title":"What do we do?!"}]}